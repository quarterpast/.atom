[{"diskText":"/**\n * FTScroller: touch and mouse-based scrolling for DOM elements larger than their containers.\n *\n * While this is a rewrite, it is heavily inspired by two projects:\n * 1) Uxebu TouchScroll (https://github.com/davidaurelio/TouchScroll), BSD licensed:\n *    Copyright (c) 2010 uxebu Consulting Ltd. & Co. KG\n *    Copyright (c) 2010 David Aurelio\n * 2) Zynga Scroller (https://github.com/zynga/scroller), MIT licensed:\n *    Copyright 2011, Zynga Inc.\n *    Copyright 2011, Deutsche Telekom AG\n *\n * Includes CubicBezier:\n *\n * Copyright (C) 2008 Apple Inc. All Rights Reserved.\n * Copyright (C) 2010 David Aurelio. All Rights Reserved.\n * Copyright (C) 2010 uxebu Consulting Ltd. & Co. KG. All Rights Reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY APPLE INC., DAVID AURELIO, AND UXEBU\n * CONSULTING LTD. & CO. KG ``AS IS'' AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL APPLE INC. OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *\n * @copyright The Financial Times Ltd [All rights reserved]\n * @codingstandard ftlabs-jslint\n * @version 0.5.1\n */\n/**\n * @license FTScroller is (c) 2012 The Financial Times Ltd [All rights reserved] and licensed under the MIT license.\n *\n * Inspired by Uxebu TouchScroll, (c) 2010 uxebu Consulting Ltd. & Co. KG and David Aurelio, which is BSD licensed (https://github.com/davidaurelio/TouchScroll)\n * Inspired by Zynga Scroller, (c) 2011 Zynga Inc and Deutsche Telekom AG, which is MIT licensed (https://github.com/zynga/scroller)\n * Includes CubicBezier, (c) 2008 Apple Inc [All rights reserved], (c) 2010 David Aurelio and uxebu Consulting Ltd. & Co. KG. [All rights reserved], which is 2-clause BSD licensed (see above or https://github.com/davidaurelio/TouchScroll).\n */\n\n/*jslint nomen: true, vars: true, browser: true, continue: true, white: true*/\n/*globals FTScrollerOptions*/\n\nvar FTScroller, CubicBezier;\n\n(function () {\n\t'use strict';\n\n\t// Determine the browser engine and prefix, trying to use the unprefixed version where available.\n\tvar _vendorCSSPrefix, _vendorStylePropertyPrefix, _vendorTransformLookup,\n\t\t_pointerEventsPrefixed, _setPointerCapture, _releasePointerCapture, _lostPointerCapture, _trackPointerEvents, _pointerTypeTouch;\n\tif (document.createElement('div').style.transform !== undefined) {\n\t\t_vendorCSSPrefix = '';\n\t\t_vendorStylePropertyPrefix = '';\n\t\t_vendorTransformLookup = 'transform';\n\t} else if (window.opera && Object.prototype.toString.call(window.opera) === '[object Opera]') {\n\t\t_vendorCSSPrefix = '-o-';\n\t\t_vendorStylePropertyPrefix = 'O';\n\t\t_vendorTransformLookup = 'OTransform';\n\t} else if (document.documentElement.style.MozTransform !== undefined) {\n\t\t_vendorCSSPrefix = '-moz-';\n\t\t_vendorStylePropertyPrefix = 'Moz';\n\t\t_vendorTransformLookup = 'MozTransform';\n\t} else if (document.documentElement.style.webkitTransform !== undefined) {\n\t\t_vendorCSSPrefix = '-webkit-';\n\t\t_vendorStylePropertyPrefix = 'webkit';\n\t\t_vendorTransformLookup = '-webkit-transform';\n\t} else if (typeof navigator.cpuClass === 'string') {\n\t\t_vendorCSSPrefix = '-ms-';\n\t\t_vendorStylePropertyPrefix = 'ms';\n\t\t_vendorTransformLookup = '-ms-transform';\n\t}\n\n\t// Pointer Events are unprefixed in IE11\n\tif ('pointerEnabled' in window.navigator) {\n\t\t_pointerEventsPrefixed = false;\n\t\t_trackPointerEvents    = window.navigator.pointerEnabled;\n\t\t_setPointerCapture     = 'setPointerCapture';\n\t\t_releasePointerCapture = 'releasePointerCapture';\n\t\t_lostPointerCapture    = 'lostpointercapture';\n\t\t_pointerTypeTouch      = 'touch';\n\t} else if ('msPointerEnabled' in window.navigator) {\n\t\t_pointerEventsPrefixed = true;\n\t\t_trackPointerEvents    = window.navigator.msPointerEnabled;\n\t\t_setPointerCapture     = 'msSetPointerCapture';\n\t\t_releasePointerCapture = 'msReleasePointerCapture';\n\t\t_lostPointerCapture    = 'MSLostPointerCapture';\n\t\t_pointerTypeTouch      = 2; // PointerEvent.MSPOINTER_TYPE_TOUCH = 2 in IE10\n\t}\n\n\t// Global flag to determine if any scroll is currently active.  This prevents\n\t// issues when using multiple scrollers, particularly when they're nested.\n\tvar _ftscrollerMoving = false;\n\n\t// Determine whether pointer events or touch events can be used\n\tvar _trackTouchEvents = false;\n\tif ('propertyIsEnumerable' in window || 'hasOwnProperty' in window.document) {\n\t\t_trackTouchEvents = !_trackPointerEvents && (window.propertyIsEnumerable('ontouchstart') || window.document.hasOwnProperty('ontouchstart'));\n\t}\n\n\t// Determine whether to use modern hardware acceleration rules or dynamic/toggleable rules.\n\t// Certain older browsers - particularly Android browsers - have problems with hardware\n\t// acceleration, so being able to toggle the behaviour dynamically via a CSS cascade is desirable.\n\tvar _useToggleableHardwareAcceleration = false;\n\tif ('hasOwnProperty' in window) {\n\t\t_useToggleableHardwareAcceleration = !window.hasOwnProperty('ArrayBuffer');\n\t}\n\n\t// Feature detection\n\tvar _canClearSelection = (window.Selection && window.Selection.prototype.removeAllRanges);\n\n\t// If hardware acceleration is using the standard path, but perspective doesn't seem to be supported,\n\t// 3D transforms likely aren't supported either\n\tif (!_useToggleableHardwareAcceleration && document.createElement('div').style[_vendorStylePropertyPrefix + (_vendorStylePropertyPrefix ? 'P' : 'p') + 'erspective'] === undefined) {\n\t\t_useToggleableHardwareAcceleration = true;\n\t}\n\n\t// Style prefixes\n\tvar _transformProperty = _vendorStylePropertyPrefix + (_vendorStylePropertyPrefix ? 'T' : 't') + 'ransform';\n\tvar _transitionProperty = _vendorStylePropertyPrefix + (_vendorStylePropertyPrefix ? 'T' : 't') + 'ransition';\n\tvar _translateRulePrefix = _useToggleableHardwareAcceleration ? 'translate(' : 'translate3d(';\n\tvar _transformPrefixes = { x: '', y: '0,' };\n\tvar _transformSuffixes = { x: ',0' + (_useToggleableHardwareAcceleration ? ')' : ',0)'), y: (_useToggleableHardwareAcceleration ? ')' : ',0)') };\n\n\t// Constants.  Note that the bezier curve should be changed along with the friction!\n\tvar _kFriction = 0.998;\n\tvar _kMinimumSpeed = 0.01;\n\n\t// Create a global stylesheet to set up stylesheet rules and track dynamic entries\n\t(function () {\n\t\tvar stylesheetContainerNode = document.getElementsByTagName('head')[0] || document.documentElement;\n\t\tvar newStyleNode = document.createElement('style');\n\t\tvar hardwareAccelerationRule;\n\t\tvar _styleText;\n\t\tnewStyleNode.type = 'text/css';\n\n\t\t// Determine the hardware acceleration logic to use\n\t\tif (_useToggleableHardwareAcceleration) {\n\t\t\thardwareAccelerationRule = _vendorCSSPrefix + 'transform-style: preserve-3d;';\n\t\t} else {\n\t\t\thardwareAccelerationRule = _vendorCSSPrefix + 'transform: translateZ(0);';\n\t\t}\n\n\t\t// Add our rules\n\t\t_styleText = [\n\t\t\t'.ftscroller_container { overflow: hidden; position: relative; max-height: 100%; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); -ms-touch-action: none }',\n\t\t\t'.ftscroller_hwaccelerated { ' + hardwareAccelerationRule  + ' }',\n\t\t\t'.ftscroller_x, .ftscroller_y { position: relative; min-width: 100%; min-height: 100%; overflow: hidden }',\n\t\t\t'.ftscroller_x { display: inline-block }',\n\t\t\t'.ftscroller_scrollbar { pointer-events: none; position: absolute; width: 5px; height: 5px; border: 1px solid rgba(255, 255, 255, 0.3); -webkit-border-radius: 3px; border-radius: 6px; opacity: 0; ' + _vendorCSSPrefix + 'transition: opacity 350ms; z-index: 10; -webkit-box-sizing: content-box; -moz-box-sizing: content-box; box-sizing: content-box }',\n\t\t\t'.ftscroller_scrollbarx { bottom: 2px; left: 2px }',\n\t\t\t'.ftscroller_scrollbary { right: 2px; top: 2px }',\n\t\t\t'.ftscroller_scrollbarinner { height: 100%; background: #000; -webkit-border-radius: 2px; border-radius: 4px / 6px }',\n\t\t\t'.ftscroller_scrollbar.active { opacity: 0.5; ' + _vendorCSSPrefix + 'transition: none; -o-transition: all 0 none }'\n\t\t];\n\n\t\tif (newStyleNode.styleSheet) {\n\t\t\tnewStyleNode.styleSheet.cssText = _styleText.join('\\n');\n\t\t} else {\n\t\t\tnewStyleNode.appendChild(document.createTextNode(_styleText.join('\\n')));\n\t\t}\n\n\t\t// Add the stylesheet\n\t\tstylesheetContainerNode.insertBefore(newStyleNode, stylesheetContainerNode.firstChild);\n\t}());\n\n\t/**\n\t * Master constructor for the scrolling function, including which element to\n\t * construct the scroller in, and any scrolling options.\n\t * Note that app-wide options can also be set using a global FTScrollerOptions\n\t * object.\n\t */\n\tFTScroller = function (domNode, options) {\n\t\tvar key;\n\t\tvar destroy, setSnapSize, scrollTo, scrollBy, updateDimensions, addEventListener, removeEventListener, setDisabledInputMethods, _startScroll, _updateScroll, _endScroll, _finalizeScroll, _interruptScroll, _flingScroll, _snapScroll, _getSnapPositionForIndexes, _getSnapIndexForPosition, _constrainAndRenderTargetScrollPosition, _limitToBounds, _initializeDOM, _existingDOMValid, _domChanged, _updateDimensions, _updateScrollbarDimensions, _updateElementPosition, _updateSegments, _setAxisPosition, _getPosition, _scheduleAxisPosition, _fireEvent, _childFocused, _modifyDistanceBeyondBounds, _distancesBeyondBounds, _startAnimation, _scheduleRender, _cancelAnimation, _addEventHandlers, _removeEventHandlers, _resetEventHandlers, _onTouchStart, _onTouchMove, _onTouchEnd, _onMouseDown, _onMouseMove, _onMouseUp, _onPointerDown, _onPointerMove, _onPointerUp, _onPointerCancel, _onPointerCaptureEnd, _onClick, _onMouseScroll, _captureInput, _releaseInputCapture, _getBoundingRect;\n\n\n\t\t/* Note that actual object instantiation occurs at the end of the closure to avoid jslint errors */\n\n\n\t\t/*                         Options                       */\n\n\t\tvar _instanceOptions = {\n\n\t\t\t// Whether to display scrollbars as appropriate\n\t\t\tscrollbars: true,\n\n\t\t\t// Enable scrolling on the X axis if content is available\n\t\t\tscrollingX: true,\n\n\t\t\t// Enable scrolling on the Y axis if content is available\n\t\t\tscrollingY: true,\n\n\t\t\t// The initial movement required to trigger a scroll, in pixels; this is the point at which\n\t\t\t// the scroll is exclusive to this particular FTScroller instance.\n\t\t\tscrollBoundary: 1,\n\n\t\t\t// The initial movement required to trigger a visual indication that scrolling is occurring,\n\t\t\t// in pixels.  This is enforced to be less than or equal to the scrollBoundary, and is used to\n\t\t\t// define when the scroller starts drawing changes in response to an input, even if the scroll\n\t\t\t// is not treated as having begun/locked yet.\n\t\t\tscrollResponseBoundary: 1,\n\n\t\t\t// Whether to always enable scrolling, even if the content of the scroller does not\n\t\t\t// require the scroller to function.  This makes the scroller behave more like an\n\t\t\t// element set to \"overflow: scroll\", with bouncing always occurring if enabled.\n\t\t\talwaysScroll: false,\n\n\t\t\t// The content width to use when determining scroller dimensions.  If this\n\t\t\t// is false, the width will be detected based on the actual content.\n\t\t\tcontentWidth: undefined,\n\n\t\t\t// The content height to use when determining scroller dimensions.  If this\n\t\t\t// is false, the height will be detected based on the actual content.\n\t\t\tcontentHeight: undefined,\n\n\t\t\t// Enable snapping of content to 'pages' or a pixel grid\n\t\t\tsnapping: false,\n\n\t\t\t// Define the horizontal interval of the pixel grid; snapping must be enabled for this to\n\t\t\t// take effect.  If this is not defined, snapping will use intervals based on container size.\n\t\t\tsnapSizeX: undefined,\n\n\t\t\t// Define the vertical interval of the pixel grid; snapping must be enabled for this to\n\t\t\t// take effect.  If this is not defined, snapping will use intervals based on container size.\n\t\t\tsnapSizeY: undefined,\n\n\t\t\t// Control whether snapping should be curtailed to only ever flick to the next page\n\t\t\t// and not beyond.  Snapping needs to be enabled for this to take effect.\n\t\t\tsinglePageScrolls: false,\n\n\t\t\t// Allow scroll bouncing and elasticity near the ends and grid\n\t\t\tbouncing: true,\n\n\t\t\t// Allow a fast scroll to continue with momentum when released\n\t\t\tflinging: true,\n\n\t\t\t// Automatically detects changes to the contained markup and\n\t\t\t// updates its dimensions whenever the content changes. This is\n\t\t\t// set to false if a contentWidth or contentHeight are supplied.\n\t\t\tupdateOnChanges: true,\n\n\t\t\t// Automatically catches changes to the window size and updates\n\t\t\t// its dimensions.\n\t\t\tupdateOnWindowResize: false,\n\n\t\t\t// The alignment to use if the content is smaller than the container;\n\t\t\t// this also applies to initial positioning of scrollable content.\n\t\t\t// Valid alignments are -1 (top or left), 0 (center), and 1 (bottom or right).\n\t\t\tbaseAlignments: { x: -1, y: -1 },\n\n\t\t\t// Whether to use a window scroll flag, eg window.foo, to control whether\n\t\t\t// to allow scrolling to start or now.  If the window flag is set to true,\n\t\t\t// this element will not start scrolling; this element will also toggle\n\t\t\t// the variable while scrolling\n\t\t\twindowScrollingActiveFlag: undefined,\n\n\t\t\t// Instead of always using translate3d for transforms, a mix of translate3d\n\t\t\t// and translate with a hardware acceleration class used to trigger acceleration\n\t\t\t// is used; this is to allow CSS inheritance to be used to allow dynamic\n\t\t\t// disabling of backing layers on older platforms.\n\t\t\thwAccelerationClass: 'ftscroller_hwaccelerated',\n\n\t\t\t// While use of requestAnimationFrame is highly recommended on platforms\n\t\t\t// which support it, it can result in the animation being a further half-frame\n\t\t\t// behind the input method, increasing perceived lag slightly.  To disable this,\n\t\t\t// set this property to false.\n\t\t\tenableRequestAnimationFrameSupport: true,\n\n\t\t\t// Set the maximum time (ms) that a fling can take to complete; if\n\t\t\t// this is not set, flings will complete instantly\n\t\t\tmaxFlingDuration: 1000,\n\n\t\t\t// Whether to disable any input methods; on some multi-input devices\n\t\t\t// custom behaviour may be desired for some scrollers.  Use with care!\n\t\t\tdisabledInputMethods: {\n\t\t\t\tmouse: false,\n\t\t\t\ttouch: false,\n\t\t\t\tscroll: false,\n\t\t\t\tpointer: false,\n\t\t\t\tfocus: false\n\t\t\t},\n\n\t\t\t// Define a scrolling class to be added to the scroller container\n\t\t\t// when scrolling is active.  Note that this can cause a relayout on\n\t\t\t// scroll start if defined, but allows custom styling in response to scrolls\n\t\t\tscrollingClassName: undefined,\n\n\t\t\t// Bezier curves defining the feel of the fling (momentum) deceleration,\n\t\t\t// the bounce decleration deceleration (as a fling exceeds the bounds),\n\t\t\t// and the bounce bezier (used for bouncing back).\n\t\t\tflingBezier: new CubicBezier(0.103, 0.389, 0.307, 0.966),\n\t\t\tbounceDecelerationBezier: new CubicBezier(0, 0.5, 0.5, 1),\n\t\t\tbounceBezier: new CubicBezier(0.7, 0, 0.9, 0.6)\n\t\t};\n\n\n\t\t/*                     Local variables                   */\n\n\t\t// Cache the DOM node and set up variables for other nodes\n\t\tvar _publicSelf;\n\t\tvar _self = this;\n\t\tvar _scrollableMasterNode = domNode;\n\t\tvar _containerNode;\n\t\tvar _contentParentNode;\n\t\tvar _scrollNodes = { x: null, y: null };\n\t\tvar _scrollbarNodes = { x: null, y: null };\n\n\t\t// Dimensions of the container element and the content element\n\t\tvar _metrics = {\n\t\t\tcontainer: { x: null, y: null },\n\t\t\tcontent: { x: null, y: null, rawX: null, rawY: null },\n\t\t\tscrollEnd: { x: null, y: null }\n\t\t};\n\n\t\t// Snapping details\n\t\tvar _snapGridSize = {\n\t\t\tx: false,\n\t\t\ty: false,\n\t\t\tuserX: false,\n\t\t\tuserY: false\n\t\t};\n\t\tvar _snapIndex = {\n\t\t\tx: 0,\n\t\t\ty: 0\n\t\t};\n\t\tvar _baseSegment = { x: 0, y: 0 };\n\t\tvar _activeSegment = { x: 0, y: 0 };\n\n\t\t// Track the identifier of any input being tracked\n\t\tvar _inputIdentifier = false;\n\t\tvar _inputIndex = 0;\n\t\tvar _inputCaptured = false;\n\n\t\t// Current scroll positions and tracking\n\t\tvar _isScrolling = false;\n\t\tvar _isDisplayingScroll = false;\n\t\tvar _isAnimating = false;\n\t\tvar _baseScrollPosition = { x: 0, y: 0 };\n\t\tvar _lastScrollPosition = { x: 0, y: 0 };\n\t\tvar _targetScrollPosition = { x: 0, y: 0 };\n\t\tvar _scrollAtExtremity = { x: null, y: null };\n\t\tvar _preventClick = false;\n\t\tvar _timeouts = [];\n\t\tvar _hasBeenScrolled = false;\n\n\t\t// Gesture details\n\t\tvar _baseScrollableAxes = {};\n\t\tvar _scrollableAxes = { x: true, y: true };\n\t\tvar _gestureStart = { x: 0, y: 0, t: 0 };\n\t\tvar _cumulativeScroll = { x: 0, y: 0 };\n\t\tvar _eventHistory = [];\n\n\t\t// Allow certain events to be debounced\n\t\tvar _domChangeDebouncer = false;\n\t\tvar _scrollWheelEndDebouncer = false;\n\n\t\t// Performance switches on browsers supporting requestAnimationFrame\n\t\tvar _animationFrameRequest = false;\n\t\tvar _reqAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || false;\n\t\tvar _cancelAnimationFrame = window.cancelAnimationFrame || window.cancelRequestAnimationFrame || window.mozCancelAnimationFrame || window.mozCancelRequestAnimationFrame || window.webkitCancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.msCancelAnimationFrame || window.msCancelRequestAnimationFrame || false;\n\n\t\t// Event listeners\n\t\tvar _eventListeners = {\n\t\t\t'scrollstart': [],\n\t\t\t'scroll': [],\n\t\t\t'scrollend': [],\n\t\t\t'segmentwillchange': [],\n\t\t\t'segmentdidchange': [],\n\t\t\t'reachedstart': [],\n\t\t\t'reachedend': [],\n\t\t\t'scrollinteractionend': []\n\t\t};\n\n\t\t// MutationObserver instance, when supported and if DOM change sniffing is enabled\n\t\tvar _mutationObserver;\n\n\n\t\t/* Parsing supplied options */\n\n\t\t// Override default instance options with global - or closure'd - options\n\t\tif (typeof FTScrollerOptions === 'object' && FTScrollerOptions) {\n\t\t\tfor (key in FTScrollerOptions) {\n\t\t\t\tif (FTScrollerOptions.hasOwnProperty(key) && _instanceOptions.hasOwnProperty(key)) {\n\t\t\t\t\t_instanceOptions[key] = FTScrollerOptions[key];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Override default and global options with supplied options\n\t\tif (options) {\n\t\t\tfor (key in options) {\n\t\t\t\tif (options.hasOwnProperty(key)) {\n\n\t\t\t\t\t// If a deprecated flag was passed in, warn, and convert to the new flag name\n\t\t\t\t\tif ('paginatedSnap' === key) {\n\t\t\t\t\t\tconsole.warn('FTScroller: \"paginatedSnap\" is deprecated; converting to \"singlePageScrolls\"');\n\t\t\t\t\t\t_instanceOptions.singlePageScrolls = options.paginatedSnap;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (_instanceOptions.hasOwnProperty(key)) {\n\t\t\t\t\t\t_instanceOptions[key] = options[key];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If snap grid size options were supplied, store them\n\t\t\tif (options.hasOwnProperty('snapSizeX') && !isNaN(options.snapSizeX)) {\n\t\t\t\t_snapGridSize.userX = _snapGridSize.x = options.snapSizeX;\n\t\t\t}\n\t\t\tif (options.hasOwnProperty('snapSizeY') && !isNaN(options.snapSizeY)) {\n\t\t\t\t_snapGridSize.userY = _snapGridSize.y = options.snapSizeY;\n\t\t\t}\n\n\t\t\t// If content width and height were defined, disable updateOnChanges for performance\n\t\t\tif (options.contentWidth && options.contentHeight) {\n\t\t\t\toptions.updateOnChanges = false;\n\t\t\t}\n\t\t}\n\n\t\t// Validate the scroll response parameter\n\t\t_instanceOptions.scrollResponseBoundary = Math.min(_instanceOptions.scrollBoundary, _instanceOptions.scrollResponseBoundary);\n\n\t\t// Update base scrollable axes\n\t\tif (_instanceOptions.scrollingX) {\n\t\t\t_baseScrollableAxes.x = true;\n\t\t}\n\t\tif (_instanceOptions.scrollingY) {\n\t\t\t_baseScrollableAxes.y = true;\n\t\t}\n\n\t\t// Only enable animation frame support if the instance options permit it\n\t\t_reqAnimationFrame = _instanceOptions.enableRequestAnimationFrameSupport && _reqAnimationFrame;\n\t\t_cancelAnimationFrame = _reqAnimationFrame && _cancelAnimationFrame;\n\n\n\t\t/*                    Scoped Functions                   */\n\n\t\t/**\n\t\t * Unbinds all event listeners to prevent circular references preventing items\n\t\t * from being deallocated, and clean up references to dom elements. Pass in\n\t\t * \"removeElements\" to also remove FTScroller DOM elements for special reuse cases.\n\t\t */\n\t\tdestroy = function destroy(removeElements) {\n\t\t\tvar i, l;\n\n\t\t\t_removeEventHandlers();\n\t\t\t_cancelAnimation();\n\t\t\tif (_domChangeDebouncer) {\n\t\t\t\twindow.clearTimeout(_domChangeDebouncer);\n\t\t\t\t_domChangeDebouncer = false;\n\t\t\t}\n\t\t\tfor (i = 0, l = _timeouts.length; i < l; i = i + 1) {\n\t\t\t\twindow.clearTimeout(_timeouts[i]);\n\t\t\t}\n\t\t\t_timeouts.length = 0;\n\n\t\t\t// Destroy DOM elements if required\n\t\t\tif (removeElements && _scrollableMasterNode) {\n\t\t\t\twhile (_contentParentNode.firstChild) {\n\t\t\t\t\t_scrollableMasterNode.appendChild(_contentParentNode.firstChild);\n\t\t\t\t}\n\t\t\t\t_scrollableMasterNode.removeChild(_containerNode);\n\t\t\t}\n\n\t\t\t_scrollableMasterNode = null;\n\t\t\t_containerNode = null;\n\t\t\t_contentParentNode = null;\n\t\t\t_scrollNodes.x = null;\n\t\t\t_scrollNodes.y = null;\n\t\t\t_scrollbarNodes.x = null;\n\t\t\t_scrollbarNodes.y = null;\n\t\t\tfor (i in _eventListeners) {\n\t\t\t\tif (_eventListeners.hasOwnProperty(i)) {\n\t\t\t\t\t_eventListeners[i].length = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If this is currently tracked as a scrolling instance, clear the flag\n\t\t\tif (_ftscrollerMoving && _ftscrollerMoving === _self) {\n\t\t\t\t_ftscrollerMoving = false;\n\t\t\t\tif (_instanceOptions.windowScrollingActiveFlag) {\n\t\t\t\t\twindow[_instanceOptions.windowScrollingActiveFlag] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Configures the snapping boundaries within the scrolling element if\n\t\t * snapping is active.  If this is never called, snapping defaults to\n\t\t * using the bounding box, eg page-at-a-time.\n\t\t */\n\t\tsetSnapSize = function setSnapSize(width, height) {\n\t\t\t_snapGridSize.userX = width;\n\t\t\t_snapGridSize.userY = height;\n\t\t\t_snapGridSize.x = width;\n\t\t\t_snapGridSize.y = height;\n\n\t\t\t// Ensure the content dimensions conform to the grid\n\t\t\t_metrics.content.x = Math.ceil(_metrics.content.rawX / width) * width;\n\t\t\t_metrics.content.y = Math.ceil(_metrics.content.rawY / height) * height;\n\t\t\t_metrics.scrollEnd.x = _metrics.container.x - _metrics.content.x;\n\t\t\t_metrics.scrollEnd.y = _metrics.container.y - _metrics.content.y;\n\t\t\t_updateScrollbarDimensions();\n\n\t\t\t// Snap to the new grid if necessary\n\t\t\t_snapScroll();\n\t\t\t_updateSegments(true);\n\t\t};\n\n\t\t/**\n\t\t * Scroll to a supplied position, including whether or not to animate the\n\t\t * scroll and how fast to perform the animation (pass in true to select a\n\t\t * dynamic duration).  The inputs will be constrained to bounds and snapped.\n\t\t * If false is supplied for a position, that axis will not be scrolled.\n\t\t */\n\t\tscrollTo = function scrollTo(left, top, animationDuration) {\n\t\t\tvar targetPosition, duration, positions, axis, maxDuration = 0, scrollPositionsToApply = {};\n\n\t\t\t// If a manual scroll is in progress, cancel it\n\t\t\t_endScroll(Date.now());\n\n\t\t\t// Move supplied coordinates into an object for iteration, also inverting the values into\n\t\t\t// our coordinate system\n\t\t\tpositions = {\n\t\t\t\tx: -left,\n\t\t\t\ty: -top\n\t\t\t};\n\n\t\t\tfor (axis in _baseScrollableAxes) {\n\t\t\t\tif (_baseScrollableAxes.hasOwnProperty(axis)) {\n\t\t\t\t\ttargetPosition = positions[axis];\n\t\t\t\t\tif (targetPosition === false) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Constrain to bounds\n\t\t\t\t\ttargetPosition = Math.min(0, Math.max(_metrics.scrollEnd[axis], targetPosition));\n\n\t\t\t\t\t// Snap if appropriate\n\t\t\t\t\tif (_instanceOptions.snapping && _snapGridSize[axis]) {\n\t\t\t\t\t\ttargetPosition = Math.round(targetPosition / _snapGridSize[axis]) * _snapGridSize[axis];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Get a duration\n\t\t\t\t\tduration = animationDuration || 0;\n\t\t\t\t\tif (duration === true) {\n\t\t\t\t\t\tduration = Math.sqrt(Math.abs(_baseScrollPosition[axis] - targetPosition)) * 20;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Trigger the position change\n\t\t\t\t\t_setAxisPosition(axis, targetPosition, duration);\n\t\t\t\t\tscrollPositionsToApply[axis] = targetPosition;\n\t\t\t\t\tmaxDuration = Math.max(maxDuration, duration);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If the scroll had resulted in a change in position, perform some additional actions:\n\t\t\tif (_baseScrollPosition.x !== positions.x || _baseScrollPosition.y !== positions.y) {\n\n\t\t\t\t// Mark a scroll as having ever occurred\n\t\t\t\t_hasBeenScrolled = true;\n\n\t\t\t\t// If an animation duration is present, fire a scroll start event and a\n\t\t\t\t// scroll event for any listeners to act on\n\t\t\t\t_fireEvent('scrollstart', _getPosition());\n\t\t\t\tconsole.log('firing scroll event from scrollTo');\n\t\t\t\t_fireEvent('scroll', _getPosition());\n\t\t\t}\n\n\t\t\tif (maxDuration) {\n\t\t\t\t_timeouts.push(setTimeout(function () {\n\t\t\t\t\tvar anAxis;\n\t\t\t\t\tfor (anAxis in scrollPositionsToApply) {\n\t\t\t\t\t\tif (scrollPositionsToApply.hasOwnProperty(anAxis)) {\n\t\t\t\t\t\t\t_lastScrollPosition[anAxis] = scrollPositionsToApply[anAxis];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t_finalizeScroll();\n\t\t\t\t}, maxDuration));\n\t\t\t} else {\n\t\t\t\t_finalizeScroll();\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Alter the current scroll position, including whether or not to animate\n\t\t * the scroll and how fast to perform the animation (pass in true to\n\t\t * select a dynamic duration).  The inputs will be checked against the\n\t\t * current position.\n\t\t */\n\t\tscrollBy = function scrollBy(horizontal, vertical, animationDuration) {\n\n\t\t\t// Wrap the scrollTo function for simplicity\n\t\t\tscrollTo(parseFloat(horizontal) - _baseScrollPosition.x, parseFloat(vertical) - _baseScrollPosition.y, animationDuration);\n\t\t};\n\n\t\t/**\n\t\t * Provide a public method to detect changes in dimensions for either the content or the\n\t\t * container.\n\t\t */\n\t\tupdateDimensions = function updateDimensions(contentWidth, contentHeight, ignoreSnapScroll) {\n\t\t\toptions.contentWidth = contentWidth || options.contentWidth;\n\t\t\toptions.contentHeight = contentHeight || options.contentHeight;\n\n\t\t\t// Currently just wrap the private API\n\t\t\t_updateDimensions(!!ignoreSnapScroll);\n\t\t};\n\n\t\t/**\n\t\t * Add an event handler for a supported event.  Current events include:\n\t\t * scroll - fired whenever the scroll position changes\n\t\t * scrollstart - fired when a scroll movement starts\n\t\t * scrollend - fired when a scroll movement ends\n\t\t * segmentwillchange - fired whenever the segment changes, including during scrolling\n\t\t * segmentdidchange - fired when a segment has conclusively changed, after scrolling.\n\t\t */\n\t\taddEventListener = function addEventListener(eventname, eventlistener) {\n\n\t\t\t// Ensure this is a valid event\n\t\t\tif (!_eventListeners.hasOwnProperty(eventname)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Add the listener\n\t\t\t_eventListeners[eventname].push(eventlistener);\n\t\t\treturn true;\n\t\t};\n\n\t\t/**\n\t\t * Remove an event handler for a supported event.  The listener must be exactly the same as\n\t\t * an added listener to be removed.\n\t\t */\n\t\tremoveEventListener = function removeEventListener(eventname, eventlistener) {\n\t\t\tvar i;\n\n\t\t\t// Ensure this is a valid event\n\t\t\tif (!_eventListeners.hasOwnProperty(eventname)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tfor (i = _eventListeners[eventname].length; i >= 0; i = i - 1) {\n\t\t\t\tif (_eventListeners[eventname][i] === eventlistener) {\n\t\t\t\t\t_eventListeners[eventname].splice(i, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\n\t\t/**\n\t\t * Set the input methods to disable. No inputs methods are disabled by default.\n\t\t * (object, default { mouse: false, touch: false, scroll: false, pointer: false, focus: false })\n\t\t */\n\t\tsetDisabledInputMethods = function setDisabledInputMethods(disabledInputMethods) {\n\t\t\tvar i, changed;\n\n\t\t\tfor (i in _instanceOptions.disabledInputMethods) {\n\t\t\t\tdisabledInputMethods[i] = !!disabledInputMethods[i];\n\n\t\t\t\tif (_instanceOptions.disabledInputMethods[i] !== disabledInputMethods[i]) changed = true;\n\t\t\t\t_instanceOptions.disabledInputMethods[i] = disabledInputMethods[i];\n\t\t\t}\n\n\t\t\tif (changed) {\n\t\t\t\t_resetEventHandlers();\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Start a scroll tracking input - this could be mouse, webkit-style touch,\n\t\t * or ms-style pointer events.\n\t\t */\n\t\t_startScroll = function _startScroll(inputX, inputY, inputTime, rawEvent) {\n\t\t\tvar triggerScrollInterrupt = _isAnimating;\n\n\t\t\t// Opera fix\n\t\t\tif (inputTime <= 0) {\n\t\t\t\tinputTime = Date.now();\n\t\t\t}\n\n\t\t\t// If a window scrolling flag is set, and evaluates to true, don't start checking touches\n\t\t\tif (_instanceOptions.windowScrollingActiveFlag && window[_instanceOptions.windowScrollingActiveFlag]) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// If an animation is in progress, stop the scroll.\n\t\t\tif (triggerScrollInterrupt) {\n\t\t\t\t_interruptScroll();\n\t\t\t} else {\n\n\t\t\t\t// Allow clicks again, but only if a scroll was not interrupted\n\t\t\t\t_preventClick = false;\n\t\t\t}\n\n\t\t\t// Store the initial event coordinates\n\t\t\t_gestureStart.x = inputX;\n\t\t\t_gestureStart.y = inputY;\n\t\t\t_gestureStart.t = inputTime;\n\t\t\t_targetScrollPosition.x = _lastScrollPosition.x;\n\t\t\t_targetScrollPosition.y = _lastScrollPosition.y;\n\n\t\t\t// Clear event history and add the start touch\n\t\t\t_eventHistory.length = 0;\n\t\t\t_eventHistory.push({ x: inputX, y: inputY, t: inputTime });\n\n\t\t\tif (triggerScrollInterrupt) {\n\t\t\t\t_updateScroll(inputX, inputY, inputTime, rawEvent, triggerScrollInterrupt);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t};\n\n\t\t/**\n\t\t * Continue a scroll as a result of an updated position\n\t\t */\n\t\t_updateScroll = function _updateScroll(inputX, inputY, inputTime, rawEvent, scrollInterrupt) {\n\t\t\tvar axis, otherScrollerActive, distancesBeyondBounds;\n\t\t\tvar initialScroll = false;\n\t\t\tvar gesture = {\n\t\t\t\tx: inputX - _gestureStart.x,\n\t\t\t\ty: inputY - _gestureStart.y\n\t\t\t};\n\n\t\t\t// Opera fix\n\t\t\tif (inputTime <= 0) {\n\t\t\t\tinputTime = Date.now();\n\t\t\t}\n\n\t\t\t// Update base target positions\n\t\t\t_targetScrollPosition.x = _baseScrollPosition.x + gesture.x;\n\t\t\t_targetScrollPosition.y = _baseScrollPosition.y + gesture.y;\n\n\t\t\t// If scrolling has not yet locked to this scroller, check whether to stop scrolling\n\t\t\tif (!_isScrolling) {\n\n\t\t\t\t// Check the internal flag to determine if another FTScroller is scrolling\n\t\t\t\tif (_ftscrollerMoving && _ftscrollerMoving !== _self) {\n\t\t\t\t\totherScrollerActive = true;\n\t\t\t\t}\n\n\t\t\t\t// Otherwise, check the window scrolling flag to see if anything else has claimed scrolling\n\t\t\t\telse if (_instanceOptions.windowScrollingActiveFlag && window[_instanceOptions.windowScrollingActiveFlag]) {\n\t\t\t\t\totherScrollerActive = true;\n\t\t\t\t}\n\n\t\t\t\t// If another scroller was active, clean up and stop processing.\n\t\t\t\tif (otherScrollerActive) {\n\t\t\t\t\t_releaseInputCapture();\n\t\t\t\t\t_inputIdentifier = false;\n\t\t\t\t\tif (_isDisplayingScroll) {\n\t\t\t\t\t\t_cancelAnimation();\n\t\t\t\t\t\tif (!_snapScroll(true)) {\n\t\t\t\t\t\t\t_finalizeScroll(true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If not yet displaying a scroll, determine whether that triggering boundary\n\t\t\t// has been exceeded\n\t\t\tif (!_isDisplayingScroll) {\n\n\t\t\t\t// Determine scroll distance beyond bounds\n\t\t\t\tdistancesBeyondBounds = _distancesBeyondBounds(_targetScrollPosition);\n\n\t\t\t\t// Determine whether to prevent the default scroll event - if the scroll could still\n\t\t\t\t// be triggered, prevent the default to avoid problems (particularly on PlayBook)\n\t\t\t\tif (_instanceOptions.bouncing || scrollInterrupt || (_scrollableAxes.x && gesture.x && distancesBeyondBounds.x < 0) || (_scrollableAxes.y && gesture.y && distancesBeyondBounds.y < 0)) {\n\t\t\t\t\trawEvent.preventDefault();\n\t\t\t\t}\n\n\t\t\t\t// Check scrolled distance against the boundary limit to see if scrolling can be triggered.\n\t\t\t\t// If the scroll has been interrupted, trigger at once\n\t\t\t\tif (!scrollInterrupt && (!_scrollableAxes.x || Math.abs(gesture.x) < _instanceOptions.scrollResponseBoundary) && (!_scrollableAxes.y || Math.abs(gesture.y) < _instanceOptions.scrollResponseBoundary)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// If bouncing is disabled, and already at an edge and scrolling beyond the edge, ignore the scroll for\n\t\t\t\t// now - this allows other scrollers to claim if appropriate, allowing nicer nested scrolls.\n\t\t\t\tif (!_instanceOptions.bouncing && !scrollInterrupt && (!_scrollableAxes.x || !gesture.x || distancesBeyondBounds.x > 0) && (!_scrollableAxes.y || !gesture.y || distancesBeyondBounds.y > 0)) {\n\n\t\t\t\t\t// Prevent the original click now that scrolling would be triggered\n\t\t\t\t\t_preventClick = true;\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Trigger the start of visual scrolling\n\t\t\t\t_startAnimation();\n\t\t\t\t_isDisplayingScroll = true;\n\t\t\t\t_hasBeenScrolled = true;\n\t\t\t\t_isAnimating = true;\n\t\t\t\tinitialScroll = true;\n\t\t\t} else {\n\n\t\t\t\t// Prevent the event default.  It is safe to call this in IE10 because the event is never\n\t\t\t\t// a window.event, always a \"true\" event.\n\t\t\t\trawEvent.preventDefault();\n\t\t\t}\n\n\t\t\t// If not yet locked to a scroll, determine whether to do so\n\t\t\tif (!_isScrolling) {\n\n\t\t\t\t// If the gesture distance has exceeded the scroll lock distance, or snapping is active\n\t\t\t\t// and the scroll has been interrupted, enter exclusive scrolling.\n\t\t\t\tif ((scrollInterrupt && _instanceOptions.snapping) || (_scrollableAxes.x && Math.abs(gesture.x) >= _instanceOptions.scrollBoundary) || (_scrollableAxes.y && Math.abs(gesture.y) >= _instanceOptions.scrollBoundary)) {\n\n\t\t\t\t\t_isScrolling = true;\n\t\t\t\t\t_preventClick = true;\n\t\t\t\t\t_ftscrollerMoving = _self;\n\t\t\t\t\tif (_instanceOptions.windowScrollingActiveFlag) {\n\t\t\t\t\t\twindow[_instanceOptions.windowScrollingActiveFlag] = _self;\n\t\t\t\t\t}\n\t\t\t\t\t_fireEvent('scrollstart', _getPosition());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Capture pointer if necessary\n\t\t\tif (_isScrolling) {\n\t\t\t\t_captureInput();\n\t\t\t}\n\n\t\t\t// Cancel text selections while dragging a cursor\n\t\t\tif (_canClearSelection) {\n\t\t\t\twindow.getSelection().removeAllRanges();\n\t\t\t}\n\n\t\t\t// Ensure the target scroll position is affected by bounds and render if needed\n\t\t\t_constrainAndRenderTargetScrollPosition();\n\n\t\t\t// To aid render/draw coalescing, perform other one-off actions here\n\t\t\tif (initialScroll) {\n\t\t\t\tif (gesture.x > 0) {\n\t\t\t\t\t_baseScrollPosition.x -= _instanceOptions.scrollResponseBoundary;\n\t\t\t\t} else if(gesture.x < 0) {\n\t\t\t\t\t_baseScrollPosition.x += _instanceOptions.scrollResponseBoundary;\n\t\t\t\t}\n\n\t\t\t\tif (gesture.y > 0) {\n\t\t\t\t\t_baseScrollPosition.y -= _instanceOptions.scrollResponseBoundary;\n\t\t\t\t} else if(gesture.y < 0) {\n\t\t\t\t\t_baseScrollPosition.y += _instanceOptions.scrollResponseBoundary;\n\t\t\t\t}\n\n\t\t\t\t_targetScrollPosition.x = _baseScrollPosition.x + gesture.x;\n\t\t\t\t_targetScrollPosition.y = _baseScrollPosition.y + gesture.y;\n\n\t\t\t\tif (_instanceOptions.scrollingClassName) {\n\t\t\t\t\t_containerNode.className += ' ' + _instanceOptions.scrollingClassName;\n\t\t\t\t}\n\t\t\t\tif (_instanceOptions.scrollbars) {\n\t\t\t\t\tfor (axis in _scrollableAxes) {\n\t\t\t\t\t\tif (_scrollableAxes.hasOwnProperty(axis)) {\n\t\t\t\t\t\t\t_scrollbarNodes[axis].className += ' active';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add an event to the event history, keeping it around twenty events long\n\t\t\t_eventHistory.push({ x: inputX, y: inputY, t: inputTime });\n\t\t\tif (_eventHistory.length > 30) {\n\t\t\t\t_eventHistory.splice(0, 15);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Complete a scroll with a final event time if available (it may\n\t\t * not be, depending on the input type); this may continue the scroll\n\t\t * with a fling and/or bounceback depending on options.\n\t\t */\n\t\t_endScroll = function _endScroll(inputTime, rawEvent) {\n\t\t\t_releaseInputCapture();\n\t\t\t_inputIdentifier = false;\n\t\t\t_cancelAnimation();\n\n\t\t\t_fireEvent('scrollinteractionend', {});\n\n\t\t\tif (!_isScrolling) {\n\t\t\t\tif (!_snapScroll(true) && _isDisplayingScroll) {\n\t\t\t\t\t_finalizeScroll(true);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Modify the last movement event to include the end event time\n\t\t\t_eventHistory[_eventHistory.length - 1].t = inputTime;\n\n\t\t\t// Update flags\n\t\t\t_isScrolling = false;\n\t\t\t_isDisplayingScroll = false;\n\t\t\t_ftscrollerMoving = false;\n\t\t\tif (_instanceOptions.windowScrollingActiveFlag) {\n\t\t\t\twindow[_instanceOptions.windowScrollingActiveFlag] = false;\n\t\t\t}\n\n\t\t\t// Stop the event default.  It is safe to call this in IE10 because\n\t\t\t// the event is never a window.event, always a \"true\" event.\n\t\t\tif (rawEvent) {\n\t\t\t\trawEvent.preventDefault();\n\t\t\t}\n\n\t\t\t// Trigger a fling or bounceback if necessary\n\t\t\tif (!_flingScroll() && !_snapScroll()) {\n\t\t\t\t_finalizeScroll();\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Remove the scrolling class, cleaning up display.\n\t\t */\n\t\t_finalizeScroll = function _finalizeScroll(scrollCancelled) {\n\t\t\tvar i, l, axis, scrollEvent, scrollRegex;\n\n\t\t\t_isAnimating = false;\n\t\t\t_isDisplayingScroll = false;\n\n\t\t\t// Remove scrolling class if set\n\t\t\tif (_instanceOptions.scrollingClassName) {\n\t\t\t\tscrollRegex = new RegExp('(?:^|\\\\s)' + _instanceOptions.scrollingClassName + '(?!\\\\S)', 'g');\n\t\t\t\t_containerNode.className = _containerNode.className.replace(scrollRegex, '');\n\t\t\t}\n\t\t\tif (_instanceOptions.scrollbars) {\n\t\t\t\tfor (axis in _scrollableAxes) {\n\t\t\t\t\tif (_scrollableAxes.hasOwnProperty(axis)) {\n\t\t\t\t\t\t_scrollbarNodes[axis].className = _scrollbarNodes[axis].className.replace(/ ?active/g, '');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Store final position if scrolling occurred\n\t\t\t_baseScrollPosition.x = _lastScrollPosition.x;\n\t\t\t_baseScrollPosition.y = _lastScrollPosition.y;\n\n\t\t\tscrollEvent = _getPosition();\n\n\t\t\tif (!scrollCancelled) {\n\t\t\t\tconsole.log('firing scroll event from _finalizeScroll');\n\t\t\t\t_fireEvent('scroll', scrollEvent);\n\t\t\t\t_updateSegments(true);\n\t\t\t}\n\n\t\t\t// Always fire the scroll end event, including an argument indicating whether\n\t\t\t// the scroll was cancelled\n\t\t\tscrollEvent.cancelled = scrollCancelled;\n\t\t\t_fireEvent('scrollend', scrollEvent);\n\n\t\t\t// Restore transitions\n\t\t\tfor (axis in _scrollableAxes) {\n\t\t\t\tif (_scrollableAxes.hasOwnProperty(axis)) {\n\t\t\t\t\t_scrollNodes[axis].style[_transitionProperty] = '';\n\t\t\t\t\tif (_instanceOptions.scrollbars) {\n\t\t\t\t\t\t_scrollbarNodes[axis].style[_transitionProperty] = '';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Clear any remaining timeouts\n\t\t\tfor (i = 0, l = _timeouts.length; i < l; i = i + 1) {\n\t\t\t\twindow.clearTimeout(_timeouts[i]);\n\t\t\t}\n\t\t\t_timeouts.length = 0;\n\t\t};\n\n\t\t/**\n\t\t * Interrupt a current scroll, allowing a start scroll during animation to trigger a new scroll\n\t\t */\n\t\t_interruptScroll = function _interruptScroll() {\n\t\t\tvar axis, i, l;\n\n\t\t\t_isAnimating = false;\n\n\t\t\t// Update the stored base position\n\t\t\t_updateElementPosition();\n\n\t\t\t// Ensure the parsed positions are set, also clearing transitions\n\t\t\tfor (axis in _scrollableAxes) {\n\t\t\t\tif (_scrollableAxes.hasOwnProperty(axis)) {\n\t\t\t\t\t_setAxisPosition(axis, _baseScrollPosition[axis], 16, _instanceOptions.bounceDecelerationBezier);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Update segment tracking if snapping is active\n\t\t\t_updateSegments(false);\n\n\t\t\t// Clear any remaining timeouts\n\t\t\tfor (i = 0, l = _timeouts.length; i < l; i = i + 1) {\n\t\t\t\twindow.clearTimeout(_timeouts[i]);\n\t\t\t}\n\t\t\t_timeouts.length = 0;\n\t\t};\n\n\t\t/**\n\t\t * Determine whether a scroll fling or bounceback is required, and set up the styles and\n\t\t * timeouts required.\n\t\t */\n\t\t_flingScroll = function _flingScroll() {\n\t\t\tvar i, axis, movementTime, movementSpeed, lastPosition, comparisonPosition, flingDuration, flingDistance, flingPosition, bounceDelay, bounceDistance, bounceDuration, bounceTarget, boundsBounce, modifiedDistance, flingBezier, timeProportion, boundsCrossDelay, flingStartSegment, beyondBoundsFlingDistance, baseFlingComponent;\n\t\t\tvar maxAnimationTime = 0;\n\t\t\tvar moveRequired = false;\n\t\t\tvar scrollPositionsToApply = {};\n\n\t\t\t// If we only have the start event available, or flinging is disabled,\n\t\t\t// or the scroll was triggered by a scrollwheel, no action required.\n\t\t\tif (_eventHistory.length === 1 || !_instanceOptions.flinging || _inputIdentifier === 'scrollwheel') {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tfor (axis in _scrollableAxes) {\n\t\t\t\tif (_scrollableAxes.hasOwnProperty(axis)) {\n\t\t\t\t\tbounceDuration = 350;\n\t\t\t\t\tbounceDistance = 0;\n\t\t\t\t\tboundsBounce = false;\n\t\t\t\t\tbounceTarget = false;\n\t\t\t\t\tboundsCrossDelay = undefined;\n\n\t\t\t\t\t// Re-set a default bezier curve for the animation for potential modification\n\t\t\t\t\tflingBezier = _instanceOptions.flingBezier;\n\n\t\t\t\t\t// Get the last movement speed, in pixels per millisecond.  To do this, look at the events\n\t\t\t\t\t// in the last 100ms and average out the speed, using a minimum number of two points.\n\t\t\t\t\tlastPosition = _eventHistory[_eventHistory.length - 1];\n\t\t\t\t\tcomparisonPosition = _eventHistory[_eventHistory.length - 2];\n\t\t\t\t\tfor (i = _eventHistory.length - 3; i >= 0; i = i - 1) {\n\t\t\t\t\t\tif (lastPosition.t - _eventHistory[i].t > 100) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcomparisonPosition = _eventHistory[i];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Get the last movement time.  If this is zero - as can happen with\n\t\t\t\t\t// some scrollwheel events on some platforms - increase it to 16ms as\n\t\t\t\t\t// if the movement occurred over a single frame at 60fps.\n\t\t\t\t\tmovementTime = lastPosition.t - comparisonPosition.t;\n\t\t\t\t\tif (!movementTime) {\n\t\t\t\t\t\tmovementTime = 16;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Derive the movement speed\n\t\t\t\t\tmovementSpeed = (lastPosition[axis] - comparisonPosition[axis]) / movementTime;\n\n\t\t\t\t\t// If there is little speed, no further action required except for a bounceback, below.\n\t\t\t\t\tif (Math.abs(movementSpeed) < _kMinimumSpeed) {\n\t\t\t\t\t\tflingDuration = 0;\n\t\t\t\t\t\tflingDistance = 0;\n\n\t\t\t\t\t} else {\n\n\n\t\t\t\t\t\t/* Calculate the fling duration.  As per TouchScroll, the speed at any particular\n\t\t\t\t\t\tpoint in time can be calculated as:\n\t\t\t\t\t\t\t{ speed } = { initial speed } * ({ friction } to the power of { duration })\n\t\t\t\t\t\t...assuming all values are in equal pixels/millisecond measurements.  As we know the\n\t\t\t\t\t\tminimum target speed, this can be altered to:\n\t\t\t\t\t\t\t{ duration } = log( { speed } / { initial speed } ) / log( { friction } )\n\t\t\t\t\t\t*/\n\n\t\t\t\t\t\tflingDuration = Math.log(_kMinimumSpeed / Math.abs(movementSpeed)) / Math.log(_kFriction);\n\n\n\t\t\t\t\t\t/* Calculate the fling distance (before any bouncing or snapping).  As per\n\t\t\t\t\t\tTouchScroll, the total distance covered can be approximated by summing\n\t\t\t\t\t\tthe distance per millisecond, per millisecond of duration - a divergent series,\n\t\t\t\t\t\tand so rather tricky to model otherwise!\n\t\t\t\t\t\tSo using values in pixels per millisecond:\n\t\t\t\t\t\t\t{ distance } = { initial speed } * (1 - ({ friction } to the power\n\t\t\t\t\t\t\t\tof { duration + 1 }) / (1 - { friction })\n\t\t\t\t\t\t*/\n\n\t\t\t\t\t\tflingDistance = movementSpeed * (1 - Math.pow(_kFriction, flingDuration + 1)) / (1 - _kFriction);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Determine a target fling position\n\t\t\t\t\tflingPosition = Math.floor(_lastScrollPosition[axis] + flingDistance);\n\n\t\t\t\t\t// If bouncing is disabled, and the last scroll position and fling position are both at a bound,\n\t\t\t\t\t// reset the fling position to the bound\n\t\t\t\t\tif (!_instanceOptions.bouncing) {\n\t\t\t\t\t\tif (_lastScrollPosition[axis] === 0 && flingPosition > 0) {\n\t\t\t\t\t\t\tflingPosition = 0;\n\t\t\t\t\t\t} else if (_lastScrollPosition[axis] === _metrics.scrollEnd[axis] && flingPosition < _lastScrollPosition[axis]) {\n\t\t\t\t\t\t\tflingPosition = _lastScrollPosition[axis];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// In single-page-scroll mode, determine the page to snap to - maximum one page\n\t\t\t\t\t// in either direction from the *start* page.\n\t\t\t\t\tif (_instanceOptions.singlePageScrolls && _instanceOptions.snapping) {\n\t\t\t\t\t\tflingStartSegment = -_lastScrollPosition[axis] / _snapGridSize[axis];\n\t\t\t\t\t\tif (_baseSegment[axis] < flingStartSegment) {\n\t\t\t\t\t\t\tflingStartSegment = Math.floor(flingStartSegment);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tflingStartSegment = Math.ceil(flingStartSegment);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If the target position will end up beyond another page, target that page edge\n\t\t\t\t\t\tif (flingPosition > -(_baseSegment[axis] - 1) * _snapGridSize[axis]) {\n\t\t\t\t\t\t\tbounceDistance = flingPosition + (_baseSegment[axis] - 1) * _snapGridSize[axis];\n\t\t\t\t\t\t} else if (flingPosition < -(_baseSegment[axis] + 1) * _snapGridSize[axis]) {\n\t\t\t\t\t\t\tbounceDistance = flingPosition + (_baseSegment[axis] + 1) * _snapGridSize[axis];\n\n\t\t\t\t\t\t// Otherwise, if the movement speed was above the minimum velocity, continue\n\t\t\t\t\t\t// in the move direction.\n\t\t\t\t\t\t} else if (Math.abs(movementSpeed) > _kMinimumSpeed) {\n\n\t\t\t\t\t\t\t// Determine the target segment\n\t\t\t\t\t\t\tif (movementSpeed < 0) {\n\t\t\t\t\t\t\t\tflingPosition = Math.floor(_lastScrollPosition[axis] / _snapGridSize[axis]) * _snapGridSize[axis];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tflingPosition = Math.ceil(_lastScrollPosition[axis] / _snapGridSize[axis]) * _snapGridSize[axis];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tflingDuration = Math.min(_instanceOptions.maxFlingDuration, flingDuration * (flingPosition - _lastScrollPosition[axis]) / flingDistance);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// In non-paginated snapping mode, snap to the nearest grid location to the target\n\t\t\t\t\t} else if (_instanceOptions.snapping) {\n\t\t\t\t\t\tbounceDistance = flingPosition - (Math.round(flingPosition / _snapGridSize[axis]) * _snapGridSize[axis]);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Deal with cases where the target is beyond the bounds\n\t\t\t\t\tif (flingPosition - bounceDistance > 0) {\n\t\t\t\t\t\tbounceDistance = flingPosition;\n\t\t\t\t\t\tboundsBounce = true;\n\t\t\t\t\t} else if (flingPosition - bounceDistance < _metrics.scrollEnd[axis]) {\n\t\t\t\t\t\tbounceDistance = flingPosition - _metrics.scrollEnd[axis];\n\t\t\t\t\t\tboundsBounce = true;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Amend the positions and bezier curve if necessary\n\t\t\t\t\tif (bounceDistance) {\n\n\t\t\t\t\t\t// If the fling moves the scroller beyond the normal scroll bounds, and\n\t\t\t\t\t\t// the bounce is snapping the scroll back after the fling:\n\t\t\t\t\t\tif (boundsBounce && _instanceOptions.bouncing && flingDistance) {\n\t\t\t\t\t\t\tflingDistance = Math.floor(flingDistance);\n\n\t\t\t\t\t\t\tif (flingPosition > 0) {\n\t\t\t\t\t\t\t\tbeyondBoundsFlingDistance = flingPosition - Math.max(0, _lastScrollPosition[axis]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbeyondBoundsFlingDistance = flingPosition - Math.min(_metrics.scrollEnd[axis], _lastScrollPosition[axis]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbaseFlingComponent = flingDistance - beyondBoundsFlingDistance;\n\n\t\t\t\t\t\t\t// Determine the time proportion the original bound is along the fling curve\n\t\t\t\t\t\t\tif (!flingDistance || !flingDuration) {\n\t\t\t\t\t\t\t\ttimeProportion = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimeProportion = flingBezier._getCoordinateForT(flingBezier.getTForY((flingDistance - beyondBoundsFlingDistance) / flingDistance, 1 / flingDuration), flingBezier._p1.x, flingBezier._p2.x);\n\t\t\t\t\t\t\t\tboundsCrossDelay = timeProportion * flingDuration;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Eighth the distance beyonds the bounds\n\t\t\t\t\t\t\tmodifiedDistance = Math.ceil(beyondBoundsFlingDistance / 8);\n\n\t\t\t\t\t\t\t// Further limit the bounce to half the container dimensions\n\t\t\t\t\t\t\tif (Math.abs(modifiedDistance) > _metrics.container[axis] / 2) {\n\t\t\t\t\t\t\t\tif (modifiedDistance < 0) {\n\t\t\t\t\t\t\t\t\tmodifiedDistance = -Math.floor(_metrics.container[axis] / 2);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tmodifiedDistance = Math.floor(_metrics.container[axis] / 2);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (flingPosition > 0) {\n\t\t\t\t\t\t\t\tbounceTarget = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbounceTarget = _metrics.scrollEnd[axis];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// If the entire fling is a bounce, modify appropriately\n\t\t\t\t\t\t\tif (timeProportion === 0) {\n\t\t\t\t\t\t\t\tflingDuration = flingDuration / 6;\n\t\t\t\t\t\t\t\tflingPosition = _lastScrollPosition[axis] + baseFlingComponent + modifiedDistance;\n\t\t\t\t\t\t\t\tbounceDelay = flingDuration;\n\n\t\t\t\t\t\t\t// Otherwise, take a new curve and add it to the timeout stack for the bounce\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// The new bounce delay is the pre-boundary fling duration, plus a\n\t\t\t\t\t\t\t\t// sixth of the post-boundary fling.\n\t\t\t\t\t\t\t\tbounceDelay = (timeProportion + ((1 - timeProportion) / 6)) * flingDuration;\n\n\t\t\t\t\t\t\t\t_scheduleAxisPosition(axis, (_lastScrollPosition[axis] + baseFlingComponent + modifiedDistance), ((1 - timeProportion) * flingDuration / 6), _instanceOptions.bounceDecelerationBezier, boundsCrossDelay);\n\n\t\t\t\t\t\t\t\t// Modify the fling to match, clipping to prevent over-fling\n\t\t\t\t\t\t\t\tflingBezier = flingBezier.divideAtX(bounceDelay / flingDuration, 1 / flingDuration)[0];\n\t\t\t\t\t\t\t\tflingDuration = bounceDelay;\n\t\t\t\t\t\t\t\tflingPosition = (_lastScrollPosition[axis] + baseFlingComponent + modifiedDistance);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If the fling requires snapping to a snap location, and the bounce needs to\n\t\t\t\t\t\t// reverse the fling direction after the fling completes:\n\t\t\t\t\t\t} else if ((flingDistance < 0 && bounceDistance < flingDistance) || (flingDistance > 0 && bounceDistance > flingDistance)) {\n\n\t\t\t\t\t\t\t// Shorten the original fling duration to reflect the bounce\n\t\t\t\t\t\t\tflingPosition = flingPosition - Math.floor(flingDistance / 2);\n\t\t\t\t\t\t\tbounceDistance = bounceDistance - Math.floor(flingDistance / 2);\n\t\t\t\t\t\t\tbounceDuration = Math.sqrt(Math.abs(bounceDistance)) * 50;\n\t\t\t\t\t\t\tbounceTarget = flingPosition - bounceDistance;\n\t\t\t\t\t\t\tflingDuration = 350;\n\t\t\t\t\t\t\tbounceDelay = flingDuration * 0.97;\n\n\t\t\t\t\t\t// If the bounce is truncating the fling, or continuing the fling on in the same\n\t\t\t\t\t\t// direction to hit the next boundary:\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tflingPosition = flingPosition - bounceDistance;\n\n\t\t\t\t\t\t\t// If there was no fling distance originally, use the bounce details\n\t\t\t\t\t\t\tif (!flingDistance) {\n\t\t\t\t\t\t\t\tflingDuration = bounceDuration;\n\n\t\t\t\t\t\t\t// If truncating the fling at a snapping edge:\n\t\t\t\t\t\t\t} else if ((flingDistance < 0 && bounceDistance < 0) || (flingDistance > 0 && bounceDistance > 0)) {\n\t\t\t\t\t\t\t\ttimeProportion = flingBezier._getCoordinateForT(flingBezier.getTForY((Math.abs(flingDistance) - Math.abs(bounceDistance)) / Math.abs(flingDistance), 1 / flingDuration), flingBezier._p1.x, flingBezier._p2.x);\n\t\t\t\t\t\t\t\tflingBezier = flingBezier.divideAtX(timeProportion, 1 / flingDuration)[0];\n\t\t\t\t\t\t\t\tflingDuration = Math.round(flingDuration * timeProportion);\n\n\t\t\t\t\t\t\t// If extending the fling to reach the next snapping boundary, no further\n\t\t\t\t\t\t\t// action is required.\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbounceDistance = 0;\n\t\t\t\t\t\t\tbounceDuration = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// If no fling or bounce is required, continue\n\t\t\t\t\tif (flingPosition === _lastScrollPosition[axis] && !bounceDistance) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tmoveRequired = true;\n\n\t\t\t\t\t// Perform the fling\n\t\t\t\t\t_setAxisPosition(axis, flingPosition, flingDuration, flingBezier, boundsCrossDelay);\n\n\t\t\t\t\t// Schedule a bounce if appropriate\n\t\t\t\t\tif (bounceDistance && bounceDuration) {\n\t\t\t\t\t\t_scheduleAxisPosition(axis, bounceTarget, bounceDuration, _instanceOptions.bounceBezier, bounceDelay);\n\t\t\t\t\t}\n\n\t\t\t\t\tmaxAnimationTime = Math.max(maxAnimationTime, bounceDistance ? (bounceDelay + bounceDuration) : flingDuration);\n\t\t\t\t\tscrollPositionsToApply[axis] = (bounceTarget === false) ? flingPosition : bounceTarget;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (moveRequired && maxAnimationTime) {\n\t\t\t\t_timeouts.push(setTimeout(function () {\n\t\t\t\t\tvar anAxis;\n\n\t\t\t\t\t// Update the stored scroll position ready for finalising\n\t\t\t\t\tfor (anAxis in scrollPositionsToApply) {\n\t\t\t\t\t\tif (scrollPositionsToApply.hasOwnProperty(anAxis)) {\n\t\t\t\t\t\t\t_lastScrollPosition[anAxis] = scrollPositionsToApply[anAxis];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t_finalizeScroll();\n\t\t\t\t}, maxAnimationTime));\n\t\t\t}\n\n\t\t\treturn moveRequired;\n\t\t};\n\n\t\t/**\n\t\t * Bounce back into bounds if necessary, or snap to a grid location.\n\t\t */\n\t\t_snapScroll = function _snapScroll(scrollCancelled) {\n\t\t\tvar axis;\n\t\t\tvar snapDuration = scrollCancelled ? 100 : 350;\n\t\t\tvar targetPosition = _lastScrollPosition;\n\n\t\t\t// Get the current position and see if a snap is required\n\t\t\tif (_instanceOptions.snapping) {\n\n\t\t\t\t// Store current snap index\n\t\t\t\t_snapIndex = _getSnapIndexForPosition(targetPosition);\n\t\t\t\ttargetPosition = _getSnapPositionForIndexes(_snapIndex, targetPosition);\n\t\t\t}\n\t\t\ttargetPosition = _limitToBounds(targetPosition);\n\n\t\t\tvar snapRequired = false;\n\t\t\tfor (axis in _baseScrollableAxes) {\n\t\t\t\tif (_baseScrollableAxes.hasOwnProperty(axis)) {\n\t\t\t\t\tif (targetPosition[axis] !== _lastScrollPosition[axis]) {\n\t\t\t\t\t\tsnapRequired = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!snapRequired) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Perform the snap\n\t\t\tfor (axis in _baseScrollableAxes) {\n\t\t\t\tif (_baseScrollableAxes.hasOwnProperty(axis)) {\n\t\t\t\t\t_setAxisPosition(axis, targetPosition[axis], snapDuration);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_timeouts.push(setTimeout(function () {\n\n\t\t\t\t// Update the stored scroll position ready for finalizing\n\t\t\t\t_lastScrollPosition = targetPosition;\n\n\t\t\t\t_finalizeScroll(scrollCancelled);\n\t\t\t}, snapDuration));\n\n\t\t\treturn true;\n\t\t};\n\n\t\t/**\n\t\t * Get an appropriate snap index for a supplied point.\n\t\t */\n\t\t_getSnapIndexForPosition = function _getSnapIndexForPosition(coordinates) {\n\t\t\tvar axis;\n\t\t\tvar indexes = {x: 0, y: 0};\n\t\t\tfor (axis in _scrollableAxes) {\n\t\t\t\tif (_scrollableAxes.hasOwnProperty(axis) && _snapGridSize[axis]) {\n\t\t\t\t\tindexes[axis] = Math.round(coordinates[axis] / _snapGridSize[axis]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn indexes;\n\t\t};\n\n\t\t/**\n\t\t * Get an appropriate snap point for a supplied index.\n\t\t */\n\t\t_getSnapPositionForIndexes = function _getSnapPositionForIndexes(indexes, currentCoordinates) {\n\t\t\tvar axis;\n\t\t\tvar coordinatesToReturn = {\n\t\t\t\tx: currentCoordinates.x,\n\t\t\t\ty: currentCoordinates.y\n\t\t\t};\n\t\t\tfor (axis in _scrollableAxes) {\n\t\t\t\tif (_scrollableAxes.hasOwnProperty(axis)) {\n\t\t\t\t\tcoordinatesToReturn[axis] = indexes[axis] * _snapGridSize[axis];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn coordinatesToReturn;\n\t\t};\n\n\t\t/**\n\t\t * Update the scroll position while scrolling is active, checking the position\n\t\t * within bounds and rubberbanding/constraining as appropriate; also triggers a\n\t\t * scroll position render if a requestAnimationFrame loop isn't active\n\t\t */\n\t\t_constrainAndRenderTargetScrollPosition = function _constrainAndRenderTargetScrollPosition() {\n\t\t\tvar axis, upperBound, lowerBound;\n\n\t\t\t// Update axes target positions if beyond bounds\n\t\t\tfor (axis in _scrollableAxes) {\n\t\t\t\tif (_scrollableAxes.hasOwnProperty(axis)) {\n\n\t\t\t\t\t// Set bounds to the left and right of the container\n\t\t\t\t\tupperBound = 0;\n\t\t\t\t\tlowerBound = _metrics.scrollEnd[axis];\n\n\t\t\t\t\tif (_instanceOptions.singlePageScrolls && _instanceOptions.snapping) {\n\n\t\t\t\t\t\t// For a single-page-scroll, set the bounds to the left and right of the\n\t\t\t\t\t\t// current segment\n\t\t\t\t\t\tupperBound = Math.min(upperBound, -(_baseSegment[axis] - 1) * _snapGridSize[axis]);\n\t\t\t\t\t\tlowerBound = Math.max(lowerBound, -(_baseSegment[axis] + 1) * _snapGridSize[axis]);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (_targetScrollPosition[axis] > upperBound) {\n\t\t\t\t\t\t_targetScrollPosition[axis] = upperBound + _modifyDistanceBeyondBounds(_targetScrollPosition[axis] - upperBound, axis);\n\t\t\t\t\t} else if (_targetScrollPosition[axis] < lowerBound) {\n\t\t\t\t\t\t_targetScrollPosition[axis] = lowerBound + _modifyDistanceBeyondBounds(_targetScrollPosition[axis] - lowerBound, axis);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Trigger a scroll position update for platforms not using requestAnimationFrames\n\t\t\tif (!_reqAnimationFrame) {\n\t\t\t\t_scheduleRender();\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Limit coordinates within the bounds of the scrollable viewport.\n\t\t */\n\t\t_limitToBounds = function _limitToBounds(coordinates) {\n\t\t\tvar axis;\n\t\t\tvar coordinatesToReturn = { x: coordinates.x, y: coordinates.y };\n\n\t\t\tfor (axis in _scrollableAxes) {\n\t\t\t\tif (_scrollableAxes.hasOwnProperty(axis)) {\n\n\t\t\t\t\t// If the coordinate is beyond the edges of the scroller, use the closest edge\n\t\t\t\t\tif (coordinates[axis] > 0) {\n\t\t\t\t\t\tcoordinatesToReturn[axis] = 0;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (coordinates[axis] < _metrics.scrollEnd[axis]) {\n\t\t\t\t\t\tcoordinatesToReturn[axis] = _metrics.scrollEnd[axis];\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn coordinatesToReturn;\n\t\t};\n\n\n\t\t/**\n\t\t * Sets up the DOM around the node to be scrolled.\n\t\t */\n\t\t_initializeDOM = function _initializeDOM() {\n\t\t\tvar offscreenFragment, offscreenNode, scrollYParent;\n\n\t\t\t// Check whether the DOM is already present and valid - if so, no further action required.\n\t\t\tif (_existingDOMValid()) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Otherwise, the DOM needs to be created inside the originally supplied node.  The node\n\t\t\t// has a container inserted inside it - which acts as an anchor element with constraints -\n\t\t\t// and then the scrollable layers as appropriate.\n\n\t\t\t// Create a new document fragment to temporarily hold the scrollable content\n\t\t\toffscreenFragment = _scrollableMasterNode.ownerDocument.createDocumentFragment();\n\t\t\toffscreenNode = document.createElement('DIV');\n\t\t\toffscreenFragment.appendChild(offscreenNode);\n\n\t\t\t// Drop in the wrapping HTML\n\t\t\toffscreenNode.innerHTML = FTScroller.prototype.getPrependedHTML(!_instanceOptions.scrollingX, !_instanceOptions.scrollingY, _instanceOptions.hwAccelerationClass) + FTScroller.prototype.getAppendedHTML(!_instanceOptions.scrollingX, !_instanceOptions.scrollingY, _instanceOptions.hwAccelerationClass, _instanceOptions.scrollbars);\n\n\t\t\t// Update references as appropriate\n\t\t\t_containerNode = offscreenNode.firstElementChild;\n\t\t\tscrollYParent = _containerNode;\n\t\t\tif (_instanceOptions.scrollingX) {\n\t\t\t\t_scrollNodes.x = _containerNode.firstElementChild;\n\t\t\t\tscrollYParent = _scrollNodes.x;\n\t\t\t\tif (_instanceOptions.scrollbars) {\n\t\t\t\t\t_scrollbarNodes.x = _containerNode.getElementsByClassName('ftscroller_scrollbarx')[0];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (_instanceOptions.scrollingY) {\n\t\t\t\t_scrollNodes.y = scrollYParent.firstElementChild;\n\t\t\t\tif (_instanceOptions.scrollbars) {\n\t\t\t\t\t_scrollbarNodes.y = _containerNode.getElementsByClassName('ftscroller_scrollbary')[0];\n\t\t\t\t}\n\t\t\t\t_contentParentNode = _scrollNodes.y;\n\t\t\t} else {\n\t\t\t\t_contentParentNode = _scrollNodes.x;\n\t\t\t}\n\n\t\t\t// Take the contents of the scrollable element, and copy them into the new container\n\t\t\twhile (_scrollableMasterNode.firstChild) {\n\t\t\t\t_contentParentNode.appendChild(_scrollableMasterNode.firstChild);\n\t\t\t}\n\n\t\t\t// Move the wrapped elements back into the document\n\t\t\t_scrollableMasterNode.appendChild(_containerNode);\n\t\t};\n\n\t\t/**\n\t\t * Attempts to use any existing DOM scroller nodes if possible, returning true if so;\n\t\t * updates all internal element references.\n\t\t */\n\t\t_existingDOMValid = function _existingDOMValid() {\n\t\t\tvar scrollerContainer, layerX, layerY, yParent, scrollerX, scrollerY, candidates, i, l;\n\n\t\t\t// Check that there's an initial child node, and make sure it's the container class\n\t\t\tscrollerContainer = _scrollableMasterNode.firstElementChild;\n\t\t\tif (!scrollerContainer || scrollerContainer.className.indexOf('ftscroller_container') === -1) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If x-axis scrolling is enabled, find and verify the x scroller layer\n\t\t\tif (_instanceOptions.scrollingX) {\n\n\t\t\t\t// Find and verify the x scroller layer\n\t\t\t\tlayerX = scrollerContainer.firstElementChild;\n\t\t\t\tif (!layerX || layerX.className.indexOf('ftscroller_x') === -1) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tyParent = layerX;\n\n\t\t\t\t// Find and verify the x scrollbar if enabled\n\t\t\t\tif (_instanceOptions.scrollbars) {\n\t\t\t\t\tcandidates = scrollerContainer.getElementsByClassName('ftscroller_scrollbarx');\n\t\t\t\t\tif (candidates) {\n\t\t\t\t\t\tfor (i = 0, l = candidates.length; i < l; i = i + 1) {\n\t\t\t\t\t\t\tif (candidates[i].parentNode === scrollerContainer) {\n\t\t\t\t\t\t\t\tscrollerX = candidates[i];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!scrollerX) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tyParent = scrollerContainer;\n\t\t\t}\n\n\t\t\t// If y-axis scrolling is enabled, find and verify the y scroller layer\n\t\t\tif (_instanceOptions.scrollingY) {\n\n\t\t\t\t// Find and verify the x scroller layer\n\t\t\t\tlayerY = yParent.firstElementChild;\n\t\t\t\tif (!layerY || layerY.className.indexOf('ftscroller_y') === -1) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Find and verify the y scrollbar if enabled\n\t\t\t\tif (_instanceOptions.scrollbars) {\n\t\t\t\t\tcandidates = scrollerContainer.getElementsByClassName('ftscroller_scrollbary');\n\t\t\t\t\tif (candidates) {\n\t\t\t\t\t\tfor (i = 0, l = candidates.length; i < l; i = i + 1) {\n\t\t\t\t\t\t\tif (candidates[i].parentNode === scrollerContainer) {\n\t\t\t\t\t\t\t\tscrollerY = candidates[i];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!scrollerY) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Elements found and verified - update the references and return success\n\t\t\t_containerNode = scrollerContainer;\n\t\t\tif (layerX) {\n\t\t\t\t_scrollNodes.x = layerX;\n\t\t\t}\n\t\t\tif (layerY) {\n\t\t\t\t_scrollNodes.y = layerY;\n\t\t\t}\n\t\t\tif (scrollerX) {\n\t\t\t\t_scrollbarNodes.x = scrollerX;\n\t\t\t}\n\t\t\tif (scrollerY) {\n\t\t\t\t_scrollbarNodes.y = scrollerY;\n\t\t\t}\n\t\t\tif (_instanceOptions.scrollingY) {\n\t\t\t\t_contentParentNode = layerY;\n\t\t\t} else {\n\t\t\t\t_contentParentNode = layerX;\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\n\t\t_domChanged = function _domChanged(e) {\n\n\t\t\t// If the timer is active, clear it\n\t\t\tif (_domChangeDebouncer) {\n\t\t\t\twindow.clearTimeout(_domChangeDebouncer);\n\t\t\t}\n\n\t\t\t// React to resizes at once\n\t\t\tif (e && e.type === 'resize') {\n\t\t\t\t_updateDimensions();\n\n\t\t\t// For other changes, which may occur in groups, set up the DOM changed timer\n\t\t\t} else {\n\t\t\t\t_domChangeDebouncer = setTimeout(function () {\n\t\t\t\t\t_updateDimensions();\n\t\t\t\t}, 100);\n\t\t\t}\n\t\t};\n\n\t\t_updateDimensions = function _updateDimensions(ignoreSnapScroll) {\n\t\t\tvar axis;\n\n\t\t\t// Only update dimensions if the container node exists (DOM elements can go away if\n\t\t\t// the scroller instance is not destroyed correctly)\n\t\t\tif (!_containerNode || !_contentParentNode) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (_domChangeDebouncer) {\n\t\t\t\twindow.clearTimeout(_domChangeDebouncer);\n\t\t\t\t_domChangeDebouncer = false;\n\t\t\t}\n\t\t\tvar containerWidth, containerHeight, startAlignments;\n\n\t\t\t// Calculate the starting alignment for comparison later\n\t\t\tstartAlignments = { x: false, y: false };\n\t\t\tfor (axis in startAlignments) {\n\t\t\t\tif (startAlignments.hasOwnProperty(axis)) {\n\t\t\t\t\tif (_lastScrollPosition[axis] === 0) {\n\t\t\t\t\t\tstartAlignments[axis] = -1;\n\t\t\t\t\t} else if (_lastScrollPosition[axis] <= _metrics.scrollEnd[axis]) {\n\t\t\t\t\t\tstartAlignments[axis] = 1;\n\t\t\t\t\t} else if (_lastScrollPosition[axis] * 2 <= _metrics.scrollEnd[axis] + 5 && _lastScrollPosition[axis] * 2 >= _metrics.scrollEnd[axis] - 5) {\n\t\t\t\t\t\tstartAlignments[axis] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcontainerWidth = _containerNode.offsetWidth;\n\t\t\tcontainerHeight = _containerNode.offsetHeight;\n\n\t\t\t// Grab the dimensions\n\t\t\tvar rawScrollWidth = options.contentWidth || _contentParentNode.offsetWidth;\n\t\t\tvar rawScrollHeight = options.contentHeight || _contentParentNode.offsetHeight;\n\t\t\tvar scrollWidth = rawScrollWidth;\n\t\t\tvar scrollHeight = rawScrollHeight;\n\t\t\tvar targetPosition = { x: _lastScrollPosition.x, y: _lastScrollPosition.y };\n\n\t\t\t// Update snap grid\n\t\t\tif (!_snapGridSize.userX) {\n\t\t\t\t_snapGridSize.x = containerWidth;\n\t\t\t}\n\t\t\tif (!_snapGridSize.userY) {\n\t\t\t\t_snapGridSize.y = containerHeight;\n\t\t\t}\n\n\t\t\t// If there is a grid, conform to the grid\n\t\t\tif (_instanceOptions.snapping) {\n\t\t\t\tif (_snapGridSize.userX) {\n\t\t\t\t\tscrollWidth = Math.ceil(scrollWidth / _snapGridSize.userX) * _snapGridSize.userX;\n\t\t\t\t} else {\n\t\t\t\t\tscrollWidth = Math.ceil(scrollWidth / _snapGridSize.x) * _snapGridSize.x;\n\t\t\t\t}\n\t\t\t\tif (_snapGridSize.userY) {\n\t\t\t\t\tscrollHeight = Math.ceil(scrollHeight / _snapGridSize.userY) * _snapGridSize.userY;\n\t\t\t\t} else {\n\t\t\t\t\tscrollHeight = Math.ceil(scrollHeight / _snapGridSize.y) * _snapGridSize.y;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If no details have changed, return.\n\t\t\tif (_metrics.container.x === containerWidth && _metrics.container.y === containerHeight && _metrics.content.x === scrollWidth && _metrics.content.y === scrollHeight) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Update the sizes\n\t\t\t_metrics.container.x = containerWidth;\n\t\t\t_metrics.container.y = containerHeight;\n\t\t\t_metrics.content.x = scrollWidth;\n\t\t\t_metrics.content.rawX = rawScrollWidth;\n\t\t\t_metrics.content.y = scrollHeight;\n\t\t\t_metrics.content.rawY = rawScrollHeight;\n\t\t\t_metrics.scrollEnd.x = containerWidth - scrollWidth;\n\t\t\t_metrics.scrollEnd.y = containerHeight - scrollHeight;\n\n\t\t\t_updateScrollbarDimensions();\n\n\t\t\t// If scrolling is in progress, trigger a scroll update\n\t\t\tif (_isScrolling) {\n\t\t\t\t_lastScrollPosition.x--;\n\t\t\t\t_lastScrollPosition.y--;\n\t\t\t\t_constrainAndRenderTargetScrollPosition();\n\n\t\t\t// If scrolling *isn't* in progress, snap and realign.\n\t\t\t} else {\n\t\t\t\tif (!ignoreSnapScroll && _instanceOptions.snapping) {\n\n\t\t\t        // Ensure bounds are correct\n\t\t\t\t\t_updateSegments();\n\t\t\t\t\ttargetPosition = _getSnapPositionForIndexes(_snapIndex, _lastScrollPosition);\n\t\t\t\t}\n\n\t\t\t\t// Apply base alignment if appropriate\n\t\t\t\tfor (axis in targetPosition) {\n\t\t\t\t\tif (targetPosition.hasOwnProperty(axis)) {\n\n\t\t\t\t\t\t// If the container is smaller than the content, determine whether to apply the\n\t\t\t\t\t\t// alignment.  This occurs if a scroll has never taken place, or if the position\n\t\t\t\t\t\t// was previously at the correct \"end\" and can be maintained.\n\t\t\t\t\t\tif (_metrics.container[axis] < _metrics.content[axis]) {\n\t\t\t\t\t\t\tif (_hasBeenScrolled && _instanceOptions.baseAlignments[axis] !== startAlignments[axis]) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Apply the alignment\n\t\t\t\t\t\tif (_instanceOptions.baseAlignments[axis] === 1) {\n\t\t\t\t\t\t\ttargetPosition[axis] = _metrics.scrollEnd[axis];\n\t\t\t\t\t\t} else if (_instanceOptions.baseAlignments[axis] === 0) {\n\t\t\t\t\t\t\ttargetPosition[axis] = Math.floor(_metrics.scrollEnd[axis] / 2);\n\t\t\t\t\t\t} else if (_instanceOptions.baseAlignments[axis] === -1) {\n\t\t\t\t\t\t\ttargetPosition[axis] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Limit to bounds\n\t\t\t\ttargetPosition = _limitToBounds(targetPosition);\n\n\t\t\t\tif (_instanceOptions.scrollingX && targetPosition.x !== _lastScrollPosition.x) {\n\t\t\t\t\t_setAxisPosition('x', targetPosition.x, 0);\n\t\t\t\t\t_baseScrollPosition.x = targetPosition.x;\n\t\t\t\t}\n\t\t\t\tif (_instanceOptions.scrollingY && targetPosition.y !== _lastScrollPosition.y) {\n\t\t\t\t\t_setAxisPosition('y', targetPosition.y, 0);\n\t\t\t\t\t_baseScrollPosition.y = targetPosition.y;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t_updateScrollbarDimensions = function _updateScrollbarDimensions() {\n\n\t\t\t// Update scrollbar sizes\n\t\t\tif (_instanceOptions.scrollbars) {\n\t\t\t\tif (_instanceOptions.scrollingX) {\n\t\t\t\t\t_scrollbarNodes.x.style.width = Math.max(6, Math.round(_metrics.container.x * (_metrics.container.x / _metrics.content.x) - 4)) + 'px';\n\t\t\t\t}\n\t\t\t\tif (_instanceOptions.scrollingY) {\n\t\t\t\t\t_scrollbarNodes.y.style.height = Math.max(6, Math.round(_metrics.container.y * (_metrics.container.y / _metrics.content.y) - 4)) + 'px';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Update scroll caches\n\t\t\t_scrollableAxes = {};\n\t\t\tif (_instanceOptions.scrollingX && (_metrics.content.x > _metrics.container.x || _instanceOptions.alwaysScroll)) {\n\t\t\t\t_scrollableAxes.x = true;\n\t\t\t}\n\t\t\tif (_instanceOptions.scrollingY && (_metrics.content.y > _metrics.container.y || _instanceOptions.alwaysScroll)) {\n\t\t\t\t_scrollableAxes.y = true;\n\t\t\t}\n\t\t};\n\n\t\t_updateElementPosition = function _updateElementPosition() {\n\t\t\tvar axis, computedStyle, splitStyle;\n\n\t\t\t// Retrieve the current position of each active axis.\n\t\t\t// Custom parsing is used instead of native matrix support for speed and for\n\t\t\t// backwards compatibility.\n\t\t\tfor (axis in _scrollableAxes) {\n\t\t\t\tif (_scrollableAxes.hasOwnProperty(axis)) {\n\t\t\t\t\tcomputedStyle = window.getComputedStyle(_scrollNodes[axis], null)[_vendorTransformLookup];\n\t\t\t\t\tsplitStyle = computedStyle.split(', ');\n\n\t\t\t\t\t// For 2d-style transforms, pull out elements four or five\n\t\t\t\t\tif (splitStyle.length === 6) {\n\t\t\t\t\t\t_baseScrollPosition[axis] = parseInt(splitStyle[(axis === 'y') ? 5 : 4], 10);\n\n\t\t\t\t\t// For 3d-style transforms, pull out elements twelve or thirteen\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_baseScrollPosition[axis] = parseInt(splitStyle[(axis === 'y') ? 13 : 12], 10);\n\t\t\t\t\t}\n\t\t\t\t\t_lastScrollPosition[axis] = _baseScrollPosition[axis];\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t_updateSegments = function _updateSegments(scrollFinalised) {\n\t\t\tvar axis;\n\t\t\tvar newSegment = { x: 0, y: 0 };\n\n\t\t\t// If snapping is disabled, return without any further action required\n\t\t\tif (!_instanceOptions.snapping) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Calculate the new segments\n\t\t\tfor (axis in _scrollableAxes) {\n\t\t\t\tif (_scrollableAxes.hasOwnProperty(axis)) {\n\t\t\t\t\tnewSegment[axis] = Math.max(0, Math.min(Math.ceil(_metrics.content[axis] / _snapGridSize[axis]) - 1, Math.round(-_lastScrollPosition[axis] / _snapGridSize[axis])));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// In all cases update the active segment if appropriate\n\t\t\tif (newSegment.x !== _activeSegment.x || newSegment.y !== _activeSegment.y) {\n\t\t\t\t_activeSegment.x = newSegment.x;\n\t\t\t\t_activeSegment.y = newSegment.y;\n\t\t\t\t_fireEvent('segmentwillchange', { segmentX: newSegment.x, segmentY: newSegment.y });\n\t\t\t}\n\n\t\t\t// If the scroll has been finalised, also update the base segment\n\t\t\tif (scrollFinalised) {\n\t\t\t\tif (newSegment.x !== _baseSegment.x || newSegment.y !== _baseSegment.y) {\n\t\t\t\t\t_baseSegment.x = newSegment.x;\n\t\t\t\t\t_baseSegment.y = newSegment.y;\n\t\t\t\t\t_fireEvent('segmentdidchange', { segmentX: newSegment.x, segmentY: newSegment.y });\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t_setAxisPosition = function _setAxisPosition(axis, position, animationDuration, animationBezier, boundsCrossDelay) {\n\t\t\tvar transitionCSSString, newPositionAtExtremity = null;\n\n\t\t\t// Only update position if the axis node exists (DOM elements can go away if\n\t\t\t// the scroller instance is not destroyed correctly)\n\t\t\tif (!_scrollNodes[axis]) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Determine the transition property to apply to both the scroll element and the scrollbar\n\t\t\tif (animationDuration) {\n\t\t\t\tif (!animationBezier) {\n\t\t\t\t\tanimationBezier = _instanceOptions.flingBezier;\n\t\t\t\t}\n\n\t\t\t\ttransitionCSSString = _vendorCSSPrefix + 'transform ' + animationDuration + 'ms ' + animationBezier.toString();\n\t\t\t} else {\n\t\t\t\ttransitionCSSString = '';\n\t\t\t}\n\n\t\t\t// Apply the transition property to elements\n\t\t\t_scrollNodes[axis].style[_transitionProperty] = transitionCSSString;\n\t\t\tif (_instanceOptions.scrollbars) {\n\t\t\t\t_scrollbarNodes[axis].style[_transitionProperty] = transitionCSSString;\n\t\t\t}\n\n\t\t\t// Update the positions\n\t\t\t_scrollNodes[axis].style[_transformProperty] = _translateRulePrefix + _transformPrefixes[axis] + position + 'px' + _transformSuffixes[axis];\n\t\t\tif (_instanceOptions.scrollbars) {\n\t\t\t\t_scrollbarNodes[axis].style[_transformProperty] = _translateRulePrefix + _transformPrefixes[axis] + (-position * _metrics.container[axis] / _metrics.content[axis]) + 'px' + _transformSuffixes[axis];\n\t\t\t}\n\n\t\t\t// Determine whether the scroll is at an extremity.\n\t\t\tif (position >= 0) {\n\t\t\t\tnewPositionAtExtremity = 'start';\n\t\t\t} else if (position <= _metrics.scrollEnd[axis]) {\n\t\t\t\tnewPositionAtExtremity = 'end';\n\t\t\t}\n\n\t\t\t// If the extremity status has changed, fire an appropriate event\n\t\t\tif (newPositionAtExtremity !== _scrollAtExtremity[axis]) {\n\t\t\t\tif (newPositionAtExtremity !== null) {\n\t\t\t\t\tif (animationDuration) {\n\t\t\t\t\t\t_timeouts.push(setTimeout(function() {\n\t\t\t\t\t\t\t_fireEvent('reached' + newPositionAtExtremity, { axis: axis });\n\t\t\t\t\t\t}, boundsCrossDelay || animationDuration));\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_fireEvent('reached' + newPositionAtExtremity, { axis: axis });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_scrollAtExtremity[axis] = newPositionAtExtremity;\n\t\t\t}\n\n\t\t\t// Update the recorded position if there's no duration\n\t\t\tif (!animationDuration) {\n\t\t\t\t_lastScrollPosition[axis] = position;\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Retrieve the current position as an object with scrollLeft and scrollTop\n\t\t * properties.\n\t\t */\n\t\t_getPosition = function _getPosition() {\n\t\t\treturn {\n\t\t\t\tscrollLeft: -_lastScrollPosition.x,\n\t\t\t\tscrollTop: -_lastScrollPosition.y\n\t\t\t};\n\t\t};\n\n\t\t_scheduleAxisPosition = function _scheduleAxisPosition(axis, position, animationDuration, animationBezier, afterDelay) {\n\t\t\t_timeouts.push(setTimeout(function () {\n\t\t\t\t_setAxisPosition(axis, position, animationDuration, animationBezier);\n\t\t\t}, afterDelay));\n\t\t};\n\n\t\t_fireEvent = function _fireEvent(eventName, eventObject) {\n\t\t\tvar i, l;\n\t\t\teventObject.srcObject = _publicSelf;\n\n\t\t\t// Iterate through any listeners\n\t\t\tfor (i = 0, l = _eventListeners[eventName].length; i < l; i = i + 1) {\n\n\t\t\t\t// Execute each in a try/catch\n\t\t\t\ttry {\n\t\t\t\t\t_eventListeners[eventName][i](eventObject);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tif (window.console && window.console.error) {\n\t\t\t\t\t\tif (error.message) {\n\t\t\t\t\t\t\twindow.console.error(error.message + ' (' + error.sourceURL + ', line ' + error.line + ')');\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twindow.console.error('Error encountered executing FTScroller event listener callback for [' + eventName + ']. Add a \"debugger\" statement here to obtain a full backtrace.');\n\t\t\t\t\t\t\tif (window.console.dir) window.console.dir(error);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Update the scroll position so that the child element is in view.\n\t\t */\n\t\t_childFocused = function _childFocused(event) {\n\t\t\tvar offset, axis, visibleChildPortion;\n\t\t\tvar focusedNodeRect = _getBoundingRect(event.target);\n\t\t\tvar containerRect = _getBoundingRect(_containerNode);\n\t\t\tvar edgeMap = { x: 'left', y: 'top' };\n\t\t\tvar opEdgeMap = { x: 'right', y: 'bottom' };\n\t\t\tvar dimensionMap = { x: 'width', y: 'height' };\n\n\t\t\t// If an input is currently being tracked, ignore the focus event\n\t\t\tif (_inputIdentifier !== false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (axis in _scrollableAxes) {\n\t\t\t\tif (_scrollableAxes.hasOwnProperty(axis)) {\n\n\t\t\t\t\t// If the focussed node is entirely in view, there is no need to center it\n\t\t\t\t\tif (focusedNodeRect[edgeMap[axis]] >= containerRect[edgeMap[axis]] && focusedNodeRect[opEdgeMap[axis]] <= containerRect[opEdgeMap[axis]]) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If the focussed node is larger than the container...\n\t\t\t\t\tif (focusedNodeRect[dimensionMap[axis]] > containerRect[dimensionMap[axis]]) {\n\n\t\t\t\t\t\tvisibleChildPortion = focusedNodeRect[dimensionMap[axis]] - Math.max(0, containerRect[edgeMap[axis]] - focusedNodeRect[edgeMap[axis]]) - Math.max(0, focusedNodeRect[opEdgeMap[axis]] - containerRect[opEdgeMap[axis]]);\n\n\t\t\t\t\t\t// If more than half a container's portion of the focussed node is visible, there's no need to center it\n\t\t\t\t\t\tif (visibleChildPortion >= (containerRect[dimensionMap[axis]] / 2)) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Set the target offset to be in the middle of the container, or as close as bounds permit\n\t\t\t\t\toffset = -Math.round((focusedNodeRect[dimensionMap[axis]] / 2) - _lastScrollPosition[axis] + focusedNodeRect[edgeMap[axis]] - containerRect[edgeMap[axis]]  - (containerRect[dimensionMap[axis]] / 2));\n\t\t\t\t\toffset = Math.min(0, Math.max(_metrics.scrollEnd[axis], offset));\n\n\t\t\t\t\t// Perform the scroll\n\t\t\t\t\t_setAxisPosition(axis, offset, 0);\n\t\t\t\t\t_baseScrollPosition[axis] = offset;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconsole.log('firing scroll event from _childFocused');\n\t\t\t_fireEvent('scroll', _getPosition());\n\t\t};\n\n\t\t/**\n\t\t * Given a relative distance beyond the element bounds, returns a modified version to\n\t\t * simulate bouncy/springy edges.\n\t\t */\n\t\t_modifyDistanceBeyondBounds = function _modifyDistanceBeyondBounds(distance, axis) {\n\t\t\tif (!_instanceOptions.bouncing) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tvar e = Math.exp(distance / _metrics.container[axis]);\n\t\t\treturn Math.round(_metrics.container[axis] * 0.6 * (e - 1) / (e + 1));\n\t\t};\n\n\t\t/**\n\t\t * Given positions for each enabled axis, returns an object showing how far each axis is beyond\n\t\t * bounds. If within bounds, -1 is returned; if at the bounds, 0 is returned.\n\t\t */\n\t\t_distancesBeyondBounds = function _distancesBeyondBounds(positions) {\n\t\t\tvar axis, position;\n\t\t\tvar distances = {};\n\t\t\tfor (axis in positions) {\n\t\t\t\tif (positions.hasOwnProperty(axis)) {\n\t\t\t\t\tposition = positions[axis];\n\n\t\t\t\t\t// If the position is to the left/top, no further modification required\n\t\t\t\t\tif (position >= 0) {\n\t\t\t\t\t\tdistances[axis] = position;\n\n\t\t\t\t\t// If it's within the bounds, use -1\n\t\t\t\t\t} else if (position > _metrics.scrollEnd[axis]) {\n\t\t\t\t\t\tdistances[axis] = -1;\n\n\t\t\t\t\t// Otherwise, amend by the distance of the maximum edge\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdistances[axis] = _metrics.scrollEnd[axis] - position;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn distances;\n\t\t};\n\n\t\t/**\n\t\t * On platforms which support it, use RequestAnimationFrame to group\n\t\t * position updates for speed.  Starts the render process.\n\t\t */\n\t\t_startAnimation = function _startAnimation() {\n\t\t\tif (_reqAnimationFrame) {\n\t\t\t\t_cancelAnimation();\n\t\t\t\t_animationFrameRequest = _reqAnimationFrame(_scheduleRender);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * On platforms which support RequestAnimationFrame, provide the rendering loop.\n\t\t * Takes two arguments; the first is the render/position update function to\n\t\t * be called, and the second is a string controlling the render type to\n\t\t * allow previous changes to be cancelled - should be 'pan' or 'scroll'.\n\t\t */\n\t\t_scheduleRender = function _scheduleRender() {\n\t\t\tvar axis, positionUpdated;\n\n\t\t\t// If using requestAnimationFrame schedule the next update at once\n\t\t\tif (_reqAnimationFrame) {\n\t\t\t\t_animationFrameRequest = _reqAnimationFrame(_scheduleRender);\n\t\t\t}\n\n\t\t\t// Perform the draw.\n\t\t\tfor (axis in _scrollableAxes) {\n\t\t\t\tif (_scrollableAxes.hasOwnProperty(axis) && _targetScrollPosition[axis] !== _lastScrollPosition[axis]) {\n\t\t\t\t\t_setAxisPosition(axis, _targetScrollPosition[axis]);\n\t\t\t\t\tpositionUpdated = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If full, locked scrolling has enabled, fire any scroll and segment change events\n\t\t\tif (_isScrolling && positionUpdated) {\n\t\t\t\tconsole.log('firing scroll event from _scheduleRender');\n\t\t\t\t_fireEvent('scroll', _getPosition());\n\t\t\t\t_updateSegments(false);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Stops the animation process.\n\t\t */\n\t\t_cancelAnimation = function _cancelAnimation() {\n\t\t\tif (_animationFrameRequest === false || !_cancelAnimationFrame) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_cancelAnimationFrame(_animationFrameRequest);\n\t\t\t_animationFrameRequest = false;\n\t\t};\n\n\t\t/**\n\t\t * Remove then re-set event handlers\n\t\t */\n\t\t_resetEventHandlers = function() {\n\t\t\t_removeEventHandlers();\n\t\t\t_addEventHandlers();\n\t\t};\n\n\t\t/**\n\t\t * Register event handlers\n\t\t */\n\t\t_addEventHandlers = function _addEventHandlers() {\n\t\t\tvar MutationObserver;\n\n\t\t\t// Only remove the event if the node exists (DOM elements can go away)\n\t\t\tif (!_containerNode) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (_trackPointerEvents && !_instanceOptions.disabledInputMethods.pointer) {\n\t\t\t\tif (_pointerEventsPrefixed) {\n\t\t\t\t\t_containerNode.addEventListener('MSPointerDown', _onPointerDown);\n\t\t\t\t\t_containerNode.addEventListener('MSPointerMove', _onPointerMove);\n\t\t\t\t\t_containerNode.addEventListener('MSPointerUp', _onPointerUp);\n\t\t\t\t\t_containerNode.addEventListener('MSPointerCancel', _onPointerCancel);\n\t\t\t\t} else {\n\t\t\t\t\t_containerNode.addEventListener('pointerdown', _onPointerDown);\n\t\t\t\t\t_containerNode.addEventListener('pointermove', _onPointerMove);\n\t\t\t\t\t_containerNode.addEventListener('pointerup', _onPointerUp);\n\t\t\t\t\t_containerNode.addEventListener('pointercancel', _onPointerCancel);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (_trackTouchEvents && !_instanceOptions.disabledInputMethods.touch) {\n\t\t\t\t\t_containerNode.addEventListener('touchstart', _onTouchStart);\n\t\t\t\t\t_containerNode.addEventListener('touchmove', _onTouchMove);\n\t\t\t\t\t_containerNode.addEventListener('touchend', _onTouchEnd);\n\t\t\t\t\t_containerNode.addEventListener('touchcancel', _onTouchEnd);\n\t\t\t\t}\n\t\t\t\tif (!_instanceOptions.disabledInputMethods.mouse) {\n\t\t\t\t\t_containerNode.addEventListener('mousedown', _onMouseDown);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!_instanceOptions.disabledInputMethods.scroll) {\n\t\t\t\t_containerNode.addEventListener('DOMMouseScroll', _onMouseScroll);\n\t\t\t\t_containerNode.addEventListener('mousewheel', _onMouseScroll);\n\t\t\t}\n\n\t\t\t// If any of the input methods which would eventually trigger a click are\n\t\t\t// enabled, add a click event listener so that phantom clicks can be prevented\n\t\t\t// at the end of a scroll. Otherwise, don't add a listener and don't prevent\n\t\t\t// clicks.\n\t\t\tif (!_instanceOptions.disabledInputMethods.mouse || !_instanceOptions.disabledInputMethods.touch || !_instanceOptions.disabledInputMethods.pointer) {\n\n\t\t\t\t// Add a click listener.  On IE, add the listener to the document, to allow\n\t\t\t\t// clicks to be cancelled if a scroll ends outside the bounds of the container; on\n\t\t\t\t// other platforms, add to the container node.\n\t\t\t\tif (_trackPointerEvents) {\n\t\t\t\t\tdocument.addEventListener('click', _onClick, true);\n\t\t\t\t} else {\n\t\t\t\t\t_containerNode.addEventListener('click', _onClick, true);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Watch for changes inside the contained element to update bounds - de-bounced slightly.\n\t\t\tif (!_instanceOptions.disabledInputMethods.focus) {\n\t\t\t\t_contentParentNode.addEventListener('focus', _childFocused);\n\t\t\t}\n\t\t\tif (_instanceOptions.updateOnChanges) {\n\n\t\t\t\t// Try and reuse the old, disconnected observer instance if available\n\t\t\t\t// Otherwise, check for support before proceeding\n\t\t\t\tif (!_mutationObserver) {\n\t\t\t\t\tMutationObserver = window.MutationObserver || window.WebKitMutationObserver || window[_vendorStylePropertyPrefix + 'MutationObserver'];\n\t\t\t\t\tif (MutationObserver) {\n\t\t\t\t\t\t_mutationObserver = new MutationObserver(_domChanged);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (_mutationObserver) {\n\t\t\t\t\t_mutationObserver.observe(_contentParentNode, {\n\t\t\t\t\t\tchildList: true,\n\t\t\t\t\t\tcharacterData: true,\n\t\t\t\t\t\tsubtree: true\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\t_contentParentNode.addEventListener('DOMSubtreeModified', function (e) {\n\n\t\t\t\t\t\t// Ignore changes to nested FT Scrollers - even updating a transform style\n\t\t\t\t\t\t// can trigger a DOMSubtreeModified in IE, causing nested scrollers to always\n\t\t\t\t\t\t// favour the deepest scroller as parent scrollers 'resize'/end scrolling.\n\t\t\t\t\t\tif (e && (e.srcElement === _contentParentNode || e.srcElement.className.indexOf('ftscroller_') !== -1)) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_domChanged();\n\t\t\t\t\t}, true);\n\t\t\t\t}\n\t\t\t\t_contentParentNode.addEventListener('load', _domChanged);\n\t\t\t}\n\t\t\tif (_instanceOptions.updateOnWindowResize) {\n\t\t\t\twindow.addEventListener('resize', _domChanged);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Remove event handlers.\n\t\t *\n\t\t * The current flags may not match the state when the event handlers were set up,\n\t\t * so remove all event handlers unconditionally, just in case they're bound.\n\t\t */\n\t\t_removeEventHandlers = function _removeEventHandlers() {\n\n\t\t\tif (_containerNode) {\n\t\t\t\t_containerNode.removeEventListener('MSPointerDown', _onPointerDown);\n\t\t\t\t_containerNode.removeEventListener('MSPointerMove', _onPointerMove);\n\t\t\t\t_containerNode.removeEventListener('MSPointerUp', _onPointerUp);\n\t\t\t\t_containerNode.removeEventListener('MSPointerCancel', _onPointerCancel);\n\t\t\t\t_containerNode.removeEventListener('pointerdown', _onPointerDown);\n\t\t\t\t_containerNode.removeEventListener('pointermove', _onPointerMove);\n\t\t\t\t_containerNode.removeEventListener('pointerup', _onPointerUp);\n\t\t\t\t_containerNode.removeEventListener('pointercancel', _onPointerCancel);\n\t\t\t\t_containerNode.removeEventListener('touchstart', _onTouchStart);\n\t\t\t\t_containerNode.removeEventListener('touchmove', _onTouchMove);\n\t\t\t\t_containerNode.removeEventListener('touchend', _onTouchEnd);\n\t\t\t\t_containerNode.removeEventListener('touchcancel', _onTouchEnd);\n\t\t\t\t_containerNode.removeEventListener('mousedown', _onMouseDown);\n\t\t\t\t_containerNode.removeEventListener('DOMMouseScroll', _onMouseScroll);\n\t\t\t\t_containerNode.removeEventListener('mousewheel', _onMouseScroll);\n\t\t\t\t_containerNode.removeEventListener('click', _onClick, true);\n\t\t\t}\n\n\t\t\tif (_contentParentNode) {\n\t\t\t\t_contentParentNode.removeEventListener('focus', _childFocused);\n\t\t\t\t_contentParentNode.removeEventListener('DOMSubtreeModified', _domChanged);\n\t\t\t\t_contentParentNode.removeEventListener('load', _domChanged);\n\t\t\t}\n\n\t\t\tif (_mutationObserver) {\n\t\t\t\t_mutationObserver.disconnect();\n\t\t\t}\n\n\t\t\tdocument.removeEventListener('mousemove', _onMouseMove);\n\t\t\tdocument.removeEventListener('mouseup', _onMouseUp);\n\t\t\tdocument.removeEventListener('click', _onClick, true);\n\t\t\twindow.removeEventListener('resize', _domChanged);\n\t\t};\n\n\t\t/**\n\t\t * Touch event handlers\n\t\t */\n\t\t_onTouchStart = function _onTouchStart(startEvent) {\n\t\t\tvar i, l, touchEvent;\n\n\t\t\t// If a touch is already active, ensure that the index\n\t\t\t// is mapped to the correct finger, and return.\n\t\t\tif (_inputIdentifier) {\n\t\t\t\tfor (i = 0, l = startEvent.touches.length; i < l; i = i + 1) {\n\t\t\t\t\tif (startEvent.touches[i].identifier === _inputIdentifier) {\n\t\t\t\t\t\t_inputIndex = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Track the new touch's identifier, reset index, and pass\n\t\t\t// the coordinates to the scroll start function.\n\t\t\ttouchEvent = startEvent.touches[0];\n\t\t\t_inputIdentifier = touchEvent.identifier;\n\t\t\t_inputIndex = 0;\n\t\t\t_startScroll(touchEvent.clientX, touchEvent.clientY, startEvent.timeStamp, startEvent);\n\t\t};\n\t\t_onTouchMove = function _onTouchMove(moveEvent) {\n\t\t\tif (_inputIdentifier === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Get the coordinates from the appropriate touch event and\n\t\t\t// pass them on to the scroll handler\n\t\t\tvar touchEvent = moveEvent.touches[_inputIndex];\n\t\t\t_updateScroll(touchEvent.clientX, touchEvent.clientY, moveEvent.timeStamp, moveEvent);\n\t\t};\n\t\t_onTouchEnd = function _onTouchEnd(endEvent) {\n\t\t\tvar i, l;\n\n\t\t\t// Check whether the original touch event is still active,\n\t\t\t// if it is, update the index and return.\n\t\t\tif (endEvent.touches) {\n\t\t\t\tfor (i = 0, l = endEvent.touches.length; i < l; i = i + 1) {\n\t\t\t\t\tif (endEvent.touches[i].identifier === _inputIdentifier) {\n\t\t\t\t\t\t_inputIndex = i;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Complete the scroll.  Note that touch end events\n\t\t\t// don't capture coordinates.\n\t\t\t_endScroll(endEvent.timeStamp, endEvent);\n\t\t};\n\n\t\t/**\n\t\t * Mouse event handlers\n\t\t */\n\t\t_onMouseDown = function _onMouseDown(startEvent) {\n\n\t\t\t// Don't track the right mouse buttons, or a context menu\n\t\t\tif ((startEvent.button && startEvent.button === 2) || startEvent.ctrlKey) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Capture if possible\n\t\t\tif (_containerNode.setCapture) {\n\t\t\t\t_containerNode.setCapture();\n\t\t\t}\n\n\t\t\t// Add move & up handlers to the *document* to allow handling outside the element\n\t\t\tdocument.addEventListener('mousemove', _onMouseMove, true);\n\t\t\tdocument.addEventListener('mouseup', _onMouseUp, true);\n\n\t\t\t_inputIdentifier = startEvent.button || 1;\n\t\t\t_inputIndex = 0;\n\t\t\t_startScroll(startEvent.clientX, startEvent.clientY, startEvent.timeStamp, startEvent);\n\t\t};\n\t\t_onMouseMove = function _onMouseMove(moveEvent) {\n\t\t\tif (!_inputIdentifier) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_updateScroll(moveEvent.clientX, moveEvent.clientY, moveEvent.timeStamp, moveEvent);\n\t\t};\n\t\t_onMouseUp = function _onMouseUp(endEvent) {\n\t\t\tif (endEvent.button && endEvent.button !== _inputIdentifier) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tdocument.removeEventListener('mousemove', _onMouseMove, true);\n\t\t\tdocument.removeEventListener('mouseup', _onMouseUp, true);\n\n\t\t\t// Release capture if possible\n\t\t\tif (_containerNode.releaseCapture) {\n\t\t\t\t_containerNode.releaseCapture();\n\t\t\t}\n\n\t\t\t_endScroll(endEvent.timeStamp, endEvent);\n\t\t};\n\n\t\t/**\n\t\t * Pointer event handlers\n\t\t */\n\t\t_onPointerDown = function _onPointerDown(startEvent) {\n\n\t\t\t// If there is already a pointer event being tracked, ignore subsequent.\n\t\t\t// However, if this pointer is seen as the primary pointer, override that.\n\t\t\tif (_inputIdentifier && !startEvent.isPrimary) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Disable specific input types if specified in the config.  Separate\n\t\t\t// out touch and other events (eg treat both pen and mouse as \"mouse\")\n\t\t\tif (startEvent.pointerType === _pointerTypeTouch) {\n\t\t\t\tif (_instanceOptions.disabledInputMethods.touch) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else if (_instanceOptions.disabledInputMethods.mouse) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_inputIdentifier = startEvent.pointerId;\n\t\t\t_startScroll(startEvent.clientX, startEvent.clientY, startEvent.timeStamp, startEvent);\n\t\t};\n\t\t_onPointerMove = function _onPointerMove(moveEvent) {\n\t\t\tif (_inputIdentifier !== moveEvent.pointerId) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t_updateScroll(moveEvent.clientX, moveEvent.clientY, moveEvent.timeStamp, moveEvent);\n\t\t};\n\t\t_onPointerUp = function _onPointerUp(endEvent) {\n\t\t\tif (_inputIdentifier !== endEvent.pointerId) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_endScroll(endEvent.timeStamp, endEvent);\n\t\t};\n\t\t_onPointerCancel = function _onPointerCancel(endEvent) {\n\t\t\t_endScroll(endEvent.timeStamp, endEvent);\n\t\t};\n\t\t_onPointerCaptureEnd = function _onPointerCaptureEnd(event) {\n\n\t\t\t// On pointer capture end - which can happen because of another element\n\t\t\t// releasing pointer capture - don't end scrolling, but do track that\n\t\t\t// input capture has been lost.  This will result in pointers leaving\n\t\t\t// the window possibly being lost, but further interactions will fix\n\t\t\t// the tracking again.\n\t\t\t_inputCaptured = false;\n\t\t};\n\n\n\t\t/**\n\t\t * Prevents click actions if appropriate\n\t\t */\n\t\t_onClick = function _onClick(clickEvent) {\n\n\t\t\t// If a scroll action hasn't resulted in the next scroll being prevented, and a scroll\n\t\t\t// isn't currently in progress with a different identifier, allow the click\n\t\t\tif (!_preventClick) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// Prevent clicks using the preventDefault() and stopPropagation() handlers on the event;\n\t\t\t// this is safe even in IE10 as this is always a \"true\" event, never a window.event.\n\t\t\tclickEvent.preventDefault();\n\t\t\tclickEvent.stopPropagation();\n\t\t\tif (!_inputIdentifier) {\n\t\t\t\t_preventClick = false;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\n\t\t/**\n\t\t * Process scroll wheel/input actions as scroller scrolls\n\t\t */\n\t\t_onMouseScroll = function _onMouseScroll(event) {\n\t\t\tvar scrollDeltaX, scrollDeltaY;\n\t\t\tif (_inputIdentifier !== 'scrollwheel') {\n\t\t\t\tif (_inputIdentifier !== false) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t_inputIdentifier = 'scrollwheel';\n\t\t\t\t_cumulativeScroll.x = 0;\n\t\t\t\t_cumulativeScroll.y = 0;\n\n\t\t\t\t// Start a scroll event\n\t\t\t\tif (!_startScroll(event.clientX, event.clientY, Date.now(), event)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Convert the scrollwheel values to a scroll value\n\t\t\tif (event.wheelDelta) {\n\t\t\t\tif (event.wheelDeltaX) {\n\t\t\t\t\tscrollDeltaX = event.wheelDeltaX / 2;\n\t\t\t\t\tscrollDeltaY = event.wheelDeltaY / 2;\n\t\t\t\t} else {\n\t\t\t\t\tscrollDeltaX = 0;\n\t\t\t\t\tscrollDeltaY = event.wheelDelta / 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (event.axis && event.axis === event.HORIZONTAL_AXIS) {\n\t\t\t\t\tscrollDeltaX = event.detail * -10;\n\t\t\t\t\tscrollDeltaY = 0;\n\t\t\t\t} else {\n\t\t\t\t\tscrollDeltaX = 0;\n\t\t\t\t\tscrollDeltaY = event.detail * -10;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If the scroller is constrained to an x axis, convert y scroll to allow single-axis scroll\n\t\t\t// wheels to scroll constrained content.\n\t\t\tif (!_instanceOptions.scrollingY && !scrollDeltaX) {\n\t\t\t\tscrollDeltaX = scrollDeltaY;\n\t\t\t\tscrollDeltaY = 0;\n\t\t\t}\n\n\t\t\t_cumulativeScroll.x = Math.round(_cumulativeScroll.x + scrollDeltaX);\n\t\t\t_cumulativeScroll.y = Math.round(_cumulativeScroll.y + scrollDeltaY);\n\n\t\t\t_updateScroll(_gestureStart.x + _cumulativeScroll.x, _gestureStart.y + _cumulativeScroll.y, event.timeStamp, event);\n\n\t\t\t// End scrolling state\n\t\t\tif (_scrollWheelEndDebouncer) {\n\t\t\t\tclearTimeout(_scrollWheelEndDebouncer);\n\t\t\t}\n\t\t\t_scrollWheelEndDebouncer = setTimeout(function () {\n\t\t\t\t_releaseInputCapture();\n\t\t\t\t_inputIdentifier = false;\n\t\t\t\t_isScrolling = false;\n\t\t\t\t_preventClick = false;\n\t\t\t\t_isDisplayingScroll = false;\n\t\t\t\t_ftscrollerMoving = false;\n\t\t\t\tif (_instanceOptions.windowScrollingActiveFlag) {\n\t\t\t\t\twindow[_instanceOptions.windowScrollingActiveFlag] = false;\n\t\t\t\t}\n\t\t\t\t_cancelAnimation();\n\t\t\t\tif (!_snapScroll()) {\n\t\t\t\t\t_finalizeScroll();\n\t\t\t\t}\n\t\t\t}, 300);\n\t\t};\n\n\t\t/**\n\t\t * Capture and release input support, particularly allowing tracking\n\t\t * of Metro pointers outside the docked view.  Note that _releaseInputCapture\n\t\t * should be called before the input identifier is cleared.\n\t\t */\n\t\t_captureInput = function _captureInput() {\n\t\t\tif (_inputCaptured || _inputIdentifier === false || _inputIdentifier === 'scrollwheel') {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (_trackPointerEvents) {\n\t\t\t\t_containerNode[_setPointerCapture](_inputIdentifier);\n\t\t\t\t_containerNode.addEventListener(_lostPointerCapture, _onPointerCaptureEnd, false);\n\t\t\t}\n\t\t\t_inputCaptured = true;\n\t\t};\n\t\t_releaseInputCapture = function _releaseInputCapture() {\n\t\t\tif (!_inputCaptured) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (_trackPointerEvents) {\n\t\t\t\t_containerNode.removeEventListener(_lostPointerCapture, _onPointerCaptureEnd, false);\n\t\t\t\t_containerNode[_releasePointerCapture](_inputIdentifier);\n\t\t\t}\n\t\t\t_inputCaptured = false;\n\t\t};\n\n\t\t/**\n\t\t * Utility function acting as a getBoundingClientRect polyfill.\n\t\t */\n\t\t_getBoundingRect = function _getBoundingRect(anElement) {\n\t\t\tif (anElement.getBoundingClientRect) {\n\t\t\t\treturn anElement.getBoundingClientRect();\n\t\t\t}\n\n\t\t\tvar x = 0, y = 0, eachElement = anElement;\n\t\t\twhile (eachElement) {\n\t\t\t\tx = x + eachElement.offsetLeft - eachElement.scrollLeft;\n\t\t\t\ty = y + eachElement.offsetTop - eachElement.scrollTop;\n\t\t\t\teachElement = eachElement.offsetParent;\n\t\t\t}\n\t\t\treturn { left: x, top: y, width: anElement.offsetWidth, height: anElement.offsetHeight };\n\t\t};\n\n\n\t\t/*                     Instantiation                     */\n\n\t\t// Set up the DOM node if appropriate\n\t\t_initializeDOM();\n\n\t\t// Update sizes\n\t\t_updateDimensions();\n\n\t\t// Set up the event handlers\n\t\t_addEventHandlers();\n\n\t\t// Define a public API to be returned at the bottom - this is the public-facing interface.\n\t\t_publicSelf = {\n\t\t\tdestroy: destroy,\n\t\t\tsetSnapSize: setSnapSize,\n\t\t\tscrollTo: scrollTo,\n\t\t\tscrollBy: scrollBy,\n\t\t\tupdateDimensions: updateDimensions,\n\t\t\taddEventListener: addEventListener,\n\t\t\tremoveEventListener: removeEventListener,\n\t\t\tsetDisabledInputMethods: setDisabledInputMethods\n\t\t};\n\n\t\tif (Object.defineProperties) {\n\t\t\tObject.defineProperties(_publicSelf, {\n\t\t\t\t'scrollHeight': {\n\t\t\t\t\tget: function() { return _metrics.content.y; },\n\t\t\t\t\tset: function(value) { throw new SyntaxError('scrollHeight is currently read-only - ignoring ' + value); }\n\t\t\t\t},\n\t\t\t\t'scrollLeft': {\n\t\t\t\t\tget: function() { return -_lastScrollPosition.x; },\n\t\t\t\t\tset: function(value) { scrollTo(value, false, false); return -_lastScrollPosition.x; }\n\t\t\t\t},\n\t\t\t\t'scrollTop': {\n\t\t\t\t\tget: function() { return -_lastScrollPosition.y; },\n\t\t\t\t\tset: function(value) { scrollTo(false, value, false); return -_lastScrollPosition.y; }\n\t\t\t\t},\n\t\t\t\t'scrollWidth': {\n\t\t\t\t\tget: function() { return _metrics.content.x; },\n\t\t\t\t\tset: function(value) { throw new SyntaxError('scrollWidth is currently read-only - ignoring ' + value); }\n\t\t\t\t},\n\t\t\t\t'segmentCount': {\n\t\t\t\t\tget: function() {\n\t\t\t\t\t\tif (!_instanceOptions.snapping) {\n\t\t\t\t\t\t\treturn { x: NaN, y: NaN };\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tx: Math.ceil(_metrics.content.x / _snapGridSize.x),\n\t\t\t\t\t\t\ty: Math.ceil(_metrics.content.y / _snapGridSize.y)\n\t\t\t\t\t\t};\n\t\t\t\t\t},\n\t\t\t\t\tset: function(value) { throw new SyntaxError('segmentCount is currently read-only - ignoring ' + value); }\n\t\t\t\t},\n\t\t\t\t'currentSegment': {\n\t\t\t\t\tget: function() { return { x: _activeSegment.x, y: _activeSegment.y }; },\n\t\t\t\t\tset: function(value) { throw new SyntaxError('currentSegment is currently read-only - ignoring ' + value); }\n\t\t\t\t},\n\t\t\t\t'contentContainerNode': {\n\t\t\t\t\tget: function() { return _contentParentNode; },\n\t\t\t\t\tset: function(value) { throw new SyntaxError('contentContainerNode is currently read-only - ignoring ' + value); }\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// Return the public interface.\n\t\treturn _publicSelf;\n\t};\n\n\n\t/*          Prototype Functions and Properties           */\n\n\t/**\n\t * The HTML to prepend to the scrollable content to wrap it. Used internally,\n\t * and may be used to pre-wrap scrollable content.  Axes can optionally\n\t * be excluded for speed improvements.\n\t */\n\tFTScroller.prototype.getPrependedHTML = function (excludeXAxis, excludeYAxis, hwAccelerationClass) {\n\t\tif (!hwAccelerationClass) {\n\t\t\tif (typeof FTScrollerOptions === 'object' && FTScrollerOptions.hwAccelerationClass) {\n\t\t\t\thwAccelerationClass = FTScrollerOptions.hwAccelerationClass;\n\t\t\t} else {\n\t\t\t\thwAccelerationClass = 'ftscroller_hwaccelerated';\n\t\t\t}\n\t\t}\n\n\t\tvar output = '<div class=\"ftscroller_container\">';\n\t\tif (!excludeXAxis) {\n\t\t\toutput += '<div class=\"ftscroller_x ' + hwAccelerationClass + '\">';\n\t\t}\n\t\tif (!excludeYAxis) {\n\t\t\toutput += '<div class=\"ftscroller_y ' + hwAccelerationClass + '\">';\n\t\t}\n\n\t\treturn output;\n\t};\n\n\t/**\n\t * The HTML to append to the scrollable content to wrap it; again, used internally,\n\t * and may be used to pre-wrap scrollable content.\n\t */\n\tFTScroller.prototype.getAppendedHTML = function (excludeXAxis, excludeYAxis, hwAccelerationClass, scrollbars) {\n\t\tif (!hwAccelerationClass) {\n\t\t\tif (typeof FTScrollerOptions === 'object' && FTScrollerOptions.hwAccelerationClass) {\n\t\t\t\thwAccelerationClass = FTScrollerOptions.hwAccelerationClass;\n\t\t\t} else {\n\t\t\t\thwAccelerationClass = 'ftscroller_hwaccelerated';\n\t\t\t}\n\t\t}\n\n\t\tvar output = '';\n\t\tif (!excludeXAxis) {\n\t\t\toutput += '</div>';\n\t\t}\n\t\tif (!excludeYAxis) {\n\t\t\toutput += '</div>';\n\t\t}\n\t\tif (scrollbars) {\n\t\t\tif (!excludeXAxis) {\n\t\t\t\toutput += '<div class=\"ftscroller_scrollbar ftscroller_scrollbarx ' + hwAccelerationClass + '\"><div class=\"ftscroller_scrollbarinner\"></div></div>';\n\t\t\t}\n\t\t\tif (!excludeYAxis) {\n\t\t\t\toutput += '<div class=\"ftscroller_scrollbar ftscroller_scrollbary ' + hwAccelerationClass + '\"><div class=\"ftscroller_scrollbarinner\"></div></div>';\n\t\t\t}\n\t\t}\n\t\toutput += '</div>';\n\n\t\treturn output;\n\t};\n}());\n\n\n(function () {\n\t'use strict';\n\n\tfunction clamp(value) {\n\t\tif (value > 1.0) return 1.0;\n\t\tif (value < 0.0) return 0.0;\n\t\treturn value;\n\t}\n\n\t/**\n\t * Represents a two-dimensional cubic bezier curve with the starting\n\t * point (0, 0) and the end point (1, 1). The two control points p1 and p2\n\t * have x and y coordinates between 0 and 1.\n\t *\n\t * This type of bezier curves can be used as CSS transform timing functions.\n\t */\n\tCubicBezier = function (p1x, p1y, p2x, p2y) {\n\t\t// Control points\n\t\tthis._p1 = { x: clamp(p1x), y: clamp(p1y) };\n\t\tthis._p2 = { x: clamp(p2x), y: clamp(p2y) };\n\t};\n\n\tCubicBezier.prototype._getCoordinateForT = function (t, p1, p2) {\n\t\tvar c = 3 * p1,\n\t\t\tb = 3 * (p2 - p1) - c,\n\t\t\ta = 1 - c - b;\n\n\t\treturn ((a * t + b) * t + c) * t;\n\t};\n\n\tCubicBezier.prototype._getCoordinateDerivateForT = function (t, p1, p2) {\n\t\tvar c = 3 * p1,\n\t\t\tb = 3 * (p2 - p1) - c,\n\t\t\ta = 1 - c - b;\n\n\t\treturn (3 * a * t + 2 * b) * t + c;\n\t};\n\n\tCubicBezier.prototype._getTForCoordinate = function (c, p1, p2, epsilon) {\n\t\tif (!isFinite(epsilon) || epsilon <= 0) {\n\t\t\tthrow new RangeError('\"epsilon\" must be a number greater than 0.');\n\t\t}\n\t\tvar t2, i, c2, d2;\n\n\t\t// First try a few iterations of Newton's method -- normally very fast.\n\t\tfor (t2 = c, i = 0; i < 8; i = i + 1) {\n\t\t\tc2 = this._getCoordinateForT(t2, p1, p2) - c;\n\t\t\tif (Math.abs(c2) < epsilon) {\n\t\t\t\treturn t2;\n\t\t\t}\n\t\t\td2 = this._getCoordinateDerivateForT(t2, p1, p2);\n\t\t\tif (Math.abs(d2) < 1e-6) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tt2 = t2 - c2 / d2;\n\t\t}\n\n\t\t// Fall back to the bisection method for reliability.\n\t\tt2 = c;\n\t\tvar t0 = 0,\n\t\t\tt1 = 1;\n\n\t\tif (t2 < t0) {\n\t\t\treturn t0;\n\t\t}\n\t\tif (t2 > t1) {\n\t\t\treturn t1;\n\t\t}\n\n\t\twhile (t0 < t1) {\n\t\t\tc2 = this._getCoordinateForT(t2, p1, p2);\n\t\t\tif (Math.abs(c2 - c) < epsilon) {\n\t\t\t\treturn t2;\n\t\t\t}\n\t\t\tif (c > c2) {\n\t\t\t\tt0 = t2;\n\t\t\t} else {\n\t\t\t\tt1 = t2;\n\t\t\t}\n\t\t\tt2 = (t1 - t0) * 0.5 + t0;\n\t\t}\n\n\t\t// Failure.\n\t\treturn t2;\n\t};\n\n\t/**\n\t * Computes the point for a given t value.\n\t *\n\t * @param {number} t\n\t * @returns {Object} Returns an object with x and y properties\n\t */\n\tCubicBezier.prototype.getPointForT = function (t) {\n\n\t\t// Special cases: starting and ending points\n\t\tif (t === 0 || t === 1) {\n\t\t\treturn { x: t, y: t };\n\t\t}\n\n\t\t// Check for correct t value (must be between 0 and 1)\n\t\tif (t < 0 || t > 1) {\n\t\t\t_throwRangeError('t', t);\n\t\t}\n\n\t\treturn {\n\t\t\tx: this._getCoordinateForT(t, this._p1.x, this._p2.x),\n\t\t\ty: this._getCoordinateForT(t, this._p1.y, this._p2.y)\n\t\t};\n\t};\n\n\tCubicBezier.prototype.getTForX = function (x, epsilon) {\n\t\treturn this._getTForCoordinate(x, this._p1.x, this._p2.x, epsilon);\n\t};\n\n\tCubicBezier.prototype.getTForY = function (y, epsilon) {\n\t\treturn this._getTForCoordinate(y, this._p1.y, this._p2.y, epsilon);\n\t};\n\n\t/**\n\t * Computes auxiliary points using De Casteljau's algorithm.\n\t *\n\t * @param {number} t must be greater than 0 and lower than 1.\n\t * @returns {Object} with members i0, i1, i2 (first iteration),\n\t *    j1, j2 (second iteration) and k (the exact point for t)\n\t */\n\tCubicBezier.prototype._getAuxPoints = function (t) {\n\t\tif (t <= 0 || t >= 1) {\n\t\t\t_throwRangeError('t', t);\n\t\t}\n\n\n\t\t/* First series of auxiliary points */\n\n\t\t// First control point of the left curve\n\t\tvar i0 = {\n\t\t\t\tx: t * this._p1.x,\n\t\t\t\ty: t * this._p1.y\n\t\t\t},\n\t\t\ti1 = {\n\t\t\t\tx: this._p1.x + t * (this._p2.x - this._p1.x),\n\t\t\t\ty: this._p1.y + t * (this._p2.y - this._p1.y)\n\t\t\t},\n\n\t\t\t// Second control point of the right curve\n\t\t\ti2  = {\n\t\t\t\tx: this._p2.x + t * (1 - this._p2.x),\n\t\t\t\ty: this._p2.y + t * (1 - this._p2.y)\n\t\t\t};\n\n\n\t\t/* Second series of auxiliary points */\n\n\t\t// Second control point of the left curve\n\t\tvar j0 = {\n\t\t\t\tx: i0.x + t * (i1.x - i0.x),\n\t\t\t\ty: i0.y + t * (i1.y - i0.y)\n\t\t\t},\n\n\t\t\t// First control point of the right curve\n\t\t\tj1 = {\n\t\t\t\tx: i1.x + t * (i2.x - i1.x),\n\t\t\t\ty: i1.y + t * (i2.y - i1.y)\n\t\t\t};\n\n\t\t// The division point (ending point of left curve, starting point of right curve)\n\t\tvar k = {\n\t\t\t\tx: j0.x + t * (j1.x - j0.x),\n\t\t\t\ty: j0.y + t * (j1.y - j0.y)\n\t\t\t};\n\n\t\treturn {\n\t\t\ti0: i0,\n\t\t\ti1: i1,\n\t\t\ti2: i2,\n\t\t\tj0: j0,\n\t\t\tj1: j1,\n\t\t\tk: k\n\t\t};\n\t};\n\n\t/**\n\t * Divides the bezier curve into two bezier functions.\n\t *\n\t * De Casteljau's algorithm is used to compute the new starting, ending, and\n\t * control points.\n\t *\n\t * @param {number} t must be greater than 0 and lower than 1.\n\t *     t === 1 or t === 0 are the starting/ending points of the curve, so no\n\t *     division is needed.\n\t *\n\t * @returns {CubicBezier[]} Returns an array containing two bezier curves\n\t *     to the left and the right of t.\n\t */\n\tCubicBezier.prototype.divideAtT = function (t) {\n\t\tif (t < 0 || t > 1) {\n\t\t\t_throwRangeError('t', t);\n\t\t}\n\n\t\t// Special cases t = 0, t = 1: Curve can be cloned for one side, the other\n\t\t// side is a linear curve (with duration 0)\n\t\tif (t === 0 || t === 1) {\n\t\t\tvar curves = [];\n\t\t\tcurves[t] = CubicBezier.linear();\n\t\t\tcurves[1 - t] = this.clone();\n\t\t\treturn curves;\n\t\t}\n\n\t\tvar left = {},\n\t\t\tright = {},\n\t\t\tpoints = this._getAuxPoints(t);\n\n\t\tvar i0 = points.i0,\n\t\t\ti2 = points.i2,\n\t\t\tj0 = points.j0,\n\t\t\tj1 = points.j1,\n\t\t\tk = points.k;\n\n\t\t// Normalize derived points, so that the new curves starting/ending point\n\t\t// coordinates are (0, 0) respectively (1, 1)\n\t\tvar factorX = k.x,\n\t\t\tfactorY = k.y;\n\n\t\tleft.p1 = {\n\t\t\tx: i0.x / factorX,\n\t\t\ty: i0.y / factorY\n\t\t};\n\t\tleft.p2 = {\n\t\t\tx: j0.x / factorX,\n\t\t\ty: j0.y / factorY\n\t\t};\n\n\t\tright.p1 = {\n\t\t\tx: (j1.x - factorX) / (1 - factorX),\n\t\t\ty: (j1.y - factorY) / (1 - factorY)\n\t\t};\n\n\t\tright.p2 = {\n\t\t\tx: (i2.x - factorX) / (1 - factorX),\n\t\t\ty: (i2.y - factorY) / (1 - factorY)\n\t\t};\n\n\t\treturn [\n\t\t\tnew CubicBezier(left.p1.x, left.p1.y, left.p2.x, left.p2.y),\n\t\t\tnew CubicBezier(right.p1.x, right.p1.y, right.p2.x, right.p2.y)\n\t\t];\n\t};\n\n\tCubicBezier.prototype.divideAtX = function (x, epsilon) {\n\t\tif (x < 0 || x > 1) {\n\t\t\t_throwRangeError('x', x);\n\t\t}\n\n\t\tvar t = this.getTForX(x, epsilon);\n\t\treturn this.divideAtT(t);\n\t};\n\n\tCubicBezier.prototype.divideAtY = function (y, epsilon) {\n\t\tif (y < 0 || y > 1) {\n\t\t\t_throwRangeError('y', y);\n\t\t}\n\n\t\tvar t = this.getTForY(y, epsilon);\n\t\treturn this.divideAtT(t);\n\t};\n\n\tCubicBezier.prototype.clone = function () {\n\t\treturn new CubicBezier(this._p1.x, this._p1.y, this._p2.x, this._p2.y);\n\t};\n\n\tCubicBezier.prototype.toString = function () {\n\t\treturn \"cubic-bezier(\" + [\n\t\t\tthis._p1.x,\n\t\t\tthis._p1.y,\n\t\t\tthis._p2.x,\n\t\t\tthis._p2.y\n\t\t].join(\", \") + \")\";\n\t};\n\n\tCubicBezier.linear = function () {\n\t\treturn new CubicBezier();\n\t};\n\n\tCubicBezier.ease = function () {\n\t\treturn new CubicBezier(0.25, 0.1, 0.25, 1.0);\n\t};\n\tCubicBezier.linear = function () {\n\t\treturn new CubicBezier(0.0, 0.0, 1.0, 1.0);\n\t};\n\tCubicBezier.easeIn = function () {\n\t\treturn new CubicBezier(0.42, 0, 1.0, 1.0);\n\t};\n\tCubicBezier.easeOut = function () {\n\t\treturn new CubicBezier(0, 0, 0.58, 1.0);\n\t};\n\tCubicBezier.easeInOut = function () {\n\t\treturn new CubicBezier(0.42, 0, 0.58, 1.0);\n\t};\n}());\n\nif (typeof define !== 'undefined' && define.amd) {\n\t// AMD. Register as an anonymous module.\n\tdefine(function() {\n\t\t'use strict';\n\t\treturn {\n\t\t\tFTScroller: FTScroller,\n\t\t\tCubicBezier: CubicBezier\n\t\t};\n\t});\n} else if (typeof module !== 'undefined' && module.exports) {\n\tmodule.exports = function(domNode, options) {\n\t\t'use strict';\n\t\treturn new FTScroller(domNode, options);\n\t};\n\n\tmodule.exports.FTScroller = FTScroller;\n\tmodule.exports.CubicBezier = CubicBezier;\n}\n","text":"/**\n * FTScroller: touch and mouse-based scrolling for DOM elements larger than their containers.\n *\n * While this is a rewrite, it is heavily inspired by two projects:\n * 1) Uxebu TouchScroll (https://github.com/davidaurelio/TouchScroll), BSD licensed:\n *    Copyright (c) 2010 uxebu Consulting Ltd. & Co. KG\n *    Copyright (c) 2010 David Aurelio\n * 2) Zynga Scroller (https://github.com/zynga/scroller), MIT licensed:\n *    Copyright 2011, Zynga Inc.\n *    Copyright 2011, Deutsche Telekom AG\n *\n * Includes CubicBezier:\n *\n * Copyright (C) 2008 Apple Inc. All Rights Reserved.\n * Copyright (C) 2010 David Aurelio. All Rights Reserved.\n * Copyright (C) 2010 uxebu Consulting Ltd. & Co. KG. All Rights Reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY APPLE INC., DAVID AURELIO, AND UXEBU\n * CONSULTING LTD. & CO. KG ``AS IS'' AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL APPLE INC. OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *\n * @copyright The Financial Times Ltd [All rights reserved]\n * @codingstandard ftlabs-jslint\n * @version 0.5.1\n */\n/**\n * @license FTScroller is (c) 2012 The Financial Times Ltd [All rights reserved] and licensed under the MIT license.\n *\n * Inspired by Uxebu TouchScroll, (c) 2010 uxebu Consulting Ltd. & Co. KG and David Aurelio, which is BSD licensed (https://github.com/davidaurelio/TouchScroll)\n * Inspired by Zynga Scroller, (c) 2011 Zynga Inc and Deutsche Telekom AG, which is MIT licensed (https://github.com/zynga/scroller)\n * Includes CubicBezier, (c) 2008 Apple Inc [All rights reserved], (c) 2010 David Aurelio and uxebu Consulting Ltd. & Co. KG. [All rights reserved], which is 2-clause BSD licensed (see above or https://github.com/davidaurelio/TouchScroll).\n */\n\n/*jslint nomen: true, vars: true, browser: true, continue: true, white: true*/\n/*globals FTScrollerOptions*/\n\nvar FTScroller, CubicBezier;\n\n(function () {\n\t'use strict';\n\n\t// Determine the browser engine and prefix, trying to use the unprefixed version where available.\n\tvar _vendorCSSPrefix, _vendorStylePropertyPrefix, _vendorTransformLookup,\n\t\t_pointerEventsPrefixed, _setPointerCapture, _releasePointerCapture, _lostPointerCapture, _trackPointerEvents, _pointerTypeTouch;\n\tif (document.createElement('div').style.transform !== undefined) {\n\t\t_vendorCSSPrefix = '';\n\t\t_vendorStylePropertyPrefix = '';\n\t\t_vendorTransformLookup = 'transform';\n\t} else if (window.opera && Object.prototype.toString.call(window.opera) === '[object Opera]') {\n\t\t_vendorCSSPrefix = '-o-';\n\t\t_vendorStylePropertyPrefix = 'O';\n\t\t_vendorTransformLookup = 'OTransform';\n\t} else if (document.documentElement.style.MozTransform !== undefined) {\n\t\t_vendorCSSPrefix = '-moz-';\n\t\t_vendorStylePropertyPrefix = 'Moz';\n\t\t_vendorTransformLookup = 'MozTransform';\n\t} else if (document.documentElement.style.webkitTransform !== undefined) {\n\t\t_vendorCSSPrefix = '-webkit-';\n\t\t_vendorStylePropertyPrefix = 'webkit';\n\t\t_vendorTransformLookup = '-webkit-transform';\n\t} else if (typeof navigator.cpuClass === 'string') {\n\t\t_vendorCSSPrefix = '-ms-';\n\t\t_vendorStylePropertyPrefix = 'ms';\n\t\t_vendorTransformLookup = '-ms-transform';\n\t}\n\n\t// Pointer Events are unprefixed in IE11\n\tif ('pointerEnabled' in window.navigator) {\n\t\t_pointerEventsPrefixed = false;\n\t\t_trackPointerEvents    = window.navigator.pointerEnabled;\n\t\t_setPointerCapture     = 'setPointerCapture';\n\t\t_releasePointerCapture = 'releasePointerCapture';\n\t\t_lostPointerCapture    = 'lostpointercapture';\n\t\t_pointerTypeTouch      = 'touch';\n\t} else if ('msPointerEnabled' in window.navigator) {\n\t\t_pointerEventsPrefixed = true;\n\t\t_trackPointerEvents    = window.navigator.msPointerEnabled;\n\t\t_setPointerCapture     = 'msSetPointerCapture';\n\t\t_releasePointerCapture = 'msReleasePointerCapture';\n\t\t_lostPointerCapture    = 'MSLostPointerCapture';\n\t\t_pointerTypeTouch      = 2; // PointerEvent.MSPOINTER_TYPE_TOUCH = 2 in IE10\n\t}\n\n\t// Global flag to determine if any scroll is currently active.  This prevents\n\t// issues when using multiple scrollers, particularly when they're nested.\n\tvar _ftscrollerMoving = false;\n\n\t// Determine whether pointer events or touch events can be used\n\tvar _trackTouchEvents = false;\n\tif ('propertyIsEnumerable' in window || 'hasOwnProperty' in window.document) {\n\t\t_trackTouchEvents = !_trackPointerEvents && (window.propertyIsEnumerable('ontouchstart') || window.document.hasOwnProperty('ontouchstart'));\n\t}\n\n\t// Determine whether to use modern hardware acceleration rules or dynamic/toggleable rules.\n\t// Certain older browsers - particularly Android browsers - have problems with hardware\n\t// acceleration, so being able to toggle the behaviour dynamically via a CSS cascade is desirable.\n\tvar _useToggleableHardwareAcceleration = false;\n\tif ('hasOwnProperty' in window) {\n\t\t_useToggleableHardwareAcceleration = !window.hasOwnProperty('ArrayBuffer');\n\t}\n\n\t// Feature detection\n\tvar _canClearSelection = (window.Selection && window.Selection.prototype.removeAllRanges);\n\n\t// If hardware acceleration is using the standard path, but perspective doesn't seem to be supported,\n\t// 3D transforms likely aren't supported either\n\tif (!_useToggleableHardwareAcceleration && document.createElement('div').style[_vendorStylePropertyPrefix + (_vendorStylePropertyPrefix ? 'P' : 'p') + 'erspective'] === undefined) {\n\t\t_useToggleableHardwareAcceleration = true;\n\t}\n\n\t// Style prefixes\n\tvar _transformProperty = _vendorStylePropertyPrefix + (_vendorStylePropertyPrefix ? 'T' : 't') + 'ransform';\n\tvar _transitionProperty = _vendorStylePropertyPrefix + (_vendorStylePropertyPrefix ? 'T' : 't') + 'ransition';\n\tvar _translateRulePrefix = _useToggleableHardwareAcceleration ? 'translate(' : 'translate3d(';\n\tvar _transformPrefixes = { x: '', y: '0,' };\n\tvar _transformSuffixes = { x: ',0' + (_useToggleableHardwareAcceleration ? ')' : ',0)'), y: (_useToggleableHardwareAcceleration ? ')' : ',0)') };\n\n\t// Constants.  Note that the bezier curve should be changed along with the friction!\n\tvar _kFriction = 0.998;\n\tvar _kMinimumSpeed = 0.01;\n\n\t// Create a global stylesheet to set up stylesheet rules and track dynamic entries\n\t(function () {\n\t\tvar stylesheetContainerNode = document.getElementsByTagName('head')[0] || document.documentElement;\n\t\tvar newStyleNode = document.createElement('style');\n\t\tvar hardwareAccelerationRule;\n\t\tvar _styleText;\n\t\tnewStyleNode.type = 'text/css';\n\n\t\t// Determine the hardware acceleration logic to use\n\t\tif (_useToggleableHardwareAcceleration) {\n\t\t\thardwareAccelerationRule = _vendorCSSPrefix + 'transform-style: preserve-3d;';\n\t\t} else {\n\t\t\thardwareAccelerationRule = _vendorCSSPrefix + 'transform: translateZ(0);';\n\t\t}\n\n\t\t// Add our rules\n\t\t_styleText = [\n\t\t\t'.ftscroller_container { overflow: hidden; position: relative; max-height: 100%; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); -ms-touch-action: none }',\n\t\t\t'.ftscroller_hwaccelerated { ' + hardwareAccelerationRule  + ' }',\n\t\t\t'.ftscroller_x, .ftscroller_y { position: relative; min-width: 100%; min-height: 100%; overflow: hidden }',\n\t\t\t'.ftscroller_x { display: inline-block }',\n\t\t\t'.ftscroller_scrollbar { pointer-events: none; position: absolute; width: 5px; height: 5px; border: 1px solid rgba(255, 255, 255, 0.3); -webkit-border-radius: 3px; border-radius: 6px; opacity: 0; ' + _vendorCSSPrefix + 'transition: opacity 350ms; z-index: 10; -webkit-box-sizing: content-box; -moz-box-sizing: content-box; box-sizing: content-box }',\n\t\t\t'.ftscroller_scrollbarx { bottom: 2px; left: 2px }',\n\t\t\t'.ftscroller_scrollbary { right: 2px; top: 2px }',\n\t\t\t'.ftscroller_scrollbarinner { height: 100%; background: #000; -webkit-border-radius: 2px; border-radius: 4px / 6px }',\n\t\t\t'.ftscroller_scrollbar.active { opacity: 0.5; ' + _vendorCSSPrefix + 'transition: none; -o-transition: all 0 none }'\n\t\t];\n\n\t\tif (newStyleNode.styleSheet) {\n\t\t\tnewStyleNode.styleSheet.cssText = _styleText.join('\\n');\n\t\t} else {\n\t\t\tnewStyleNode.appendChild(document.createTextNode(_styleText.join('\\n')));\n\t\t}\n\n\t\t// Add the stylesheet\n\t\tstylesheetContainerNode.insertBefore(newStyleNode, stylesheetContainerNode.firstChild);\n\t}());\n\n\t/**\n\t * Master constructor for the scrolling function, including which element to\n\t * construct the scroller in, and any scrolling options.\n\t * Note that app-wide options can also be set using a global FTScrollerOptions\n\t * object.\n\t */\n\tFTScroller = function (domNode, options) {\n\t\tvar key;\n\t\tvar destroy, setSnapSize, scrollTo, scrollBy, updateDimensions, addEventListener, removeEventListener, setDisabledInputMethods, _startScroll, _updateScroll, _endScroll, _finalizeScroll, _interruptScroll, _flingScroll, _snapScroll, _getSnapPositionForIndexes, _getSnapIndexForPosition, _constrainAndRenderTargetScrollPosition, _limitToBounds, _initializeDOM, _existingDOMValid, _domChanged, _updateDimensions, _updateScrollbarDimensions, _updateElementPosition, _updateSegments, _setAxisPosition, _getPosition, _scheduleAxisPosition, _fireEvent, _childFocused, _modifyDistanceBeyondBounds, _distancesBeyondBounds, _startAnimation, _scheduleRender, _cancelAnimation, _addEventHandlers, _removeEventHandlers, _resetEventHandlers, _onTouchStart, _onTouchMove, _onTouchEnd, _onMouseDown, _onMouseMove, _onMouseUp, _onPointerDown, _onPointerMove, _onPointerUp, _onPointerCancel, _onPointerCaptureEnd, _onClick, _onMouseScroll, _captureInput, _releaseInputCapture, _getBoundingRect;\n\n\n\t\t/* Note that actual object instantiation occurs at the end of the closure to avoid jslint errors */\n\n\n\t\t/*                         Options                       */\n\n\t\tvar _instanceOptions = {\n\n\t\t\t// Whether to display scrollbars as appropriate\n\t\t\tscrollbars: true,\n\n\t\t\t// Enable scrolling on the X axis if content is available\n\t\t\tscrollingX: true,\n\n\t\t\t// Enable scrolling on the Y axis if content is available\n\t\t\tscrollingY: true,\n\n\t\t\t// The initial movement required to trigger a scroll, in pixels; this is the point at which\n\t\t\t// the scroll is exclusive to this particular FTScroller instance.\n\t\t\tscrollBoundary: 1,\n\n\t\t\t// The initial movement required to trigger a visual indication that scrolling is occurring,\n\t\t\t// in pixels.  This is enforced to be less than or equal to the scrollBoundary, and is used to\n\t\t\t// define when the scroller starts drawing changes in response to an input, even if the scroll\n\t\t\t// is not treated as having begun/locked yet.\n\t\t\tscrollResponseBoundary: 1,\n\n\t\t\t// Whether to always enable scrolling, even if the content of the scroller does not\n\t\t\t// require the scroller to function.  This makes the scroller behave more like an\n\t\t\t// element set to \"overflow: scroll\", with bouncing always occurring if enabled.\n\t\t\talwaysScroll: false,\n\n\t\t\t// The content width to use when determining scroller dimensions.  If this\n\t\t\t// is false, the width will be detected based on the actual content.\n\t\t\tcontentWidth: undefined,\n\n\t\t\t// The content height to use when determining scroller dimensions.  If this\n\t\t\t// is false, the height will be detected based on the actual content.\n\t\t\tcontentHeight: undefined,\n\n\t\t\t// Enable snapping of content to 'pages' or a pixel grid\n\t\t\tsnapping: false,\n\n\t\t\t// Define the horizontal interval of the pixel grid; snapping must be enabled for this to\n\t\t\t// take effect.  If this is not defined, snapping will use intervals based on container size.\n\t\t\tsnapSizeX: undefined,\n\n\t\t\t// Define the vertical interval of the pixel grid; snapping must be enabled for this to\n\t\t\t// take effect.  If this is not defined, snapping will use intervals based on container size.\n\t\t\tsnapSizeY: undefined,\n\n\t\t\t// Control whether snapping should be curtailed to only ever flick to the next page\n\t\t\t// and not beyond.  Snapping needs to be enabled for this to take effect.\n\t\t\tsinglePageScrolls: false,\n\n\t\t\t// Allow scroll bouncing and elasticity near the ends and grid\n\t\t\tbouncing: true,\n\n\t\t\t// Allow a fast scroll to continue with momentum when released\n\t\t\tflinging: true,\n\n\t\t\t// Automatically detects changes to the contained markup and\n\t\t\t// updates its dimensions whenever the content changes. This is\n\t\t\t// set to false if a contentWidth or contentHeight are supplied.\n\t\t\tupdateOnChanges: true,\n\n\t\t\t// Automatically catches changes to the window size and updates\n\t\t\t// its dimensions.\n\t\t\tupdateOnWindowResize: false,\n\n\t\t\t// The alignment to use if the content is smaller than the container;\n\t\t\t// this also applies to initial positioning of scrollable content.\n\t\t\t// Valid alignments are -1 (top or left), 0 (center), and 1 (bottom or right).\n\t\t\tbaseAlignments: { x: -1, y: -1 },\n\n\t\t\t// Whether to use a window scroll flag, eg window.foo, to control whether\n\t\t\t// to allow scrolling to start or now.  If the window flag is set to true,\n\t\t\t// this element will not start scrolling; this element will also toggle\n\t\t\t// the variable while scrolling\n\t\t\twindowScrollingActiveFlag: undefined,\n\n\t\t\t// Instead of always using translate3d for transforms, a mix of translate3d\n\t\t\t// and translate with a hardware acceleration class used to trigger acceleration\n\t\t\t// is used; this is to allow CSS inheritance to be used to allow dynamic\n\t\t\t// disabling of backing layers on older platforms.\n\t\t\thwAccelerationClass: 'ftscroller_hwaccelerated',\n\n\t\t\t// While use of requestAnimationFrame is highly recommended on platforms\n\t\t\t// which support it, it can result in the animation being a further half-frame\n\t\t\t// behind the input method, increasing perceived lag slightly.  To disable this,\n\t\t\t// set this property to false.\n\t\t\tenableRequestAnimationFrameSupport: true,\n\n\t\t\t// Set the maximum time (ms) that a fling can take to complete; if\n\t\t\t// this is not set, flings will complete instantly\n\t\t\tmaxFlingDuration: 1000,\n\n\t\t\t// Whether to disable any input methods; on some multi-input devices\n\t\t\t// custom behaviour may be desired for some scrollers.  Use with care!\n\t\t\tdisabledInputMethods: {\n\t\t\t\tmouse: false,\n\t\t\t\ttouch: false,\n\t\t\t\tscroll: false,\n\t\t\t\tpointer: false,\n\t\t\t\tfocus: false\n\t\t\t},\n\n\t\t\t// Define a scrolling class to be added to the scroller container\n\t\t\t// when scrolling is active.  Note that this can cause a relayout on\n\t\t\t// scroll start if defined, but allows custom styling in response to scrolls\n\t\t\tscrollingClassName: undefined,\n\n\t\t\t// Bezier curves defining the feel of the fling (momentum) deceleration,\n\t\t\t// the bounce decleration deceleration (as a fling exceeds the bounds),\n\t\t\t// and the bounce bezier (used for bouncing back).\n\t\t\tflingBezier: new CubicBezier(0.103, 0.389, 0.307, 0.966),\n\t\t\tbounceDecelerationBezier: new CubicBezier(0, 0.5, 0.5, 1),\n\t\t\tbounceBezier: new CubicBezier(0.7, 0, 0.9, 0.6)\n\t\t};\n\n\n\t\t/*                     Local variables                   */\n\n\t\t// Cache the DOM node and set up variables for other nodes\n\t\tvar _publicSelf;\n\t\tvar _self = this;\n\t\tvar _scrollableMasterNode = domNode;\n\t\tvar _containerNode;\n\t\tvar _contentParentNode;\n\t\tvar _scrollNodes = { x: null, y: null };\n\t\tvar _scrollbarNodes = { x: null, y: null };\n\n\t\t// Dimensions of the container element and the content element\n\t\tvar _metrics = {\n\t\t\tcontainer: { x: null, y: null },\n\t\t\tcontent: { x: null, y: null, rawX: null, rawY: null },\n\t\t\tscrollEnd: { x: null, y: null }\n\t\t};\n\n\t\t// Snapping details\n\t\tvar _snapGridSize = {\n\t\t\tx: false,\n\t\t\ty: false,\n\t\t\tuserX: false,\n\t\t\tuserY: false\n\t\t};\n\t\tvar _snapIndex = {\n\t\t\tx: 0,\n\t\t\ty: 0\n\t\t};\n\t\tvar _baseSegment = { x: 0, y: 0 };\n\t\tvar _activeSegment = { x: 0, y: 0 };\n\n\t\t// Track the identifier of any input being tracked\n\t\tvar _inputIdentifier = false;\n\t\tvar _inputIndex = 0;\n\t\tvar _inputCaptured = false;\n\n\t\t// Current scroll positions and tracking\n\t\tvar _isScrolling = false;\n\t\tvar _isDisplayingScroll = false;\n\t\tvar _isAnimating = false;\n\t\tvar _baseScrollPosition = { x: 0, y: 0 };\n\t\tvar _lastScrollPosition = { x: 0, y: 0 };\n\t\tvar _targetScrollPosition = { x: 0, y: 0 };\n\t\tvar _scrollAtExtremity = { x: null, y: null };\n\t\tvar _preventClick = false;\n\t\tvar _timeouts = [];\n\t\tvar _hasBeenScrolled = false;\n\n\t\t// Gesture details\n\t\tvar _baseScrollableAxes = {};\n\t\tvar _scrollableAxes = { x: true, y: true };\n\t\tvar _gestureStart = { x: 0, y: 0, t: 0 };\n\t\tvar _cumulativeScroll = { x: 0, y: 0 };\n\t\tvar _eventHistory = [];\n\n\t\t// Allow certain events to be debounced\n\t\tvar _domChangeDebouncer = false;\n\t\tvar _scrollWheelEndDebouncer = false;\n\n\t\t// Performance switches on browsers supporting requestAnimationFrame\n\t\tvar _animationFrameRequest = false;\n\t\tvar _reqAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || false;\n\t\tvar _cancelAnimationFrame = window.cancelAnimationFrame || window.cancelRequestAnimationFrame || window.mozCancelAnimationFrame || window.mozCancelRequestAnimationFrame || window.webkitCancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.msCancelAnimationFrame || window.msCancelRequestAnimationFrame || false;\n\n\t\t// Event listeners\n\t\tvar _eventListeners = {\n\t\t\t'scrollstart': [],\n\t\t\t'scroll': [],\n\t\t\t'scrollend': [],\n\t\t\t'segmentwillchange': [],\n\t\t\t'segmentdidchange': [],\n\t\t\t'reachedstart': [],\n\t\t\t'reachedend': [],\n\t\t\t'scrollinteractionend': []\n\t\t};\n\n\t\t// MutationObserver instance, when supported and if DOM change sniffing is enabled\n\t\tvar _mutationObserver;\n\n\n\t\t/* Parsing supplied options */\n\n\t\t// Override default instance options with global - or closure'd - options\n\t\tif (typeof FTScrollerOptions === 'object' && FTScrollerOptions) {\n\t\t\tfor (key in FTScrollerOptions) {\n\t\t\t\tif (FTScrollerOptions.hasOwnProperty(key) && _instanceOptions.hasOwnProperty(key)) {\n\t\t\t\t\t_instanceOptions[key] = FTScrollerOptions[key];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Override default and global options with supplied options\n\t\tif (options) {\n\t\t\tfor (key in options) {\n\t\t\t\tif (options.hasOwnProperty(key)) {\n\n\t\t\t\t\t// If a deprecated flag was passed in, warn, and convert to the new flag name\n\t\t\t\t\tif ('paginatedSnap' === key) {\n\t\t\t\t\t\tconsole.warn('FTScroller: \"paginatedSnap\" is deprecated; converting to \"singlePageScrolls\"');\n\t\t\t\t\t\t_instanceOptions.singlePageScrolls = options.paginatedSnap;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (_instanceOptions.hasOwnProperty(key)) {\n\t\t\t\t\t\t_instanceOptions[key] = options[key];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If snap grid size options were supplied, store them\n\t\t\tif (options.hasOwnProperty('snapSizeX') && !isNaN(options.snapSizeX)) {\n\t\t\t\t_snapGridSize.userX = _snapGridSize.x = options.snapSizeX;\n\t\t\t}\n\t\t\tif (options.hasOwnProperty('snapSizeY') && !isNaN(options.snapSizeY)) {\n\t\t\t\t_snapGridSize.userY = _snapGridSize.y = options.snapSizeY;\n\t\t\t}\n\n\t\t\t// If content width and height were defined, disable updateOnChanges for performance\n\t\t\tif (options.contentWidth && options.contentHeight) {\n\t\t\t\toptions.updateOnChanges = false;\n\t\t\t}\n\t\t}\n\n\t\t// Validate the scroll response parameter\n\t\t_instanceOptions.scrollResponseBoundary = Math.min(_instanceOptions.scrollBoundary, _instanceOptions.scrollResponseBoundary);\n\n\t\t// Update base scrollable axes\n\t\tif (_instanceOptions.scrollingX) {\n\t\t\t_baseScrollableAxes.x = true;\n\t\t}\n\t\tif (_instanceOptions.scrollingY) {\n\t\t\t_baseScrollableAxes.y = true;\n\t\t}\n\n\t\t// Only enable animation frame support if the instance options permit it\n\t\t_reqAnimationFrame = _instanceOptions.enableRequestAnimationFrameSupport && _reqAnimationFrame;\n\t\t_cancelAnimationFrame = _reqAnimationFrame && _cancelAnimationFrame;\n\n\n\t\t/*                    Scoped Functions                   */\n\n\t\t/**\n\t\t * Unbinds all event listeners to prevent circular references preventing items\n\t\t * from being deallocated, and clean up references to dom elements. Pass in\n\t\t * \"removeElements\" to also remove FTScroller DOM elements for special reuse cases.\n\t\t */\n\t\tdestroy = function destroy(removeElements) {\n\t\t\tvar i, l;\n\n\t\t\t_removeEventHandlers();\n\t\t\t_cancelAnimation();\n\t\t\tif (_domChangeDebouncer) {\n\t\t\t\twindow.clearTimeout(_domChangeDebouncer);\n\t\t\t\t_domChangeDebouncer = false;\n\t\t\t}\n\t\t\tfor (i = 0, l = _timeouts.length; i < l; i = i + 1) {\n\t\t\t\twindow.clearTimeout(_timeouts[i]);\n\t\t\t}\n\t\t\t_timeouts.length = 0;\n\n\t\t\t// Destroy DOM elements if required\n\t\t\tif (removeElements && _scrollableMasterNode) {\n\t\t\t\twhile (_contentParentNode.firstChild) {\n\t\t\t\t\t_scrollableMasterNode.appendChild(_contentParentNode.firstChild);\n\t\t\t\t}\n\t\t\t\t_scrollableMasterNode.removeChild(_containerNode);\n\t\t\t}\n\n\t\t\t_scrollableMasterNode = null;\n\t\t\t_containerNode = null;\n\t\t\t_contentParentNode = null;\n\t\t\t_scrollNodes.x = null;\n\t\t\t_scrollNodes.y = null;\n\t\t\t_scrollbarNodes.x = null;\n\t\t\t_scrollbarNodes.y = null;\n\t\t\tfor (i in _eventListeners) {\n\t\t\t\tif (_eventListeners.hasOwnProperty(i)) {\n\t\t\t\t\t_eventListeners[i].length = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If this is currently tracked as a scrolling instance, clear the flag\n\t\t\tif (_ftscrollerMoving && _ftscrollerMoving === _self) {\n\t\t\t\t_ftscrollerMoving = false;\n\t\t\t\tif (_instanceOptions.windowScrollingActiveFlag) {\n\t\t\t\t\twindow[_instanceOptions.windowScrollingActiveFlag] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Configures the snapping boundaries within the scrolling element if\n\t\t * snapping is active.  If this is never called, snapping defaults to\n\t\t * using the bounding box, eg page-at-a-time.\n\t\t */\n\t\tsetSnapSize = function setSnapSize(width, height) {\n\t\t\t_snapGridSize.userX = width;\n\t\t\t_snapGridSize.userY = height;\n\t\t\t_snapGridSize.x = width;\n\t\t\t_snapGridSize.y = height;\n\n\t\t\t// Ensure the content dimensions conform to the grid\n\t\t\t_metrics.content.x = Math.ceil(_metrics.content.rawX / width) * width;\n\t\t\t_metrics.content.y = Math.ceil(_metrics.content.rawY / height) * height;\n\t\t\t_metrics.scrollEnd.x = _metrics.container.x - _metrics.content.x;\n\t\t\t_metrics.scrollEnd.y = _metrics.container.y - _metrics.content.y;\n\t\t\t_updateScrollbarDimensions();\n\n\t\t\t// Snap to the new grid if necessary\n\t\t\t_snapScroll();\n\t\t\t_updateSegments(true);\n\t\t};\n\n\t\t/**\n\t\t * Scroll to a supplied position, including whether or not to animate the\n\t\t * scroll and how fast to perform the animation (pass in true to select a\n\t\t * dynamic duration).  The inputs will be constrained to bounds and snapped.\n\t\t * If false is supplied for a position, that axis will not be scrolled.\n\t\t */\n\t\tscrollTo = function scrollTo(left, top, animationDuration) {\n\t\t\tvar targetPosition, duration, positions, axis, maxDuration = 0, scrollPositionsToApply = {};\n\n\t\t\t// If a manual scroll is in progress, cancel it\n\t\t\t_endScroll(Date.now());\n\n\t\t\t// Move supplied coordinates into an object for iteration, also inverting the values into\n\t\t\t// our coordinate system\n\t\t\tpositions = {\n\t\t\t\tx: -left,\n\t\t\t\ty: -top\n\t\t\t};\n\n\t\t\tfor (axis in _baseScrollableAxes) {\n\t\t\t\tif (_baseScrollableAxes.hasOwnProperty(axis)) {\n\t\t\t\t\ttargetPosition = positions[axis];\n\t\t\t\t\tif (targetPosition === false) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Constrain to bounds\n\t\t\t\t\ttargetPosition = Math.min(0, Math.max(_metrics.scrollEnd[axis], targetPosition));\n\n\t\t\t\t\t// Snap if appropriate\n\t\t\t\t\tif (_instanceOptions.snapping && _snapGridSize[axis]) {\n\t\t\t\t\t\ttargetPosition = Math.round(targetPosition / _snapGridSize[axis]) * _snapGridSize[axis];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Get a duration\n\t\t\t\t\tduration = animationDuration || 0;\n\t\t\t\t\tif (duration === true) {\n\t\t\t\t\t\tduration = Math.sqrt(Math.abs(_baseScrollPosition[axis] - targetPosition)) * 20;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Trigger the position change\n\t\t\t\t\t_setAxisPosition(axis, targetPosition, duration);\n\t\t\t\t\tscrollPositionsToApply[axis] = targetPosition;\n\t\t\t\t\tmaxDuration = Math.max(maxDuration, duration);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If the scroll had resulted in a change in position, perform some additional actions:\n\t\t\tif (_baseScrollPosition.x !== positions.x || _baseScrollPosition.y !== positions.y) {\n\n\t\t\t\t// Mark a scroll as having ever occurred\n\t\t\t\t_hasBeenScrolled = true;\n\n\t\t\t\t// If an animation duration is present, fire a scroll start event and a\n\t\t\t\t// scroll event for any listeners to act on\n\t\t\t\t_fireEvent('scrollstart', _getPosition());\n\t\t\t\tconsole.log('firing scroll event from scrollTo');\n\t\t\t\t_fireEvent('scroll', _getPosition());\n\t\t\t}\n\n\t\t\tif (maxDuration) {\n\t\t\t\t_timeouts.push(setTimeout(function () {\n\t\t\t\t\tvar anAxis;\n\t\t\t\t\tfor (anAxis in scrollPositionsToApply) {\n\t\t\t\t\t\tif (scrollPositionsToApply.hasOwnProperty(anAxis)) {\n\t\t\t\t\t\t\t_lastScrollPosition[anAxis] = scrollPositionsToApply[anAxis];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t_finalizeScroll();\n\t\t\t\t}, maxDuration));\n\t\t\t} else {\n\t\t\t\t_finalizeScroll();\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Alter the current scroll position, including whether or not to animate\n\t\t * the scroll and how fast to perform the animation (pass in true to\n\t\t * select a dynamic duration).  The inputs will be checked against the\n\t\t * current position.\n\t\t */\n\t\tscrollBy = function scrollBy(horizontal, vertical, animationDuration) {\n\n\t\t\t// Wrap the scrollTo function for simplicity\n\t\t\tscrollTo(parseFloat(horizontal) - _baseScrollPosition.x, parseFloat(vertical) - _baseScrollPosition.y, animationDuration);\n\t\t};\n\n\t\t/**\n\t\t * Provide a public method to detect changes in dimensions for either the content or the\n\t\t * container.\n\t\t */\n\t\tupdateDimensions = function updateDimensions(contentWidth, contentHeight, ignoreSnapScroll) {\n\t\t\toptions.contentWidth = contentWidth || options.contentWidth;\n\t\t\toptions.contentHeight = contentHeight || options.contentHeight;\n\n\t\t\t// Currently just wrap the private API\n\t\t\t_updateDimensions(!!ignoreSnapScroll);\n\t\t};\n\n\t\t/**\n\t\t * Add an event handler for a supported event.  Current events include:\n\t\t * scroll - fired whenever the scroll position changes\n\t\t * scrollstart - fired when a scroll movement starts\n\t\t * scrollend - fired when a scroll movement ends\n\t\t * segmentwillchange - fired whenever the segment changes, including during scrolling\n\t\t * segmentdidchange - fired when a segment has conclusively changed, after scrolling.\n\t\t */\n\t\taddEventListener = function addEventListener(eventname, eventlistener) {\n\n\t\t\t// Ensure this is a valid event\n\t\t\tif (!_eventListeners.hasOwnProperty(eventname)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Add the listener\n\t\t\t_eventListeners[eventname].push(eventlistener);\n\t\t\treturn true;\n\t\t};\n\n\t\t/**\n\t\t * Remove an event handler for a supported event.  The listener must be exactly the same as\n\t\t * an added listener to be removed.\n\t\t */\n\t\tremoveEventListener = function removeEventListener(eventname, eventlistener) {\n\t\t\tvar i;\n\n\t\t\t// Ensure this is a valid event\n\t\t\tif (!_eventListeners.hasOwnProperty(eventname)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tfor (i = _eventListeners[eventname].length; i >= 0; i = i - 1) {\n\t\t\t\tif (_eventListeners[eventname][i] === eventlistener) {\n\t\t\t\t\t_eventListeners[eventname].splice(i, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\n\t\t/**\n\t\t * Set the input methods to disable. No inputs methods are disabled by default.\n\t\t * (object, default { mouse: false, touch: false, scroll: false, pointer: false, focus: false })\n\t\t */\n\t\tsetDisabledInputMethods = function setDisabledInputMethods(disabledInputMethods) {\n\t\t\tvar i, changed;\n\n\t\t\tfor (i in _instanceOptions.disabledInputMethods) {\n\t\t\t\tdisabledInputMethods[i] = !!disabledInputMethods[i];\n\n\t\t\t\tif (_instanceOptions.disabledInputMethods[i] !== disabledInputMethods[i]) changed = true;\n\t\t\t\t_instanceOptions.disabledInputMethods[i] = disabledInputMethods[i];\n\t\t\t}\n\n\t\t\tif (changed) {\n\t\t\t\t_resetEventHandlers();\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Start a scroll tracking input - this could be mouse, webkit-style touch,\n\t\t * or ms-style pointer events.\n\t\t */\n\t\t_startScroll = function _startScroll(inputX, inputY, inputTime, rawEvent) {\n\t\t\tvar triggerScrollInterrupt = _isAnimating;\n\n\t\t\t// Opera fix\n\t\t\tif (inputTime <= 0) {\n\t\t\t\tinputTime = Date.now();\n\t\t\t}\n\n\t\t\t// If a window scrolling flag is set, and evaluates to true, don't start checking touches\n\t\t\tif (_instanceOptions.windowScrollingActiveFlag && window[_instanceOptions.windowScrollingActiveFlag]) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// If an animation is in progress, stop the scroll.\n\t\t\tif (triggerScrollInterrupt) {\n\t\t\t\t_interruptScroll();\n\t\t\t} else {\n\n\t\t\t\t// Allow clicks again, but only if a scroll was not interrupted\n\t\t\t\t_preventClick = false;\n\t\t\t}\n\n\t\t\t// Store the initial event coordinates\n\t\t\t_gestureStart.x = inputX;\n\t\t\t_gestureStart.y = inputY;\n\t\t\t_gestureStart.t = inputTime;\n\t\t\t_targetScrollPosition.x = _lastScrollPosition.x;\n\t\t\t_targetScrollPosition.y = _lastScrollPosition.y;\n\n\t\t\t// Clear event history and add the start touch\n\t\t\t_eventHistory.length = 0;\n\t\t\t_eventHistory.push({ x: inputX, y: inputY, t: inputTime });\n\n\t\t\tif (triggerScrollInterrupt) {\n\t\t\t\t_updateScroll(inputX, inputY, inputTime, rawEvent, triggerScrollInterrupt);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t};\n\n\t\t/**\n\t\t * Continue a scroll as a result of an updated position\n\t\t */\n\t\t_updateScroll = function _updateScroll(inputX, inputY, inputTime, rawEvent, scrollInterrupt) {\n\t\t\tvar axis, otherScrollerActive, distancesBeyondBounds;\n\t\t\tvar initialScroll = false;\n\t\t\tvar gesture = {\n\t\t\t\tx: inputX - _gestureStart.x,\n\t\t\t\ty: inputY - _gestureStart.y\n\t\t\t};\n\n\t\t\t// Opera fix\n\t\t\tif (inputTime <= 0) {\n\t\t\t\tinputTime = Date.now();\n\t\t\t}\n\n\t\t\t// Update base target positions\n\t\t\t_targetScrollPosition.x = _baseScrollPosition.x + gesture.x;\n\t\t\t_targetScrollPosition.y = _baseScrollPosition.y + gesture.y;\n\n\t\t\t// If scrolling has not yet locked to this scroller, check whether to stop scrolling\n\t\t\tif (!_isScrolling) {\n\n\t\t\t\t// Check the internal flag to determine if another FTScroller is scrolling\n\t\t\t\tif (_ftscrollerMoving && _ftscrollerMoving !== _self) {\n\t\t\t\t\totherScrollerActive = true;\n\t\t\t\t}\n\n\t\t\t\t// Otherwise, check the window scrolling flag to see if anything else has claimed scrolling\n\t\t\t\telse if (_instanceOptions.windowScrollingActiveFlag && window[_instanceOptions.windowScrollingActiveFlag]) {\n\t\t\t\t\totherScrollerActive = true;\n\t\t\t\t}\n\n\t\t\t\t// If another scroller was active, clean up and stop processing.\n\t\t\t\tif (otherScrollerActive) {\n\t\t\t\t\t_releaseInputCapture();\n\t\t\t\t\t_inputIdentifier = false;\n\t\t\t\t\tif (_isDisplayingScroll) {\n\t\t\t\t\t\t_cancelAnimation();\n\t\t\t\t\t\tif (!_snapScroll(true)) {\n\t\t\t\t\t\t\t_finalizeScroll(true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If not yet displaying a scroll, determine whether that triggering boundary\n\t\t\t// has been exceeded\n\t\t\tif (!_isDisplayingScroll) {\n\n\t\t\t\t// Determine scroll distance beyond bounds\n\t\t\t\tdistancesBeyondBounds = _distancesBeyondBounds(_targetScrollPosition);\n\n\t\t\t\t// Determine whether to prevent the default scroll event - if the scroll could still\n\t\t\t\t// be triggered, prevent the default to avoid problems (particularly on PlayBook)\n\t\t\t\tif (_instanceOptions.bouncing || scrollInterrupt || (_scrollableAxes.x && gesture.x && distancesBeyondBounds.x < 0) || (_scrollableAxes.y && gesture.y && distancesBeyondBounds.y < 0)) {\n\t\t\t\t\trawEvent.preventDefault();\n\t\t\t\t}\n\n\t\t\t\t// Check scrolled distance against the boundary limit to see if scrolling can be triggered.\n\t\t\t\t// If the scroll has been interrupted, trigger at once\n\t\t\t\tif (!scrollInterrupt && (!_scrollableAxes.x || Math.abs(gesture.x) < _instanceOptions.scrollResponseBoundary) && (!_scrollableAxes.y || Math.abs(gesture.y) < _instanceOptions.scrollResponseBoundary)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// If bouncing is disabled, and already at an edge and scrolling beyond the edge, ignore the scroll for\n\t\t\t\t// now - this allows other scrollers to claim if appropriate, allowing nicer nested scrolls.\n\t\t\t\tif (!_instanceOptions.bouncing && !scrollInterrupt && (!_scrollableAxes.x || !gesture.x || distancesBeyondBounds.x > 0) && (!_scrollableAxes.y || !gesture.y || distancesBeyondBounds.y > 0)) {\n\n\t\t\t\t\t// Prevent the original click now that scrolling would be triggered\n\t\t\t\t\t_preventClick = true;\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Trigger the start of visual scrolling\n\t\t\t\t_startAnimation();\n\t\t\t\t_isDisplayingScroll = true;\n\t\t\t\t_hasBeenScrolled = true;\n\t\t\t\t_isAnimating = true;\n\t\t\t\tinitialScroll = true;\n\t\t\t} else {\n\n\t\t\t\t// Prevent the event default.  It is safe to call this in IE10 because the event is never\n\t\t\t\t// a window.event, always a \"true\" event.\n\t\t\t\trawEvent.preventDefault();\n\t\t\t}\n\n\t\t\t// If not yet locked to a scroll, determine whether to do so\n\t\t\tif (!_isScrolling) {\n\n\t\t\t\t// If the gesture distance has exceeded the scroll lock distance, or snapping is active\n\t\t\t\t// and the scroll has been interrupted, enter exclusive scrolling.\n\t\t\t\tif ((scrollInterrupt && _instanceOptions.snapping) || (_scrollableAxes.x && Math.abs(gesture.x) >= _instanceOptions.scrollBoundary) || (_scrollableAxes.y && Math.abs(gesture.y) >= _instanceOptions.scrollBoundary)) {\n\n\t\t\t\t\t_isScrolling = true;\n\t\t\t\t\t_preventClick = true;\n\t\t\t\t\t_ftscrollerMoving = _self;\n\t\t\t\t\tif (_instanceOptions.windowScrollingActiveFlag) {\n\t\t\t\t\t\twindow[_instanceOptions.windowScrollingActiveFlag] = _self;\n\t\t\t\t\t}\n\t\t\t\t\t_fireEvent('scrollstart', _getPosition());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Capture pointer if necessary\n\t\t\tif (_isScrolling) {\n\t\t\t\t_captureInput();\n\t\t\t}\n\n\t\t\t// Cancel text selections while dragging a cursor\n\t\t\tif (_canClearSelection) {\n\t\t\t\twindow.getSelection().removeAllRanges();\n\t\t\t}\n\n\t\t\t// Ensure the target scroll position is affected by bounds and render if needed\n\t\t\t_constrainAndRenderTargetScrollPosition();\n\n\t\t\t// To aid render/draw coalescing, perform other one-off actions here\n\t\t\tif (initialScroll) {\n\t\t\t\tif (gesture.x > 0) {\n\t\t\t\t\t_baseScrollPosition.x -= _instanceOptions.scrollResponseBoundary;\n\t\t\t\t} else if(gesture.x < 0) {\n\t\t\t\t\t_baseScrollPosition.x += _instanceOptions.scrollResponseBoundary;\n\t\t\t\t}\n\n\t\t\t\tif (gesture.y > 0) {\n\t\t\t\t\t_baseScrollPosition.y -= _instanceOptions.scrollResponseBoundary;\n\t\t\t\t} else if(gesture.y < 0) {\n\t\t\t\t\t_baseScrollPosition.y += _instanceOptions.scrollResponseBoundary;\n\t\t\t\t}\n\n\t\t\t\t_targetScrollPosition.x = _baseScrollPosition.x + gesture.x;\n\t\t\t\t_targetScrollPosition.y = _baseScrollPosition.y + gesture.y;\n\n\t\t\t\tif (_instanceOptions.scrollingClassName) {\n\t\t\t\t\t_containerNode.className += ' ' + _instanceOptions.scrollingClassName;\n\t\t\t\t}\n\t\t\t\tif (_instanceOptions.scrollbars) {\n\t\t\t\t\tfor (axis in _scrollableAxes) {\n\t\t\t\t\t\tif (_scrollableAxes.hasOwnProperty(axis)) {\n\t\t\t\t\t\t\t_scrollbarNodes[axis].className += ' active';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add an event to the event history, keeping it around twenty events long\n\t\t\t_eventHistory.push({ x: inputX, y: inputY, t: inputTime });\n\t\t\tif (_eventHistory.length > 30) {\n\t\t\t\t_eventHistory.splice(0, 15);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Complete a scroll with a final event time if available (it may\n\t\t * not be, depending on the input type); this may continue the scroll\n\t\t * with a fling and/or bounceback depending on options.\n\t\t */\n\t\t_endScroll = function _endScroll(inputTime, rawEvent) {\n\t\t\t_releaseInputCapture();\n\t\t\t_inputIdentifier = false;\n\t\t\t_cancelAnimation();\n\n\t\t\t_fireEvent('scrollinteractionend', {});\n\n\t\t\tif (!_isScrolling) {\n\t\t\t\tif (!_snapScroll(true) && _isDisplayingScroll) {\n\t\t\t\t\t_finalizeScroll(true);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Modify the last movement event to include the end event time\n\t\t\t_eventHistory[_eventHistory.length - 1].t = inputTime;\n\n\t\t\t// Update flags\n\t\t\t_isScrolling = false;\n\t\t\t_isDisplayingScroll = false;\n\t\t\t_ftscrollerMoving = false;\n\t\t\tif (_instanceOptions.windowScrollingActiveFlag) {\n\t\t\t\twindow[_instanceOptions.windowScrollingActiveFlag] = false;\n\t\t\t}\n\n\t\t\t// Stop the event default.  It is safe to call this in IE10 because\n\t\t\t// the event is never a window.event, always a \"true\" event.\n\t\t\tif (rawEvent) {\n\t\t\t\trawEvent.preventDefault();\n\t\t\t}\n\n\t\t\t// Trigger a fling or bounceback if necessary\n\t\t\tif (!_flingScroll() && !_snapScroll()) {\n\t\t\t\t_finalizeScroll();\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Remove the scrolling class, cleaning up display.\n\t\t */\n\t\t_finalizeScroll = function _finalizeScroll(scrollCancelled) {\n\t\t\tvar i, l, axis, scrollEvent, scrollRegex;\n\n\t\t\t_isAnimating = false;\n\t\t\t_isDisplayingScroll = false;\n\n\t\t\t// Remove scrolling class if set\n\t\t\tif (_instanceOptions.scrollingClassName) {\n\t\t\t\tscrollRegex = new RegExp('(?:^|\\\\s)' + _instanceOptions.scrollingClassName + '(?!\\\\S)', 'g');\n\t\t\t\t_containerNode.className = _containerNode.className.replace(scrollRegex, '');\n\t\t\t}\n\t\t\tif (_instanceOptions.scrollbars) {\n\t\t\t\tfor (axis in _scrollableAxes) {\n\t\t\t\t\tif (_scrollableAxes.hasOwnProperty(axis)) {\n\t\t\t\t\t\t_scrollbarNodes[axis].className = _scrollbarNodes[axis].className.replace(/ ?active/g, '');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Store final position if scrolling occurred\n\t\t\t_baseScrollPosition.x = _lastScrollPosition.x;\n\t\t\t_baseScrollPosition.y = _lastScrollPosition.y;\n\n\t\t\tscrollEvent = _getPosition();\n\n\t\t\tif (!scrollCancelled) {\n\t\t\t\tconsole.log('firing scroll event from _finalizeScroll');\n\t\t\t\t_fireEvent('scroll', scrollEvent);\n\t\t\t\t_updateSegments(true);\n\t\t\t}\n\n\t\t\t// Always fire the scroll end event, including an argument indicating whether\n\t\t\t// the scroll was cancelled\n\t\t\tscrollEvent.cancelled = scrollCancelled;\n\t\t\t_fireEvent('scrollend', scrollEvent);\n\n\t\t\t// Restore transitions\n\t\t\tfor (axis in _scrollableAxes) {\n\t\t\t\tif (_scrollableAxes.hasOwnProperty(axis)) {\n\t\t\t\t\t_scrollNodes[axis].style[_transitionProperty] = '';\n\t\t\t\t\tif (_instanceOptions.scrollbars) {\n\t\t\t\t\t\t_scrollbarNodes[axis].style[_transitionProperty] = '';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Clear any remaining timeouts\n\t\t\tfor (i = 0, l = _timeouts.length; i < l; i = i + 1) {\n\t\t\t\twindow.clearTimeout(_timeouts[i]);\n\t\t\t}\n\t\t\t_timeouts.length = 0;\n\t\t};\n\n\t\t/**\n\t\t * Interrupt a current scroll, allowing a start scroll during animation to trigger a new scroll\n\t\t */\n\t\t_interruptScroll = function _interruptScroll() {\n\t\t\tvar axis, i, l;\n\n\t\t\t_isAnimating = false;\n\n\t\t\t// Update the stored base position\n\t\t\t_updateElementPosition();\n\n\t\t\t// Ensure the parsed positions are set, also clearing transitions\n\t\t\tfor (axis in _scrollableAxes) {\n\t\t\t\tif (_scrollableAxes.hasOwnProperty(axis)) {\n\t\t\t\t\t_setAxisPosition(axis, _baseScrollPosition[axis], 16, _instanceOptions.bounceDecelerationBezier);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Update segment tracking if snapping is active\n\t\t\t_updateSegments(false);\n\n\t\t\t// Clear any remaining timeouts\n\t\t\tfor (i = 0, l = _timeouts.length; i < l; i = i + 1) {\n\t\t\t\twindow.clearTimeout(_timeouts[i]);\n\t\t\t}\n\t\t\t_timeouts.length = 0;\n\t\t};\n\n\t\t/**\n\t\t * Determine whether a scroll fling or bounceback is required, and set up the styles and\n\t\t * timeouts required.\n\t\t */\n\t\t_flingScroll = function _flingScroll() {\n\t\t\tvar i, axis, movementTime, movementSpeed, lastPosition, comparisonPosition, flingDuration, flingDistance, flingPosition, bounceDelay, bounceDistance, bounceDuration, bounceTarget, boundsBounce, modifiedDistance, flingBezier, timeProportion, boundsCrossDelay, flingStartSegment, beyondBoundsFlingDistance, baseFlingComponent;\n\t\t\tvar maxAnimationTime = 0;\n\t\t\tvar moveRequired = false;\n\t\t\tvar scrollPositionsToApply = {};\n\n\t\t\t// If we only have the start event available, or flinging is disabled,\n\t\t\t// or the scroll was triggered by a scrollwheel, no action required.\n\t\t\tif (_eventHistory.length === 1 || !_instanceOptions.flinging || _inputIdentifier === 'scrollwheel') {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tfor (axis in _scrollableAxes) {\n\t\t\t\tif (_scrollableAxes.hasOwnProperty(axis)) {\n\t\t\t\t\tbounceDuration = 350;\n\t\t\t\t\tbounceDistance = 0;\n\t\t\t\t\tboundsBounce = false;\n\t\t\t\t\tbounceTarget = false;\n\t\t\t\t\tboundsCrossDelay = undefined;\n\n\t\t\t\t\t// Re-set a default bezier curve for the animation for potential modification\n\t\t\t\t\tflingBezier = _instanceOptions.flingBezier;\n\n\t\t\t\t\t// Get the last movement speed, in pixels per millisecond.  To do this, look at the events\n\t\t\t\t\t// in the last 100ms and average out the speed, using a minimum number of two points.\n\t\t\t\t\tlastPosition = _eventHistory[_eventHistory.length - 1];\n\t\t\t\t\tcomparisonPosition = _eventHistory[_eventHistory.length - 2];\n\t\t\t\t\tfor (i = _eventHistory.length - 3; i >= 0; i = i - 1) {\n\t\t\t\t\t\tif (lastPosition.t - _eventHistory[i].t > 100) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcomparisonPosition = _eventHistory[i];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Get the last movement time.  If this is zero - as can happen with\n\t\t\t\t\t// some scrollwheel events on some platforms - increase it to 16ms as\n\t\t\t\t\t// if the movement occurred over a single frame at 60fps.\n\t\t\t\t\tmovementTime = lastPosition.t - comparisonPosition.t;\n\t\t\t\t\tif (!movementTime) {\n\t\t\t\t\t\tmovementTime = 16;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Derive the movement speed\n\t\t\t\t\tmovementSpeed = (lastPosition[axis] - comparisonPosition[axis]) / movementTime;\n\n\t\t\t\t\t// If there is little speed, no further action required except for a bounceback, below.\n\t\t\t\t\tif (Math.abs(movementSpeed) < _kMinimumSpeed) {\n\t\t\t\t\t\tflingDuration = 0;\n\t\t\t\t\t\tflingDistance = 0;\n\n\t\t\t\t\t} else {\n\n\n\t\t\t\t\t\t/* Calculate the fling duration.  As per TouchScroll, the speed at any particular\n\t\t\t\t\t\tpoint in time can be calculated as:\n\t\t\t\t\t\t\t{ speed } = { initial speed } * ({ friction } to the power of { duration })\n\t\t\t\t\t\t...assuming all values are in equal pixels/millisecond measurements.  As we know the\n\t\t\t\t\t\tminimum target speed, this can be altered to:\n\t\t\t\t\t\t\t{ duration } = log( { speed } / { initial speed } ) / log( { friction } )\n\t\t\t\t\t\t*/\n\n\t\t\t\t\t\tflingDuration = Math.log(_kMinimumSpeed / Math.abs(movementSpeed)) / Math.log(_kFriction);\n\n\n\t\t\t\t\t\t/* Calculate the fling distance (before any bouncing or snapping).  As per\n\t\t\t\t\t\tTouchScroll, the total distance covered can be approximated by summing\n\t\t\t\t\t\tthe distance per millisecond, per millisecond of duration - a divergent series,\n\t\t\t\t\t\tand so rather tricky to model otherwise!\n\t\t\t\t\t\tSo using values in pixels per millisecond:\n\t\t\t\t\t\t\t{ distance } = { initial speed } * (1 - ({ friction } to the power\n\t\t\t\t\t\t\t\tof { duration + 1 }) / (1 - { friction })\n\t\t\t\t\t\t*/\n\n\t\t\t\t\t\tflingDistance = movementSpeed * (1 - Math.pow(_kFriction, flingDuration + 1)) / (1 - _kFriction);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Determine a target fling position\n\t\t\t\t\tflingPosition = Math.floor(_lastScrollPosition[axis] + flingDistance);\n\n\t\t\t\t\t// If bouncing is disabled, and the last scroll position and fling position are both at a bound,\n\t\t\t\t\t// reset the fling position to the bound\n\t\t\t\t\tif (!_instanceOptions.bouncing) {\n\t\t\t\t\t\tif (_lastScrollPosition[axis] === 0 && flingPosition > 0) {\n\t\t\t\t\t\t\tflingPosition = 0;\n\t\t\t\t\t\t} else if (_lastScrollPosition[axis] === _metrics.scrollEnd[axis] && flingPosition < _lastScrollPosition[axis]) {\n\t\t\t\t\t\t\tflingPosition = _lastScrollPosition[axis];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// In single-page-scroll mode, determine the page to snap to - maximum one page\n\t\t\t\t\t// in either direction from the *start* page.\n\t\t\t\t\tif (_instanceOptions.singlePageScrolls && _instanceOptions.snapping) {\n\t\t\t\t\t\tflingStartSegment = -_lastScrollPosition[axis] / _snapGridSize[axis];\n\t\t\t\t\t\tif (_baseSegment[axis] < flingStartSegment) {\n\t\t\t\t\t\t\tflingStartSegment = Math.floor(flingStartSegment);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tflingStartSegment = Math.ceil(flingStartSegment);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If the target position will end up beyond another page, target that page edge\n\t\t\t\t\t\tif (flingPosition > -(_baseSegment[axis] - 1) * _snapGridSize[axis]) {\n\t\t\t\t\t\t\tbounceDistance = flingPosition + (_baseSegment[axis] - 1) * _snapGridSize[axis];\n\t\t\t\t\t\t} else if (flingPosition < -(_baseSegment[axis] + 1) * _snapGridSize[axis]) {\n\t\t\t\t\t\t\tbounceDistance = flingPosition + (_baseSegment[axis] + 1) * _snapGridSize[axis];\n\n\t\t\t\t\t\t// Otherwise, if the movement speed was above the minimum velocity, continue\n\t\t\t\t\t\t// in the move direction.\n\t\t\t\t\t\t} else if (Math.abs(movementSpeed) > _kMinimumSpeed) {\n\n\t\t\t\t\t\t\t// Determine the target segment\n\t\t\t\t\t\t\tif (movementSpeed < 0) {\n\t\t\t\t\t\t\t\tflingPosition = Math.floor(_lastScrollPosition[axis] / _snapGridSize[axis]) * _snapGridSize[axis];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tflingPosition = Math.ceil(_lastScrollPosition[axis] / _snapGridSize[axis]) * _snapGridSize[axis];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tflingDuration = Math.min(_instanceOptions.maxFlingDuration, flingDuration * (flingPosition - _lastScrollPosition[axis]) / flingDistance);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// In non-paginated snapping mode, snap to the nearest grid location to the target\n\t\t\t\t\t} else if (_instanceOptions.snapping) {\n\t\t\t\t\t\tbounceDistance = flingPosition - (Math.round(flingPosition / _snapGridSize[axis]) * _snapGridSize[axis]);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Deal with cases where the target is beyond the bounds\n\t\t\t\t\tif (flingPosition - bounceDistance > 0) {\n\t\t\t\t\t\tbounceDistance = flingPosition;\n\t\t\t\t\t\tboundsBounce = true;\n\t\t\t\t\t} else if (flingPosition - bounceDistance < _metrics.scrollEnd[axis]) {\n\t\t\t\t\t\tbounceDistance = flingPosition - _metrics.scrollEnd[axis];\n\t\t\t\t\t\tboundsBounce = true;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Amend the positions and bezier curve if necessary\n\t\t\t\t\tif (bounceDistance) {\n\n\t\t\t\t\t\t// If the fling moves the scroller beyond the normal scroll bounds, and\n\t\t\t\t\t\t// the bounce is snapping the scroll back after the fling:\n\t\t\t\t\t\tif (boundsBounce && _instanceOptions.bouncing && flingDistance) {\n\t\t\t\t\t\t\tflingDistance = Math.floor(flingDistance);\n\n\t\t\t\t\t\t\tif (flingPosition > 0) {\n\t\t\t\t\t\t\t\tbeyondBoundsFlingDistance = flingPosition - Math.max(0, _lastScrollPosition[axis]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbeyondBoundsFlingDistance = flingPosition - Math.min(_metrics.scrollEnd[axis], _lastScrollPosition[axis]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbaseFlingComponent = flingDistance - beyondBoundsFlingDistance;\n\n\t\t\t\t\t\t\t// Determine the time proportion the original bound is along the fling curve\n\t\t\t\t\t\t\tif (!flingDistance || !flingDuration) {\n\t\t\t\t\t\t\t\ttimeProportion = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimeProportion = flingBezier._getCoordinateForT(flingBezier.getTForY((flingDistance - beyondBoundsFlingDistance) / flingDistance, 1 / flingDuration), flingBezier._p1.x, flingBezier._p2.x);\n\t\t\t\t\t\t\t\tboundsCrossDelay = timeProportion * flingDuration;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Eighth the distance beyonds the bounds\n\t\t\t\t\t\t\tmodifiedDistance = Math.ceil(beyondBoundsFlingDistance / 8);\n\n\t\t\t\t\t\t\t// Further limit the bounce to half the container dimensions\n\t\t\t\t\t\t\tif (Math.abs(modifiedDistance) > _metrics.container[axis] / 2) {\n\t\t\t\t\t\t\t\tif (modifiedDistance < 0) {\n\t\t\t\t\t\t\t\t\tmodifiedDistance = -Math.floor(_metrics.container[axis] / 2);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tmodifiedDistance = Math.floor(_metrics.container[axis] / 2);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (flingPosition > 0) {\n\t\t\t\t\t\t\t\tbounceTarget = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbounceTarget = _metrics.scrollEnd[axis];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// If the entire fling is a bounce, modify appropriately\n\t\t\t\t\t\t\tif (timeProportion === 0) {\n\t\t\t\t\t\t\t\tflingDuration = flingDuration / 6;\n\t\t\t\t\t\t\t\tflingPosition = _lastScrollPosition[axis] + baseFlingComponent + modifiedDistance;\n\t\t\t\t\t\t\t\tbounceDelay = flingDuration;\n\n\t\t\t\t\t\t\t// Otherwise, take a new curve and add it to the timeout stack for the bounce\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// The new bounce delay is the pre-boundary fling duration, plus a\n\t\t\t\t\t\t\t\t// sixth of the post-boundary fling.\n\t\t\t\t\t\t\t\tbounceDelay = (timeProportion + ((1 - timeProportion) / 6)) * flingDuration;\n\n\t\t\t\t\t\t\t\t_scheduleAxisPosition(axis, (_lastScrollPosition[axis] + baseFlingComponent + modifiedDistance), ((1 - timeProportion) * flingDuration / 6), _instanceOptions.bounceDecelerationBezier, boundsCrossDelay);\n\n\t\t\t\t\t\t\t\t// Modify the fling to match, clipping to prevent over-fling\n\t\t\t\t\t\t\t\tflingBezier = flingBezier.divideAtX(bounceDelay / flingDuration, 1 / flingDuration)[0];\n\t\t\t\t\t\t\t\tflingDuration = bounceDelay;\n\t\t\t\t\t\t\t\tflingPosition = (_lastScrollPosition[axis] + baseFlingComponent + modifiedDistance);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If the fling requires snapping to a snap location, and the bounce needs to\n\t\t\t\t\t\t// reverse the fling direction after the fling completes:\n\t\t\t\t\t\t} else if ((flingDistance < 0 && bounceDistance < flingDistance) || (flingDistance > 0 && bounceDistance > flingDistance)) {\n\n\t\t\t\t\t\t\t// Shorten the original fling duration to reflect the bounce\n\t\t\t\t\t\t\tflingPosition = flingPosition - Math.floor(flingDistance / 2);\n\t\t\t\t\t\t\tbounceDistance = bounceDistance - Math.floor(flingDistance / 2);\n\t\t\t\t\t\t\tbounceDuration = Math.sqrt(Math.abs(bounceDistance)) * 50;\n\t\t\t\t\t\t\tbounceTarget = flingPosition - bounceDistance;\n\t\t\t\t\t\t\tflingDuration = 350;\n\t\t\t\t\t\t\tbounceDelay = flingDuration * 0.97;\n\n\t\t\t\t\t\t// If the bounce is truncating the fling, or continuing the fling on in the same\n\t\t\t\t\t\t// direction to hit the next boundary:\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tflingPosition = flingPosition - bounceDistance;\n\n\t\t\t\t\t\t\t// If there was no fling distance originally, use the bounce details\n\t\t\t\t\t\t\tif (!flingDistance) {\n\t\t\t\t\t\t\t\tflingDuration = bounceDuration;\n\n\t\t\t\t\t\t\t// If truncating the fling at a snapping edge:\n\t\t\t\t\t\t\t} else if ((flingDistance < 0 && bounceDistance < 0) || (flingDistance > 0 && bounceDistance > 0)) {\n\t\t\t\t\t\t\t\ttimeProportion = flingBezier._getCoordinateForT(flingBezier.getTForY((Math.abs(flingDistance) - Math.abs(bounceDistance)) / Math.abs(flingDistance), 1 / flingDuration), flingBezier._p1.x, flingBezier._p2.x);\n\t\t\t\t\t\t\t\tflingBezier = flingBezier.divideAtX(timeProportion, 1 / flingDuration)[0];\n\t\t\t\t\t\t\t\tflingDuration = Math.round(flingDuration * timeProportion);\n\n\t\t\t\t\t\t\t// If extending the fling to reach the next snapping boundary, no further\n\t\t\t\t\t\t\t// action is required.\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbounceDistance = 0;\n\t\t\t\t\t\t\tbounceDuration = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// If no fling or bounce is required, continue\n\t\t\t\t\tif (flingPosition === _lastScrollPosition[axis] && !bounceDistance) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tmoveRequired = true;\n\n\t\t\t\t\t// Perform the fling\n\t\t\t\t\t_setAxisPosition(axis, flingPosition, flingDuration, flingBezier, boundsCrossDelay);\n\n\t\t\t\t\t// Schedule a bounce if appropriate\n\t\t\t\t\tif (bounceDistance && bounceDuration) {\n\t\t\t\t\t\t_scheduleAxisPosition(axis, bounceTarget, bounceDuration, _instanceOptions.bounceBezier, bounceDelay);\n\t\t\t\t\t}\n\n\t\t\t\t\tmaxAnimationTime = Math.max(maxAnimationTime, bounceDistance ? (bounceDelay + bounceDuration) : flingDuration);\n\t\t\t\t\tscrollPositionsToApply[axis] = (bounceTarget === false) ? flingPosition : bounceTarget;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (moveRequired && maxAnimationTime) {\n\t\t\t\t_timeouts.push(setTimeout(function () {\n\t\t\t\t\tvar anAxis;\n\n\t\t\t\t\t// Update the stored scroll position ready for finalising\n\t\t\t\t\tfor (anAxis in scrollPositionsToApply) {\n\t\t\t\t\t\tif (scrollPositionsToApply.hasOwnProperty(anAxis)) {\n\t\t\t\t\t\t\t_lastScrollPosition[anAxis] = scrollPositionsToApply[anAxis];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t_finalizeScroll();\n\t\t\t\t}, maxAnimationTime));\n\t\t\t}\n\n\t\t\treturn moveRequired;\n\t\t};\n\n\t\t/**\n\t\t * Bounce back into bounds if necessary, or snap to a grid location.\n\t\t */\n\t\t_snapScroll = function _snapScroll(scrollCancelled) {\n\t\t\tvar axis;\n\t\t\tvar snapDuration = scrollCancelled ? 100 : 350;\n\t\t\tvar targetPosition = _lastScrollPosition;\n\n\t\t\t// Get the current position and see if a snap is required\n\t\t\tif (_instanceOptions.snapping) {\n\n\t\t\t\t// Store current snap index\n\t\t\t\t_snapIndex = _getSnapIndexForPosition(targetPosition);\n\t\t\t\ttargetPosition = _getSnapPositionForIndexes(_snapIndex, targetPosition);\n\t\t\t}\n\t\t\ttargetPosition = _limitToBounds(targetPosition);\n\n\t\t\tvar snapRequired = false;\n\t\t\tfor (axis in _baseScrollableAxes) {\n\t\t\t\tif (_baseScrollableAxes.hasOwnProperty(axis)) {\n\t\t\t\t\tif (targetPosition[axis] !== _lastScrollPosition[axis]) {\n\t\t\t\t\t\tsnapRequired = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!snapRequired) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Perform the snap\n\t\t\tfor (axis in _baseScrollableAxes) {\n\t\t\t\tif (_baseScrollableAxes.hasOwnProperty(axis)) {\n\t\t\t\t\t_setAxisPosition(axis, targetPosition[axis], snapDuration);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_timeouts.push(setTimeout(function () {\n\n\t\t\t\t// Update the stored scroll position ready for finalizing\n\t\t\t\t_lastScrollPosition = targetPosition;\n\n\t\t\t\t_finalizeScroll(scrollCancelled);\n\t\t\t}, snapDuration));\n\n\t\t\treturn true;\n\t\t};\n\n\t\t/**\n\t\t * Get an appropriate snap index for a supplied point.\n\t\t */\n\t\t_getSnapIndexForPosition = function _getSnapIndexForPosition(coordinates) {\n\t\t\tvar axis;\n\t\t\tvar indexes = {x: 0, y: 0};\n\t\t\tfor (axis in _scrollableAxes) {\n\t\t\t\tif (_scrollableAxes.hasOwnProperty(axis) && _snapGridSize[axis]) {\n\t\t\t\t\tindexes[axis] = Math.round(coordinates[axis] / _snapGridSize[axis]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn indexes;\n\t\t};\n\n\t\t/**\n\t\t * Get an appropriate snap point for a supplied index.\n\t\t */\n\t\t_getSnapPositionForIndexes = function _getSnapPositionForIndexes(indexes, currentCoordinates) {\n\t\t\tvar axis;\n\t\t\tvar coordinatesToReturn = {\n\t\t\t\tx: currentCoordinates.x,\n\t\t\t\ty: currentCoordinates.y\n\t\t\t};\n\t\t\tfor (axis in _scrollableAxes) {\n\t\t\t\tif (_scrollableAxes.hasOwnProperty(axis)) {\n\t\t\t\t\tcoordinatesToReturn[axis] = indexes[axis] * _snapGridSize[axis];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn coordinatesToReturn;\n\t\t};\n\n\t\t/**\n\t\t * Update the scroll position while scrolling is active, checking the position\n\t\t * within bounds and rubberbanding/constraining as appropriate; also triggers a\n\t\t * scroll position render if a requestAnimationFrame loop isn't active\n\t\t */\n\t\t_constrainAndRenderTargetScrollPosition = function _constrainAndRenderTargetScrollPosition() {\n\t\t\tvar axis, upperBound, lowerBound;\n\n\t\t\t// Update axes target positions if beyond bounds\n\t\t\tfor (axis in _scrollableAxes) {\n\t\t\t\tif (_scrollableAxes.hasOwnProperty(axis)) {\n\n\t\t\t\t\t// Set bounds to the left and right of the container\n\t\t\t\t\tupperBound = 0;\n\t\t\t\t\tlowerBound = _metrics.scrollEnd[axis];\n\n\t\t\t\t\tif (_instanceOptions.singlePageScrolls && _instanceOptions.snapping) {\n\n\t\t\t\t\t\t// For a single-page-scroll, set the bounds to the left and right of the\n\t\t\t\t\t\t// current segment\n\t\t\t\t\t\tupperBound = Math.min(upperBound, -(_baseSegment[axis] - 1) * _snapGridSize[axis]);\n\t\t\t\t\t\tlowerBound = Math.max(lowerBound, -(_baseSegment[axis] + 1) * _snapGridSize[axis]);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (_targetScrollPosition[axis] > upperBound) {\n\t\t\t\t\t\t_targetScrollPosition[axis] = upperBound + _modifyDistanceBeyondBounds(_targetScrollPosition[axis] - upperBound, axis);\n\t\t\t\t\t} else if (_targetScrollPosition[axis] < lowerBound) {\n\t\t\t\t\t\t_targetScrollPosition[axis] = lowerBound + _modifyDistanceBeyondBounds(_targetScrollPosition[axis] - lowerBound, axis);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Trigger a scroll position update for platforms not using requestAnimationFrames\n\t\t\tif (!_reqAnimationFrame) {\n\t\t\t\t_scheduleRender();\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Limit coordinates within the bounds of the scrollable viewport.\n\t\t */\n\t\t_limitToBounds = function _limitToBounds(coordinates) {\n\t\t\tvar axis;\n\t\t\tvar coordinatesToReturn = { x: coordinates.x, y: coordinates.y };\n\n\t\t\tfor (axis in _scrollableAxes) {\n\t\t\t\tif (_scrollableAxes.hasOwnProperty(axis)) {\n\n\t\t\t\t\t// If the coordinate is beyond the edges of the scroller, use the closest edge\n\t\t\t\t\tif (coordinates[axis] > 0) {\n\t\t\t\t\t\tcoordinatesToReturn[axis] = 0;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (coordinates[axis] < _metrics.scrollEnd[axis]) {\n\t\t\t\t\t\tcoordinatesToReturn[axis] = _metrics.scrollEnd[axis];\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn coordinatesToReturn;\n\t\t};\n\n\n\t\t/**\n\t\t * Sets up the DOM around the node to be scrolled.\n\t\t */\n\t\t_initializeDOM = function _initializeDOM() {\n\t\t\tvar offscreenFragment, offscreenNode, scrollYParent;\n\n\t\t\t// Check whether the DOM is already present and valid - if so, no further action required.\n\t\t\tif (_existingDOMValid()) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Otherwise, the DOM needs to be created inside the originally supplied node.  The node\n\t\t\t// has a container inserted inside it - which acts as an anchor element with constraints -\n\t\t\t// and then the scrollable layers as appropriate.\n\n\t\t\t// Create a new document fragment to temporarily hold the scrollable content\n\t\t\toffscreenFragment = _scrollableMasterNode.ownerDocument.createDocumentFragment();\n\t\t\toffscreenNode = document.createElement('DIV');\n\t\t\toffscreenFragment.appendChild(offscreenNode);\n\n\t\t\t// Drop in the wrapping HTML\n\t\t\toffscreenNode.innerHTML = FTScroller.prototype.getPrependedHTML(!_instanceOptions.scrollingX, !_instanceOptions.scrollingY, _instanceOptions.hwAccelerationClass) + FTScroller.prototype.getAppendedHTML(!_instanceOptions.scrollingX, !_instanceOptions.scrollingY, _instanceOptions.hwAccelerationClass, _instanceOptions.scrollbars);\n\n\t\t\t// Update references as appropriate\n\t\t\t_containerNode = offscreenNode.firstElementChild;\n\t\t\tscrollYParent = _containerNode;\n\t\t\tif (_instanceOptions.scrollingX) {\n\t\t\t\t_scrollNodes.x = _containerNode.firstElementChild;\n\t\t\t\tscrollYParent = _scrollNodes.x;\n\t\t\t\tif (_instanceOptions.scrollbars) {\n\t\t\t\t\t_scrollbarNodes.x = _containerNode.getElementsByClassName('ftscroller_scrollbarx')[0];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (_instanceOptions.scrollingY) {\n\t\t\t\t_scrollNodes.y = scrollYParent.firstElementChild;\n\t\t\t\tif (_instanceOptions.scrollbars) {\n\t\t\t\t\t_scrollbarNodes.y = _containerNode.getElementsByClassName('ftscroller_scrollbary')[0];\n\t\t\t\t}\n\t\t\t\t_contentParentNode = _scrollNodes.y;\n\t\t\t} else {\n\t\t\t\t_contentParentNode = _scrollNodes.x;\n\t\t\t}\n\n\t\t\t// Take the contents of the scrollable element, and copy them into the new container\n\t\t\twhile (_scrollableMasterNode.firstChild) {\n\t\t\t\t_contentParentNode.appendChild(_scrollableMasterNode.firstChild);\n\t\t\t}\n\n\t\t\t// Move the wrapped elements back into the document\n\t\t\t_scrollableMasterNode.appendChild(_containerNode);\n\t\t};\n\n\t\t/**\n\t\t * Attempts to use any existing DOM scroller nodes if possible, returning true if so;\n\t\t * updates all internal element references.\n\t\t */\n\t\t_existingDOMValid = function _existingDOMValid() {\n\t\t\tvar scrollerContainer, layerX, layerY, yParent, scrollerX, scrollerY, candidates, i, l;\n\n\t\t\t// Check that there's an initial child node, and make sure it's the container class\n\t\t\tscrollerContainer = _scrollableMasterNode.firstElementChild;\n\t\t\tif (!scrollerContainer || scrollerContainer.className.indexOf('ftscroller_container') === -1) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If x-axis scrolling is enabled, find and verify the x scroller layer\n\t\t\tif (_instanceOptions.scrollingX) {\n\n\t\t\t\t// Find and verify the x scroller layer\n\t\t\t\tlayerX = scrollerContainer.firstElementChild;\n\t\t\t\tif (!layerX || layerX.className.indexOf('ftscroller_x') === -1) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tyParent = layerX;\n\n\t\t\t\t// Find and verify the x scrollbar if enabled\n\t\t\t\tif (_instanceOptions.scrollbars) {\n\t\t\t\t\tcandidates = scrollerContainer.getElementsByClassName('ftscroller_scrollbarx');\n\t\t\t\t\tif (candidates) {\n\t\t\t\t\t\tfor (i = 0, l = candidates.length; i < l; i = i + 1) {\n\t\t\t\t\t\t\tif (candidates[i].parentNode === scrollerContainer) {\n\t\t\t\t\t\t\t\tscrollerX = candidates[i];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!scrollerX) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tyParent = scrollerContainer;\n\t\t\t}\n\n\t\t\t// If y-axis scrolling is enabled, find and verify the y scroller layer\n\t\t\tif (_instanceOptions.scrollingY) {\n\n\t\t\t\t// Find and verify the x scroller layer\n\t\t\t\tlayerY = yParent.firstElementChild;\n\t\t\t\tif (!layerY || layerY.className.indexOf('ftscroller_y') === -1) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Find and verify the y scrollbar if enabled\n\t\t\t\tif (_instanceOptions.scrollbars) {\n\t\t\t\t\tcandidates = scrollerContainer.getElementsByClassName('ftscroller_scrollbary');\n\t\t\t\t\tif (candidates) {\n\t\t\t\t\t\tfor (i = 0, l = candidates.length; i < l; i = i + 1) {\n\t\t\t\t\t\t\tif (candidates[i].parentNode === scrollerContainer) {\n\t\t\t\t\t\t\t\tscrollerY = candidates[i];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!scrollerY) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Elements found and verified - update the references and return success\n\t\t\t_containerNode = scrollerContainer;\n\t\t\tif (layerX) {\n\t\t\t\t_scrollNodes.x = layerX;\n\t\t\t}\n\t\t\tif (layerY) {\n\t\t\t\t_scrollNodes.y = layerY;\n\t\t\t}\n\t\t\tif (scrollerX) {\n\t\t\t\t_scrollbarNodes.x = scrollerX;\n\t\t\t}\n\t\t\tif (scrollerY) {\n\t\t\t\t_scrollbarNodes.y = scrollerY;\n\t\t\t}\n\t\t\tif (_instanceOptions.scrollingY) {\n\t\t\t\t_contentParentNode = layerY;\n\t\t\t} else {\n\t\t\t\t_contentParentNode = layerX;\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\n\t\t_domChanged = function _domChanged(e) {\n\n\t\t\t// If the timer is active, clear it\n\t\t\tif (_domChangeDebouncer) {\n\t\t\t\twindow.clearTimeout(_domChangeDebouncer);\n\t\t\t}\n\n\t\t\t// React to resizes at once\n\t\t\tif (e && e.type === 'resize') {\n\t\t\t\t_updateDimensions();\n\n\t\t\t// For other changes, which may occur in groups, set up the DOM changed timer\n\t\t\t} else {\n\t\t\t\t_domChangeDebouncer = setTimeout(function () {\n\t\t\t\t\t_updateDimensions();\n\t\t\t\t}, 100);\n\t\t\t}\n\t\t};\n\n\t\t_updateDimensions = function _updateDimensions(ignoreSnapScroll) {\n\t\t\tvar axis;\n\n\t\t\t// Only update dimensions if the container node exists (DOM elements can go away if\n\t\t\t// the scroller instance is not destroyed correctly)\n\t\t\tif (!_containerNode || !_contentParentNode) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (_domChangeDebouncer) {\n\t\t\t\twindow.clearTimeout(_domChangeDebouncer);\n\t\t\t\t_domChangeDebouncer = false;\n\t\t\t}\n\t\t\tvar containerWidth, containerHeight, startAlignments;\n\n\t\t\t// Calculate the starting alignment for comparison later\n\t\t\tstartAlignments = { x: false, y: false };\n\t\t\tfor (axis in startAlignments) {\n\t\t\t\tif (startAlignments.hasOwnProperty(axis)) {\n\t\t\t\t\tif (_lastScrollPosition[axis] === 0) {\n\t\t\t\t\t\tstartAlignments[axis] = -1;\n\t\t\t\t\t} else if (_lastScrollPosition[axis] <= _metrics.scrollEnd[axis]) {\n\t\t\t\t\t\tstartAlignments[axis] = 1;\n\t\t\t\t\t} else if (_lastScrollPosition[axis] * 2 <= _metrics.scrollEnd[axis] + 5 && _lastScrollPosition[axis] * 2 >= _metrics.scrollEnd[axis] - 5) {\n\t\t\t\t\t\tstartAlignments[axis] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcontainerWidth = _containerNode.offsetWidth;\n\t\t\tcontainerHeight = _containerNode.offsetHeight;\n\n\t\t\t// Grab the dimensions\n\t\t\tvar rawScrollWidth = options.contentWidth || _contentParentNode.offsetWidth;\n\t\t\tvar rawScrollHeight = options.contentHeight || _contentParentNode.offsetHeight;\n\t\t\tvar scrollWidth = rawScrollWidth;\n\t\t\tvar scrollHeight = rawScrollHeight;\n\t\t\tvar targetPosition = { x: _lastScrollPosition.x, y: _lastScrollPosition.y };\n\n\t\t\t// Update snap grid\n\t\t\tif (!_snapGridSize.userX) {\n\t\t\t\t_snapGridSize.x = containerWidth;\n\t\t\t}\n\t\t\tif (!_snapGridSize.userY) {\n\t\t\t\t_snapGridSize.y = containerHeight;\n\t\t\t}\n\n\t\t\t// If there is a grid, conform to the grid\n\t\t\tif (_instanceOptions.snapping) {\n\t\t\t\tif (_snapGridSize.userX) {\n\t\t\t\t\tscrollWidth = Math.ceil(scrollWidth / _snapGridSize.userX) * _snapGridSize.userX;\n\t\t\t\t} else {\n\t\t\t\t\tscrollWidth = Math.ceil(scrollWidth / _snapGridSize.x) * _snapGridSize.x;\n\t\t\t\t}\n\t\t\t\tif (_snapGridSize.userY) {\n\t\t\t\t\tscrollHeight = Math.ceil(scrollHeight / _snapGridSize.userY) * _snapGridSize.userY;\n\t\t\t\t} else {\n\t\t\t\t\tscrollHeight = Math.ceil(scrollHeight / _snapGridSize.y) * _snapGridSize.y;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If no details have changed, return.\n\t\t\tif (_metrics.container.x === containerWidth && _metrics.container.y === containerHeight && _metrics.content.x === scrollWidth && _metrics.content.y === scrollHeight) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Update the sizes\n\t\t\t_metrics.container.x = containerWidth;\n\t\t\t_metrics.container.y = containerHeight;\n\t\t\t_metrics.content.x = scrollWidth;\n\t\t\t_metrics.content.rawX = rawScrollWidth;\n\t\t\t_metrics.content.y = scrollHeight;\n\t\t\t_metrics.content.rawY = rawScrollHeight;\n\t\t\t_metrics.scrollEnd.x = containerWidth - scrollWidth;\n\t\t\t_metrics.scrollEnd.y = containerHeight - scrollHeight;\n\n\t\t\t_updateScrollbarDimensions();\n\n\t\t\t// If scrolling is in progress, trigger a scroll update\n\t\t\tif (_isScrolling) {\n\t\t\t\t_lastScrollPosition.x--;\n\t\t\t\t_lastScrollPosition.y--;\n\t\t\t\t_constrainAndRenderTargetScrollPosition();\n\n\t\t\t// If scrolling *isn't* in progress, snap and realign.\n\t\t\t} else {\n\t\t\t\tif (!ignoreSnapScroll && _instanceOptions.snapping) {\n\n\t\t\t        // Ensure bounds are correct\n\t\t\t\t\t_updateSegments();\n\t\t\t\t\ttargetPosition = _getSnapPositionForIndexes(_snapIndex, _lastScrollPosition);\n\t\t\t\t}\n\n\t\t\t\t// Apply base alignment if appropriate\n\t\t\t\tfor (axis in targetPosition) {\n\t\t\t\t\tif (targetPosition.hasOwnProperty(axis)) {\n\n\t\t\t\t\t\t// If the container is smaller than the content, determine whether to apply the\n\t\t\t\t\t\t// alignment.  This occurs if a scroll has never taken place, or if the position\n\t\t\t\t\t\t// was previously at the correct \"end\" and can be maintained.\n\t\t\t\t\t\tif (_metrics.container[axis] < _metrics.content[axis]) {\n\t\t\t\t\t\t\tif (_hasBeenScrolled && _instanceOptions.baseAlignments[axis] !== startAlignments[axis]) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Apply the alignment\n\t\t\t\t\t\tif (_instanceOptions.baseAlignments[axis] === 1) {\n\t\t\t\t\t\t\ttargetPosition[axis] = _metrics.scrollEnd[axis];\n\t\t\t\t\t\t} else if (_instanceOptions.baseAlignments[axis] === 0) {\n\t\t\t\t\t\t\ttargetPosition[axis] = Math.floor(_metrics.scrollEnd[axis] / 2);\n\t\t\t\t\t\t} else if (_instanceOptions.baseAlignments[axis] === -1) {\n\t\t\t\t\t\t\ttargetPosition[axis] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Limit to bounds\n\t\t\t\ttargetPosition = _limitToBounds(targetPosition);\n\n\t\t\t\tif (_instanceOptions.scrollingX && targetPosition.x !== _lastScrollPosition.x) {\n\t\t\t\t\t_setAxisPosition('x', targetPosition.x, 0);\n\t\t\t\t\t_baseScrollPosition.x = targetPosition.x;\n\t\t\t\t}\n\t\t\t\tif (_instanceOptions.scrollingY && targetPosition.y !== _lastScrollPosition.y) {\n\t\t\t\t\t_setAxisPosition('y', targetPosition.y, 0);\n\t\t\t\t\t_baseScrollPosition.y = targetPosition.y;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t_updateScrollbarDimensions = function _updateScrollbarDimensions() {\n\n\t\t\t// Update scrollbar sizes\n\t\t\tif (_instanceOptions.scrollbars) {\n\t\t\t\tif (_instanceOptions.scrollingX) {\n\t\t\t\t\t_scrollbarNodes.x.style.width = Math.max(6, Math.round(_metrics.container.x * (_metrics.container.x / _metrics.content.x) - 4)) + 'px';\n\t\t\t\t}\n\t\t\t\tif (_instanceOptions.scrollingY) {\n\t\t\t\t\t_scrollbarNodes.y.style.height = Math.max(6, Math.round(_metrics.container.y * (_metrics.container.y / _metrics.content.y) - 4)) + 'px';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Update scroll caches\n\t\t\t_scrollableAxes = {};\n\t\t\tif (_instanceOptions.scrollingX && (_metrics.content.x > _metrics.container.x || _instanceOptions.alwaysScroll)) {\n\t\t\t\t_scrollableAxes.x = true;\n\t\t\t}\n\t\t\tif (_instanceOptions.scrollingY && (_metrics.content.y > _metrics.container.y || _instanceOptions.alwaysScroll)) {\n\t\t\t\t_scrollableAxes.y = true;\n\t\t\t}\n\t\t};\n\n\t\t_updateElementPosition = function _updateElementPosition() {\n\t\t\tvar axis, computedStyle, splitStyle;\n\n\t\t\t// Retrieve the current position of each active axis.\n\t\t\t// Custom parsing is used instead of native matrix support for speed and for\n\t\t\t// backwards compatibility.\n\t\t\tfor (axis in _scrollableAxes) {\n\t\t\t\tif (_scrollableAxes.hasOwnProperty(axis)) {\n\t\t\t\t\tcomputedStyle = window.getComputedStyle(_scrollNodes[axis], null)[_vendorTransformLookup];\n\t\t\t\t\tsplitStyle = computedStyle.split(', ');\n\n\t\t\t\t\t// For 2d-style transforms, pull out elements four or five\n\t\t\t\t\tif (splitStyle.length === 6) {\n\t\t\t\t\t\t_baseScrollPosition[axis] = parseInt(splitStyle[(axis === 'y') ? 5 : 4], 10);\n\n\t\t\t\t\t// For 3d-style transforms, pull out elements twelve or thirteen\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_baseScrollPosition[axis] = parseInt(splitStyle[(axis === 'y') ? 13 : 12], 10);\n\t\t\t\t\t}\n\t\t\t\t\t_lastScrollPosition[axis] = _baseScrollPosition[axis];\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t_updateSegments = function _updateSegments(scrollFinalised) {\n\t\t\tvar axis;\n\t\t\tvar newSegment = { x: 0, y: 0 };\n\n\t\t\t// If snapping is disabled, return without any further action required\n\t\t\tif (!_instanceOptions.snapping) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Calculate the new segments\n\t\t\tfor (axis in _scrollableAxes) {\n\t\t\t\tif (_scrollableAxes.hasOwnProperty(axis)) {\n\t\t\t\t\tnewSegment[axis] = Math.max(0, Math.min(Math.ceil(_metrics.content[axis] / _snapGridSize[axis]) - 1, Math.round(-_lastScrollPosition[axis] / _snapGridSize[axis])));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// In all cases update the active segment if appropriate\n\t\t\tif (newSegment.x !== _activeSegment.x || newSegment.y !== _activeSegment.y) {\n\t\t\t\t_activeSegment.x = newSegment.x;\n\t\t\t\t_activeSegment.y = newSegment.y;\n\t\t\t\t_fireEvent('segmentwillchange', { segmentX: newSegment.x, segmentY: newSegment.y });\n\t\t\t}\n\n\t\t\t// If the scroll has been finalised, also update the base segment\n\t\t\tif (scrollFinalised) {\n\t\t\t\tif (newSegment.x !== _baseSegment.x || newSegment.y !== _baseSegment.y) {\n\t\t\t\t\t_baseSegment.x = newSegment.x;\n\t\t\t\t\t_baseSegment.y = newSegment.y;\n\t\t\t\t\t_fireEvent('segmentdidchange', { segmentX: newSegment.x, segmentY: newSegment.y });\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t_setAxisPosition = function _setAxisPosition(axis, position, animationDuration, animationBezier, boundsCrossDelay) {\n\t\t\tvar transitionCSSString, newPositionAtExtremity = null;\n\n\t\t\t// Only update position if the axis node exists (DOM elements can go away if\n\t\t\t// the scroller instance is not destroyed correctly)\n\t\t\tif (!_scrollNodes[axis]) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Determine the transition property to apply to both the scroll element and the scrollbar\n\t\t\tif (animationDuration) {\n\t\t\t\tif (!animationBezier) {\n\t\t\t\t\tanimationBezier = _instanceOptions.flingBezier;\n\t\t\t\t}\n\n\t\t\t\ttransitionCSSString = _vendorCSSPrefix + 'transform ' + animationDuration + 'ms ' + animationBezier.toString();\n\t\t\t} else {\n\t\t\t\ttransitionCSSString = '';\n\t\t\t}\n\n\t\t\t// Apply the transition property to elements\n\t\t\t_scrollNodes[axis].style[_transitionProperty] = transitionCSSString;\n\t\t\tif (_instanceOptions.scrollbars) {\n\t\t\t\t_scrollbarNodes[axis].style[_transitionProperty] = transitionCSSString;\n\t\t\t}\n\n\t\t\t// Update the positions\n\t\t\t_scrollNodes[axis].style[_transformProperty] = _translateRulePrefix + _transformPrefixes[axis] + position + 'px' + _transformSuffixes[axis];\n\t\t\tif (_instanceOptions.scrollbars) {\n\t\t\t\t_scrollbarNodes[axis].style[_transformProperty] = _translateRulePrefix + _transformPrefixes[axis] + (-position * _metrics.container[axis] / _metrics.content[axis]) + 'px' + _transformSuffixes[axis];\n\t\t\t}\n\n\t\t\t// Determine whether the scroll is at an extremity.\n\t\t\tif (position >= 0) {\n\t\t\t\tnewPositionAtExtremity = 'start';\n\t\t\t} else if (position <= _metrics.scrollEnd[axis]) {\n\t\t\t\tnewPositionAtExtremity = 'end';\n\t\t\t}\n\n\t\t\t// If the extremity status has changed, fire an appropriate event\n\t\t\tif (newPositionAtExtremity !== _scrollAtExtremity[axis]) {\n\t\t\t\tif (newPositionAtExtremity !== null) {\n\t\t\t\t\tif (animationDuration) {\n\t\t\t\t\t\t_timeouts.push(setTimeout(function() {\n\t\t\t\t\t\t\t_fireEvent('reached' + newPositionAtExtremity, { axis: axis });\n\t\t\t\t\t\t}, boundsCrossDelay || animationDuration));\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_fireEvent('reached' + newPositionAtExtremity, { axis: axis });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_scrollAtExtremity[axis] = newPositionAtExtremity;\n\t\t\t}\n\n\t\t\t// Update the recorded position if there's no duration\n\t\t\tif (!animationDuration) {\n\t\t\t\t_lastScrollPosition[axis] = position;\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Retrieve the current position as an object with scrollLeft and scrollTop\n\t\t * properties.\n\t\t */\n\t\t_getPosition = function _getPosition() {\n\t\t\treturn {\n\t\t\t\tscrollLeft: -_lastScrollPosition.x,\n\t\t\t\tscrollTop: -_lastScrollPosition.y\n\t\t\t};\n\t\t};\n\n\t\t_scheduleAxisPosition = function _scheduleAxisPosition(axis, position, animationDuration, animationBezier, afterDelay) {\n\t\t\t_timeouts.push(setTimeout(function () {\n\t\t\t\t_setAxisPosition(axis, position, animationDuration, animationBezier);\n\t\t\t}, afterDelay));\n\t\t};\n\n\t\t_fireEvent = function _fireEvent(eventName, eventObject) {\n\t\t\tvar i, l;\n\t\t\teventObject.srcObject = _publicSelf;\n\n\t\t\t// Iterate through any listeners\n\t\t\tfor (i = 0, l = _eventListeners[eventName].length; i < l; i = i + 1) {\n\n\t\t\t\t// Execute each in a try/catch\n\t\t\t\ttry {\n\t\t\t\t\t_eventListeners[eventName][i](eventObject);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tif (window.console && window.console.error) {\n\t\t\t\t\t\tif (error.message) {\n\t\t\t\t\t\t\twindow.console.error(error.message + ' (' + error.sourceURL + ', line ' + error.line + ')');\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twindow.console.error('Error encountered executing FTScroller event listener callback for [' + eventName + ']. Add a \"debugger\" statement here to obtain a full backtrace.');\n\t\t\t\t\t\t\tif (window.console.dir) window.console.dir(error);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Update the scroll position so that the child element is in view.\n\t\t */\n\t\t_childFocused = function _childFocused(event) {\n\t\t\tvar offset, axis, visibleChildPortion;\n\t\t\tvar focusedNodeRect = _getBoundingRect(event.target);\n\t\t\tvar containerRect = _getBoundingRect(_containerNode);\n\t\t\tvar edgeMap = { x: 'left', y: 'top' };\n\t\t\tvar opEdgeMap = { x: 'right', y: 'bottom' };\n\t\t\tvar dimensionMap = { x: 'width', y: 'height' };\n\n\t\t\t// If an input is currently being tracked, ignore the focus event\n\t\t\tif (_inputIdentifier !== false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (axis in _scrollableAxes) {\n\t\t\t\tif (_scrollableAxes.hasOwnProperty(axis)) {\n\n\t\t\t\t\t// If the focussed node is entirely in view, there is no need to center it\n\t\t\t\t\tif (focusedNodeRect[edgeMap[axis]] >= containerRect[edgeMap[axis]] && focusedNodeRect[opEdgeMap[axis]] <= containerRect[opEdgeMap[axis]]) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If the focussed node is larger than the container...\n\t\t\t\t\tif (focusedNodeRect[dimensionMap[axis]] > containerRect[dimensionMap[axis]]) {\n\n\t\t\t\t\t\tvisibleChildPortion = focusedNodeRect[dimensionMap[axis]] - Math.max(0, containerRect[edgeMap[axis]] - focusedNodeRect[edgeMap[axis]]) - Math.max(0, focusedNodeRect[opEdgeMap[axis]] - containerRect[opEdgeMap[axis]]);\n\n\t\t\t\t\t\t// If more than half a container's portion of the focussed node is visible, there's no need to center it\n\t\t\t\t\t\tif (visibleChildPortion >= (containerRect[dimensionMap[axis]] / 2)) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Set the target offset to be in the middle of the container, or as close as bounds permit\n\t\t\t\t\toffset = -Math.round((focusedNodeRect[dimensionMap[axis]] / 2) - _lastScrollPosition[axis] + focusedNodeRect[edgeMap[axis]] - containerRect[edgeMap[axis]]  - (containerRect[dimensionMap[axis]] / 2));\n\t\t\t\t\toffset = Math.min(0, Math.max(_metrics.scrollEnd[axis], offset));\n\n\t\t\t\t\t// Perform the scroll\n\t\t\t\t\t_setAxisPosition(axis, offset, 0);\n\t\t\t\t\t_baseScrollPosition[axis] = offset;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconsole.log('firing scroll event from _childFocused');\n\t\t\t_fireEvent('scroll', _getPosition());\n\t\t};\n\n\t\t/**\n\t\t * Given a relative distance beyond the element bounds, returns a modified version to\n\t\t * simulate bouncy/springy edges.\n\t\t */\n\t\t_modifyDistanceBeyondBounds = function _modifyDistanceBeyondBounds(distance, axis) {\n\t\t\tif (!_instanceOptions.bouncing) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tvar e = Math.exp(distance / _metrics.container[axis]);\n\t\t\treturn Math.round(_metrics.container[axis] * 0.6 * (e - 1) / (e + 1));\n\t\t};\n\n\t\t/**\n\t\t * Given positions for each enabled axis, returns an object showing how far each axis is beyond\n\t\t * bounds. If within bounds, -1 is returned; if at the bounds, 0 is returned.\n\t\t */\n\t\t_distancesBeyondBounds = function _distancesBeyondBounds(positions) {\n\t\t\tvar axis, position;\n\t\t\tvar distances = {};\n\t\t\tfor (axis in positions) {\n\t\t\t\tif (positions.hasOwnProperty(axis)) {\n\t\t\t\t\tposition = positions[axis];\n\n\t\t\t\t\t// If the position is to the left/top, no further modification required\n\t\t\t\t\tif (position >= 0) {\n\t\t\t\t\t\tdistances[axis] = position;\n\n\t\t\t\t\t// If it's within the bounds, use -1\n\t\t\t\t\t} else if (position > _metrics.scrollEnd[axis]) {\n\t\t\t\t\t\tdistances[axis] = -1;\n\n\t\t\t\t\t// Otherwise, amend by the distance of the maximum edge\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdistances[axis] = _metrics.scrollEnd[axis] - position;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn distances;\n\t\t};\n\n\t\t/**\n\t\t * On platforms which support it, use RequestAnimationFrame to group\n\t\t * position updates for speed.  Starts the render process.\n\t\t */\n\t\t_startAnimation = function _startAnimation() {\n\t\t\tif (_reqAnimationFrame) {\n\t\t\t\t_cancelAnimation();\n\t\t\t\t_animationFrameRequest = _reqAnimationFrame(_scheduleRender);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * On platforms which support RequestAnimationFrame, provide the rendering loop.\n\t\t * Takes two arguments; the first is the render/position update function to\n\t\t * be called, and the second is a string controlling the render type to\n\t\t * allow previous changes to be cancelled - should be 'pan' or 'scroll'.\n\t\t */\n\t\t_scheduleRender = function _scheduleRender() {\n\t\t\tvar axis, positionUpdated;\n\n\t\t\t// If using requestAnimationFrame schedule the next update at once\n\t\t\tif (_reqAnimationFrame) {\n\t\t\t\t_animationFrameRequest = _reqAnimationFrame(_scheduleRender);\n\t\t\t}\n\n\t\t\t// Perform the draw.\n\t\t\tfor (axis in _scrollableAxes) {\n\t\t\t\tif (_scrollableAxes.hasOwnProperty(axis) && _targetScrollPosition[axis] !== _lastScrollPosition[axis]) {\n\t\t\t\t\t_setAxisPosition(axis, _targetScrollPosition[axis]);\n\t\t\t\t\tpositionUpdated = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If full, locked scrolling has enabled, fire any scroll and segment change events\n\t\t\tif (_isScrolling && positionUpdated) {\n\t\t\t\tconsole.log('firing scroll event from _scheduleRender');\n\t\t\t\t_fireEvent('scroll', _getPosition());\n\t\t\t\t_updateSegments(false);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Stops the animation process.\n\t\t */\n\t\t_cancelAnimation = function _cancelAnimation() {\n\t\t\tif (_animationFrameRequest === false || !_cancelAnimationFrame) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_cancelAnimationFrame(_animationFrameRequest);\n\t\t\t_animationFrameRequest = false;\n\t\t};\n\n\t\t/**\n\t\t * Remove then re-set event handlers\n\t\t */\n\t\t_resetEventHandlers = function() {\n\t\t\t_removeEventHandlers();\n\t\t\t_addEventHandlers();\n\t\t};\n\n\t\t/**\n\t\t * Register event handlers\n\t\t */\n\t\t_addEventHandlers = function _addEventHandlers() {\n\t\t\tvar MutationObserver;\n\n\t\t\t// Only remove the event if the node exists (DOM elements can go away)\n\t\t\tif (!_containerNode) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (_trackPointerEvents && !_instanceOptions.disabledInputMethods.pointer) {\n\t\t\t\tif (_pointerEventsPrefixed) {\n\t\t\t\t\t_containerNode.addEventListener('MSPointerDown', _onPointerDown);\n\t\t\t\t\t_containerNode.addEventListener('MSPointerMove', _onPointerMove);\n\t\t\t\t\t_containerNode.addEventListener('MSPointerUp', _onPointerUp);\n\t\t\t\t\t_containerNode.addEventListener('MSPointerCancel', _onPointerCancel);\n\t\t\t\t} else {\n\t\t\t\t\t_containerNode.addEventListener('pointerdown', _onPointerDown);\n\t\t\t\t\t_containerNode.addEventListener('pointermove', _onPointerMove);\n\t\t\t\t\t_containerNode.addEventListener('pointerup', _onPointerUp);\n\t\t\t\t\t_containerNode.addEventListener('pointercancel', _onPointerCancel);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (_trackTouchEvents && !_instanceOptions.disabledInputMethods.touch) {\n\t\t\t\t\t_containerNode.addEventListener('touchstart', _onTouchStart);\n\t\t\t\t\t_containerNode.addEventListener('touchmove', _onTouchMove);\n\t\t\t\t\t_containerNode.addEventListener('touchend', _onTouchEnd);\n\t\t\t\t\t_containerNode.addEventListener('touchcancel', _onTouchEnd);\n\t\t\t\t}\n\t\t\t\tif (!_instanceOptions.disabledInputMethods.mouse) {\n\t\t\t\t\t_containerNode.addEventListener('mousedown', _onMouseDown);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!_instanceOptions.disabledInputMethods.scroll) {\n\t\t\t\t_containerNode.addEventListener('DOMMouseScroll', _onMouseScroll);\n\t\t\t\t_containerNode.addEventListener('mousewheel', _onMouseScroll);\n\t\t\t}\n\n\t\t\t// If any of the input methods which would eventually trigger a click are\n\t\t\t// enabled, add a click event listener so that phantom clicks can be prevented\n\t\t\t// at the end of a scroll. Otherwise, don't add a listener and don't prevent\n\t\t\t// clicks.\n\t\t\tif (!_instanceOptions.disabledInputMethods.mouse || !_instanceOptions.disabledInputMethods.touch || !_instanceOptions.disabledInputMethods.pointer) {\n\n\t\t\t\t// Add a click listener.  On IE, add the listener to the document, to allow\n\t\t\t\t// clicks to be cancelled if a scroll ends outside the bounds of the container; on\n\t\t\t\t// other platforms, add to the container node.\n\t\t\t\tif (_trackPointerEvents) {\n\t\t\t\t\tdocument.addEventListener('click', _onClick, true);\n\t\t\t\t} else {\n\t\t\t\t\t_containerNode.addEventListener('click', _onClick, true);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Watch for changes inside the contained element to update bounds - de-bounced slightly.\n\t\t\tif (!_instanceOptions.disabledInputMethods.focus) {\n\t\t\t\t_contentParentNode.addEventListener('focus', _childFocused);\n\t\t\t}\n\t\t\tif (_instanceOptions.updateOnChanges) {\n\n\t\t\t\t// Try and reuse the old, disconnected observer instance if available\n\t\t\t\t// Otherwise, check for support before proceeding\n\t\t\t\tif (!_mutationObserver) {\n\t\t\t\t\tMutationObserver = window.MutationObserver || window.WebKitMutationObserver || window[_vendorStylePropertyPrefix + 'MutationObserver'];\n\t\t\t\t\tif (MutationObserver) {\n\t\t\t\t\t\t_mutationObserver = new MutationObserver(_domChanged);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (_mutationObserver) {\n\t\t\t\t\t_mutationObserver.observe(_contentParentNode, {\n\t\t\t\t\t\tchildList: true,\n\t\t\t\t\t\tcharacterData: true,\n\t\t\t\t\t\tsubtree: true\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\t_contentParentNode.addEventListener('DOMSubtreeModified', function (e) {\n\n\t\t\t\t\t\t// Ignore changes to nested FT Scrollers - even updating a transform style\n\t\t\t\t\t\t// can trigger a DOMSubtreeModified in IE, causing nested scrollers to always\n\t\t\t\t\t\t// favour the deepest scroller as parent scrollers 'resize'/end scrolling.\n\t\t\t\t\t\tif (e && (e.srcElement === _contentParentNode || e.srcElement.className.indexOf('ftscroller_') !== -1)) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_domChanged();\n\t\t\t\t\t}, true);\n\t\t\t\t}\n\t\t\t\t_contentParentNode.addEventListener('load', _domChanged);\n\t\t\t}\n\t\t\tif (_instanceOptions.updateOnWindowResize) {\n\t\t\t\twindow.addEventListener('resize', _domChanged);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Remove event handlers.\n\t\t *\n\t\t * The current flags may not match the state when the event handlers were set up,\n\t\t * so remove all event handlers unconditionally, just in case they're bound.\n\t\t */\n\t\t_removeEventHandlers = function _removeEventHandlers() {\n\n\t\t\tif (_containerNode) {\n\t\t\t\t_containerNode.removeEventListener('MSPointerDown', _onPointerDown);\n\t\t\t\t_containerNode.removeEventListener('MSPointerMove', _onPointerMove);\n\t\t\t\t_containerNode.removeEventListener('MSPointerUp', _onPointerUp);\n\t\t\t\t_containerNode.removeEventListener('MSPointerCancel', _onPointerCancel);\n\t\t\t\t_containerNode.removeEventListener('pointerdown', _onPointerDown);\n\t\t\t\t_containerNode.removeEventListener('pointermove', _onPointerMove);\n\t\t\t\t_containerNode.removeEventListener('pointerup', _onPointerUp);\n\t\t\t\t_containerNode.removeEventListener('pointercancel', _onPointerCancel);\n\t\t\t\t_containerNode.removeEventListener('touchstart', _onTouchStart);\n\t\t\t\t_containerNode.removeEventListener('touchmove', _onTouchMove);\n\t\t\t\t_containerNode.removeEventListener('touchend', _onTouchEnd);\n\t\t\t\t_containerNode.removeEventListener('touchcancel', _onTouchEnd);\n\t\t\t\t_containerNode.removeEventListener('mousedown', _onMouseDown);\n\t\t\t\t_containerNode.removeEventListener('DOMMouseScroll', _onMouseScroll);\n\t\t\t\t_containerNode.removeEventListener('mousewheel', _onMouseScroll);\n\t\t\t\t_containerNode.removeEventListener('click', _onClick, true);\n\t\t\t}\n\n\t\t\tif (_contentParentNode) {\n\t\t\t\t_contentParentNode.removeEventListener('focus', _childFocused);\n\t\t\t\t_contentParentNode.removeEventListener('DOMSubtreeModified', _domChanged);\n\t\t\t\t_contentParentNode.removeEventListener('load', _domChanged);\n\t\t\t}\n\n\t\t\tif (_mutationObserver) {\n\t\t\t\t_mutationObserver.disconnect();\n\t\t\t}\n\n\t\t\tdocument.removeEventListener('mousemove', _onMouseMove);\n\t\t\tdocument.removeEventListener('mouseup', _onMouseUp);\n\t\t\tdocument.removeEventListener('click', _onClick, true);\n\t\t\twindow.removeEventListener('resize', _domChanged);\n\t\t};\n\n\t\t/**\n\t\t * Touch event handlers\n\t\t */\n\t\t_onTouchStart = function _onTouchStart(startEvent) {\n\t\t\tvar i, l, touchEvent;\n\n\t\t\t// If a touch is already active, ensure that the index\n\t\t\t// is mapped to the correct finger, and return.\n\t\t\tif (_inputIdentifier) {\n\t\t\t\tfor (i = 0, l = startEvent.touches.length; i < l; i = i + 1) {\n\t\t\t\t\tif (startEvent.touches[i].identifier === _inputIdentifier) {\n\t\t\t\t\t\t_inputIndex = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Track the new touch's identifier, reset index, and pass\n\t\t\t// the coordinates to the scroll start function.\n\t\t\ttouchEvent = startEvent.touches[0];\n\t\t\t_inputIdentifier = touchEvent.identifier;\n\t\t\t_inputIndex = 0;\n\t\t\t_startScroll(touchEvent.clientX, touchEvent.clientY, startEvent.timeStamp, startEvent);\n\t\t};\n\t\t_onTouchMove = function _onTouchMove(moveEvent) {\n\t\t\tif (_inputIdentifier === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Get the coordinates from the appropriate touch event and\n\t\t\t// pass them on to the scroll handler\n\t\t\tvar touchEvent = moveEvent.touches[_inputIndex];\n\t\t\t_updateScroll(touchEvent.clientX, touchEvent.clientY, moveEvent.timeStamp, moveEvent);\n\t\t};\n\t\t_onTouchEnd = function _onTouchEnd(endEvent) {\n\t\t\tvar i, l;\n\n\t\t\t// Check whether the original touch event is still active,\n\t\t\t// if it is, update the index and return.\n\t\t\tif (endEvent.touches) {\n\t\t\t\tfor (i = 0, l = endEvent.touches.length; i < l; i = i + 1) {\n\t\t\t\t\tif (endEvent.touches[i].identifier === _inputIdentifier) {\n\t\t\t\t\t\t_inputIndex = i;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Complete the scroll.  Note that touch end events\n\t\t\t// don't capture coordinates.\n\t\t\t_endScroll(endEvent.timeStamp, endEvent);\n\t\t};\n\n\t\t/**\n\t\t * Mouse event handlers\n\t\t */\n\t\t_onMouseDown = function _onMouseDown(startEvent) {\n\n\t\t\t// Don't track the right mouse buttons, or a context menu\n\t\t\tif ((startEvent.button && startEvent.button === 2) || startEvent.ctrlKey) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Capture if possible\n\t\t\tif (_containerNode.setCapture) {\n\t\t\t\t_containerNode.setCapture();\n\t\t\t}\n\n\t\t\t// Add move & up handlers to the *document* to allow handling outside the element\n\t\t\tdocument.addEventListener('mousemove', _onMouseMove, true);\n\t\t\tdocument.addEventListener('mouseup', _onMouseUp, true);\n\n\t\t\t_inputIdentifier = startEvent.button || 1;\n\t\t\t_inputIndex = 0;\n\t\t\t_startScroll(startEvent.clientX, startEvent.clientY, startEvent.timeStamp, startEvent);\n\t\t};\n\t\t_onMouseMove = function _onMouseMove(moveEvent) {\n\t\t\tif (!_inputIdentifier) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_updateScroll(moveEvent.clientX, moveEvent.clientY, moveEvent.timeStamp, moveEvent);\n\t\t};\n\t\t_onMouseUp = function _onMouseUp(endEvent) {\n\t\t\tif (endEvent.button && endEvent.button !== _inputIdentifier) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tdocument.removeEventListener('mousemove', _onMouseMove, true);\n\t\t\tdocument.removeEventListener('mouseup', _onMouseUp, true);\n\n\t\t\t// Release capture if possible\n\t\t\tif (_containerNode.releaseCapture) {\n\t\t\t\t_containerNode.releaseCapture();\n\t\t\t}\n\n\t\t\t_endScroll(endEvent.timeStamp, endEvent);\n\t\t};\n\n\t\t/**\n\t\t * Pointer event handlers\n\t\t */\n\t\t_onPointerDown = function _onPointerDown(startEvent) {\n\n\t\t\t// If there is already a pointer event being tracked, ignore subsequent.\n\t\t\t// However, if this pointer is seen as the primary pointer, override that.\n\t\t\tif (_inputIdentifier && !startEvent.isPrimary) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Disable specific input types if specified in the config.  Separate\n\t\t\t// out touch and other events (eg treat both pen and mouse as \"mouse\")\n\t\t\tif (startEvent.pointerType === _pointerTypeTouch) {\n\t\t\t\tif (_instanceOptions.disabledInputMethods.touch) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else if (_instanceOptions.disabledInputMethods.mouse) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_inputIdentifier = startEvent.pointerId;\n\t\t\t_startScroll(startEvent.clientX, startEvent.clientY, startEvent.timeStamp, startEvent);\n\t\t};\n\t\t_onPointerMove = function _onPointerMove(moveEvent) {\n\t\t\tif (_inputIdentifier !== moveEvent.pointerId) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t_updateScroll(moveEvent.clientX, moveEvent.clientY, moveEvent.timeStamp, moveEvent);\n\t\t};\n\t\t_onPointerUp = function _onPointerUp(endEvent) {\n\t\t\tif (_inputIdentifier !== endEvent.pointerId) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_endScroll(endEvent.timeStamp, endEvent);\n\t\t};\n\t\t_onPointerCancel = function _onPointerCancel(endEvent) {\n\t\t\t_endScroll(endEvent.timeStamp, endEvent);\n\t\t};\n\t\t_onPointerCaptureEnd = function _onPointerCaptureEnd(event) {\n\n\t\t\t// On pointer capture end - which can happen because of another element\n\t\t\t// releasing pointer capture - don't end scrolling, but do track that\n\t\t\t// input capture has been lost.  This will result in pointers leaving\n\t\t\t// the window possibly being lost, but further interactions will fix\n\t\t\t// the tracking again.\n\t\t\t_inputCaptured = false;\n\t\t};\n\n\n\t\t/**\n\t\t * Prevents click actions if appropriate\n\t\t */\n\t\t_onClick = function _onClick(clickEvent) {\n\n\t\t\t// If a scroll action hasn't resulted in the next scroll being prevented, and a scroll\n\t\t\t// isn't currently in progress with a different identifier, allow the click\n\t\t\tif (!_preventClick) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// Prevent clicks using the preventDefault() and stopPropagation() handlers on the event;\n\t\t\t// this is safe even in IE10 as this is always a \"true\" event, never a window.event.\n\t\t\tclickEvent.preventDefault();\n\t\t\tclickEvent.stopPropagation();\n\t\t\tif (!_inputIdentifier) {\n\t\t\t\t_preventClick = false;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\n\t\t/**\n\t\t * Process scroll wheel/input actions as scroller scrolls\n\t\t */\n\t\t_onMouseScroll = function _onMouseScroll(event) {\n\t\t\tvar scrollDeltaX, scrollDeltaY;\n\t\t\tif (_inputIdentifier !== 'scrollwheel') {\n\t\t\t\tif (_inputIdentifier !== false) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t_inputIdentifier = 'scrollwheel';\n\t\t\t\t_cumulativeScroll.x = 0;\n\t\t\t\t_cumulativeScroll.y = 0;\n\n\t\t\t\t// Start a scroll event\n\t\t\t\tif (!_startScroll(event.clientX, event.clientY, Date.now(), event)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Convert the scrollwheel values to a scroll value\n\t\t\tif (event.wheelDelta) {\n\t\t\t\tif (event.wheelDeltaX) {\n\t\t\t\t\tscrollDeltaX = event.wheelDeltaX / 2;\n\t\t\t\t\tscrollDeltaY = event.wheelDeltaY / 2;\n\t\t\t\t} else {\n\t\t\t\t\tscrollDeltaX = 0;\n\t\t\t\t\tscrollDeltaY = event.wheelDelta / 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (event.axis && event.axis === event.HORIZONTAL_AXIS) {\n\t\t\t\t\tscrollDeltaX = event.detail * -10;\n\t\t\t\t\tscrollDeltaY = 0;\n\t\t\t\t} else {\n\t\t\t\t\tscrollDeltaX = 0;\n\t\t\t\t\tscrollDeltaY = event.detail * -10;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If the scroller is constrained to an x axis, convert y scroll to allow single-axis scroll\n\t\t\t// wheels to scroll constrained content.\n\t\t\tif (!_instanceOptions.scrollingY && !scrollDeltaX) {\n\t\t\t\tscrollDeltaX = scrollDeltaY;\n\t\t\t\tscrollDeltaY = 0;\n\t\t\t}\n\n\t\t\t_cumulativeScroll.x = Math.round(_cumulativeScroll.x + scrollDeltaX);\n\t\t\t_cumulativeScroll.y = Math.round(_cumulativeScroll.y + scrollDeltaY);\n\n\t\t\t_updateScroll(_gestureStart.x + _cumulativeScroll.x, _gestureStart.y + _cumulativeScroll.y, event.timeStamp, event);\n\n\t\t\t// End scrolling state\n\t\t\tif (_scrollWheelEndDebouncer) {\n\t\t\t\tclearTimeout(_scrollWheelEndDebouncer);\n\t\t\t}\n\t\t\t_scrollWheelEndDebouncer = setTimeout(function () {\n\t\t\t\t_releaseInputCapture();\n\t\t\t\t_inputIdentifier = false;\n\t\t\t\t_isScrolling = false;\n\t\t\t\t_preventClick = false;\n\t\t\t\t_isDisplayingScroll = false;\n\t\t\t\t_ftscrollerMoving = false;\n\t\t\t\tif (_instanceOptions.windowScrollingActiveFlag) {\n\t\t\t\t\twindow[_instanceOptions.windowScrollingActiveFlag] = false;\n\t\t\t\t}\n\t\t\t\t_cancelAnimation();\n\t\t\t\tif (!_snapScroll()) {\n\t\t\t\t\t_finalizeScroll();\n\t\t\t\t}\n\t\t\t}, 300);\n\t\t};\n\n\t\t/**\n\t\t * Capture and release input support, particularly allowing tracking\n\t\t * of Metro pointers outside the docked view.  Note that _releaseInputCapture\n\t\t * should be called before the input identifier is cleared.\n\t\t */\n\t\t_captureInput = function _captureInput() {\n\t\t\tif (_inputCaptured || _inputIdentifier === false || _inputIdentifier === 'scrollwheel') {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (_trackPointerEvents) {\n\t\t\t\t_containerNode[_setPointerCapture](_inputIdentifier);\n\t\t\t\t_containerNode.addEventListener(_lostPointerCapture, _onPointerCaptureEnd, false);\n\t\t\t}\n\t\t\t_inputCaptured = true;\n\t\t};\n\t\t_releaseInputCapture = function _releaseInputCapture() {\n\t\t\tif (!_inputCaptured) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (_trackPointerEvents) {\n\t\t\t\t_containerNode.removeEventListener(_lostPointerCapture, _onPointerCaptureEnd, false);\n\t\t\t\t_containerNode[_releasePointerCapture](_inputIdentifier);\n\t\t\t}\n\t\t\t_inputCaptured = false;\n\t\t};\n\n\t\t/**\n\t\t * Utility function acting as a getBoundingClientRect polyfill.\n\t\t */\n\t\t_getBoundingRect = function _getBoundingRect(anElement) {\n\t\t\tif (anElement.getBoundingClientRect) {\n\t\t\t\treturn anElement.getBoundingClientRect();\n\t\t\t}\n\n\t\t\tvar x = 0, y = 0, eachElement = anElement;\n\t\t\twhile (eachElement) {\n\t\t\t\tx = x + eachElement.offsetLeft - eachElement.scrollLeft;\n\t\t\t\ty = y + eachElement.offsetTop - eachElement.scrollTop;\n\t\t\t\teachElement = eachElement.offsetParent;\n\t\t\t}\n\t\t\treturn { left: x, top: y, width: anElement.offsetWidth, height: anElement.offsetHeight };\n\t\t};\n\n\n\t\t/*                     Instantiation                     */\n\n\t\t// Set up the DOM node if appropriate\n\t\t_initializeDOM();\n\n\t\t// Update sizes\n\t\t_updateDimensions();\n\n\t\t// Set up the event handlers\n\t\t_addEventHandlers();\n\n\t\t// Define a public API to be returned at the bottom - this is the public-facing interface.\n\t\t_publicSelf = {\n\t\t\tdestroy: destroy,\n\t\t\tsetSnapSize: setSnapSize,\n\t\t\tscrollTo: scrollTo,\n\t\t\tscrollBy: scrollBy,\n\t\t\tupdateDimensions: updateDimensions,\n\t\t\taddEventListener: addEventListener,\n\t\t\tremoveEventListener: removeEventListener,\n\t\t\tsetDisabledInputMethods: setDisabledInputMethods\n\t\t};\n\n\t\tif (Object.defineProperties) {\n\t\t\tObject.defineProperties(_publicSelf, {\n\t\t\t\t'scrollHeight': {\n\t\t\t\t\tget: function() { return _metrics.content.y; },\n\t\t\t\t\tset: function(value) { throw new SyntaxError('scrollHeight is currently read-only - ignoring ' + value); }\n\t\t\t\t},\n\t\t\t\t'scrollLeft': {\n\t\t\t\t\tget: function() { return -_lastScrollPosition.x; },\n\t\t\t\t\tset: function(value) { scrollTo(value, false, false); return -_lastScrollPosition.x; }\n\t\t\t\t},\n\t\t\t\t'scrollTop': {\n\t\t\t\t\tget: function() { return -_lastScrollPosition.y; },\n\t\t\t\t\tset: function(value) { scrollTo(false, value, false); return -_lastScrollPosition.y; }\n\t\t\t\t},\n\t\t\t\t'scrollWidth': {\n\t\t\t\t\tget: function() { return _metrics.content.x; },\n\t\t\t\t\tset: function(value) { throw new SyntaxError('scrollWidth is currently read-only - ignoring ' + value); }\n\t\t\t\t},\n\t\t\t\t'segmentCount': {\n\t\t\t\t\tget: function() {\n\t\t\t\t\t\tif (!_instanceOptions.snapping) {\n\t\t\t\t\t\t\treturn { x: NaN, y: NaN };\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tx: Math.ceil(_metrics.content.x / _snapGridSize.x),\n\t\t\t\t\t\t\ty: Math.ceil(_metrics.content.y / _snapGridSize.y)\n\t\t\t\t\t\t};\n\t\t\t\t\t},\n\t\t\t\t\tset: function(value) { throw new SyntaxError('segmentCount is currently read-only - ignoring ' + value); }\n\t\t\t\t},\n\t\t\t\t'currentSegment': {\n\t\t\t\t\tget: function() { return { x: _activeSegment.x, y: _activeSegment.y }; },\n\t\t\t\t\tset: function(value) { throw new SyntaxError('currentSegment is currently read-only - ignoring ' + value); }\n\t\t\t\t},\n\t\t\t\t'contentContainerNode': {\n\t\t\t\t\tget: function() { return _contentParentNode; },\n\t\t\t\t\tset: function(value) { throw new SyntaxError('contentContainerNode is currently read-only - ignoring ' + value); }\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// Return the public interface.\n\t\treturn _publicSelf;\n\t};\n\n\n\t/*          Prototype Functions and Properties           */\n\n\t/**\n\t * The HTML to prepend to the scrollable content to wrap it. Used internally,\n\t * and may be used to pre-wrap scrollable content.  Axes can optionally\n\t * be excluded for speed improvements.\n\t */\n\tFTScroller.prototype.getPrependedHTML = function (excludeXAxis, excludeYAxis, hwAccelerationClass) {\n\t\tif (!hwAccelerationClass) {\n\t\t\tif (typeof FTScrollerOptions === 'object' && FTScrollerOptions.hwAccelerationClass) {\n\t\t\t\thwAccelerationClass = FTScrollerOptions.hwAccelerationClass;\n\t\t\t} else {\n\t\t\t\thwAccelerationClass = 'ftscroller_hwaccelerated';\n\t\t\t}\n\t\t}\n\n\t\tvar output = '<div class=\"ftscroller_container\">';\n\t\tif (!excludeXAxis) {\n\t\t\toutput += '<div class=\"ftscroller_x ' + hwAccelerationClass + '\">';\n\t\t}\n\t\tif (!excludeYAxis) {\n\t\t\toutput += '<div class=\"ftscroller_y ' + hwAccelerationClass + '\">';\n\t\t}\n\n\t\treturn output;\n\t};\n\n\t/**\n\t * The HTML to append to the scrollable content to wrap it; again, used internally,\n\t * and may be used to pre-wrap scrollable content.\n\t */\n\tFTScroller.prototype.getAppendedHTML = function (excludeXAxis, excludeYAxis, hwAccelerationClass, scrollbars) {\n\t\tif (!hwAccelerationClass) {\n\t\t\tif (typeof FTScrollerOptions === 'object' && FTScrollerOptions.hwAccelerationClass) {\n\t\t\t\thwAccelerationClass = FTScrollerOptions.hwAccelerationClass;\n\t\t\t} else {\n\t\t\t\thwAccelerationClass = 'ftscroller_hwaccelerated';\n\t\t\t}\n\t\t}\n\n\t\tvar output = '';\n\t\tif (!excludeXAxis) {\n\t\t\toutput += '</div>';\n\t\t}\n\t\tif (!excludeYAxis) {\n\t\t\toutput += '</div>';\n\t\t}\n\t\tif (scrollbars) {\n\t\t\tif (!excludeXAxis) {\n\t\t\t\toutput += '<div class=\"ftscroller_scrollbar ftscroller_scrollbarx ' + hwAccelerationClass + '\"><div class=\"ftscroller_scrollbarinner\"></div></div>';\n\t\t\t}\n\t\t\tif (!excludeYAxis) {\n\t\t\t\toutput += '<div class=\"ftscroller_scrollbar ftscroller_scrollbary ' + hwAccelerationClass + '\"><div class=\"ftscroller_scrollbarinner\"></div></div>';\n\t\t\t}\n\t\t}\n\t\toutput += '</div>';\n\n\t\treturn output;\n\t};\n}());\n\n\n(function () {\n\t'use strict';\n\n\tfunction clamp(value) {\n\t\tif (value > 1.0) return 1.0;\n\t\tif (value < 0.0) return 0.0;\n\t\treturn value;\n\t}\n\n\t/**\n\t * Represents a two-dimensional cubic bezier curve with the starting\n\t * point (0, 0) and the end point (1, 1). The two control points p1 and p2\n\t * have x and y coordinates between 0 and 1.\n\t *\n\t * This type of bezier curves can be used as CSS transform timing functions.\n\t */\n\tCubicBezier = function (p1x, p1y, p2x, p2y) {\n\t\t// Control points\n\t\tthis._p1 = { x: clamp(p1x), y: clamp(p1y) };\n\t\tthis._p2 = { x: clamp(p2x), y: clamp(p2y) };\n\t};\n\n\tCubicBezier.prototype._getCoordinateForT = function (t, p1, p2) {\n\t\tvar c = 3 * p1,\n\t\t\tb = 3 * (p2 - p1) - c,\n\t\t\ta = 1 - c - b;\n\n\t\treturn ((a * t + b) * t + c) * t;\n\t};\n\n\tCubicBezier.prototype._getCoordinateDerivateForT = function (t, p1, p2) {\n\t\tvar c = 3 * p1,\n\t\t\tb = 3 * (p2 - p1) - c,\n\t\t\ta = 1 - c - b;\n\n\t\treturn (3 * a * t + 2 * b) * t + c;\n\t};\n\n\tCubicBezier.prototype._getTForCoordinate = function (c, p1, p2, epsilon) {\n\t\tif (!isFinite(epsilon) || epsilon <= 0) {\n\t\t\tthrow new RangeError('\"epsilon\" must be a number greater than 0.');\n\t\t}\n\t\tvar t2, i, c2, d2;\n\n\t\t// First try a few iterations of Newton's method -- normally very fast.\n\t\tfor (t2 = c, i = 0; i < 8; i = i + 1) {\n\t\t\tc2 = this._getCoordinateForT(t2, p1, p2) - c;\n\t\t\tif (Math.abs(c2) < epsilon) {\n\t\t\t\treturn t2;\n\t\t\t}\n\t\t\td2 = this._getCoordinateDerivateForT(t2, p1, p2);\n\t\t\tif (Math.abs(d2) < 1e-6) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tt2 = t2 - c2 / d2;\n\t\t}\n\n\t\t// Fall back to the bisection method for reliability.\n\t\tt2 = c;\n\t\tvar t0 = 0,\n\t\t\tt1 = 1;\n\n\t\tif (t2 < t0) {\n\t\t\treturn t0;\n\t\t}\n\t\tif (t2 > t1) {\n\t\t\treturn t1;\n\t\t}\n\n\t\twhile (t0 < t1) {\n\t\t\tc2 = this._getCoordinateForT(t2, p1, p2);\n\t\t\tif (Math.abs(c2 - c) < epsilon) {\n\t\t\t\treturn t2;\n\t\t\t}\n\t\t\tif (c > c2) {\n\t\t\t\tt0 = t2;\n\t\t\t} else {\n\t\t\t\tt1 = t2;\n\t\t\t}\n\t\t\tt2 = (t1 - t0) * 0.5 + t0;\n\t\t}\n\n\t\t// Failure.\n\t\treturn t2;\n\t};\n\n\t/**\n\t * Computes the point for a given t value.\n\t *\n\t * @param {number} t\n\t * @returns {Object} Returns an object with x and y properties\n\t */\n\tCubicBezier.prototype.getPointForT = function (t) {\n\n\t\t// Special cases: starting and ending points\n\t\tif (t === 0 || t === 1) {\n\t\t\treturn { x: t, y: t };\n\t\t}\n\n\t\t// Check for correct t value (must be between 0 and 1)\n\t\tif (t < 0 || t > 1) {\n\t\t\t_throwRangeError('t', t);\n\t\t}\n\n\t\treturn {\n\t\t\tx: this._getCoordinateForT(t, this._p1.x, this._p2.x),\n\t\t\ty: this._getCoordinateForT(t, this._p1.y, this._p2.y)\n\t\t};\n\t};\n\n\tCubicBezier.prototype.getTForX = function (x, epsilon) {\n\t\treturn this._getTForCoordinate(x, this._p1.x, this._p2.x, epsilon);\n\t};\n\n\tCubicBezier.prototype.getTForY = function (y, epsilon) {\n\t\treturn this._getTForCoordinate(y, this._p1.y, this._p2.y, epsilon);\n\t};\n\n\t/**\n\t * Computes auxiliary points using De Casteljau's algorithm.\n\t *\n\t * @param {number} t must be greater than 0 and lower than 1.\n\t * @returns {Object} with members i0, i1, i2 (first iteration),\n\t *    j1, j2 (second iteration) and k (the exact point for t)\n\t */\n\tCubicBezier.prototype._getAuxPoints = function (t) {\n\t\tif (t <= 0 || t >= 1) {\n\t\t\t_throwRangeError('t', t);\n\t\t}\n\n\n\t\t/* First series of auxiliary points */\n\n\t\t// First control point of the left curve\n\t\tvar i0 = {\n\t\t\t\tx: t * this._p1.x,\n\t\t\t\ty: t * this._p1.y\n\t\t\t},\n\t\t\ti1 = {\n\t\t\t\tx: this._p1.x + t * (this._p2.x - this._p1.x),\n\t\t\t\ty: this._p1.y + t * (this._p2.y - this._p1.y)\n\t\t\t},\n\n\t\t\t// Second control point of the right curve\n\t\t\ti2  = {\n\t\t\t\tx: this._p2.x + t * (1 - this._p2.x),\n\t\t\t\ty: this._p2.y + t * (1 - this._p2.y)\n\t\t\t};\n\n\n\t\t/* Second series of auxiliary points */\n\n\t\t// Second control point of the left curve\n\t\tvar j0 = {\n\t\t\t\tx: i0.x + t * (i1.x - i0.x),\n\t\t\t\ty: i0.y + t * (i1.y - i0.y)\n\t\t\t},\n\n\t\t\t// First control point of the right curve\n\t\t\tj1 = {\n\t\t\t\tx: i1.x + t * (i2.x - i1.x),\n\t\t\t\ty: i1.y + t * (i2.y - i1.y)\n\t\t\t};\n\n\t\t// The division point (ending point of left curve, starting point of right curve)\n\t\tvar k = {\n\t\t\t\tx: j0.x + t * (j1.x - j0.x),\n\t\t\t\ty: j0.y + t * (j1.y - j0.y)\n\t\t\t};\n\n\t\treturn {\n\t\t\ti0: i0,\n\t\t\ti1: i1,\n\t\t\ti2: i2,\n\t\t\tj0: j0,\n\t\t\tj1: j1,\n\t\t\tk: k\n\t\t};\n\t};\n\n\t/**\n\t * Divides the bezier curve into two bezier functions.\n\t *\n\t * De Casteljau's algorithm is used to compute the new starting, ending, and\n\t * control points.\n\t *\n\t * @param {number} t must be greater than 0 and lower than 1.\n\t *     t === 1 or t === 0 are the starting/ending points of the curve, so no\n\t *     division is needed.\n\t *\n\t * @returns {CubicBezier[]} Returns an array containing two bezier curves\n\t *     to the left and the right of t.\n\t */\n\tCubicBezier.prototype.divideAtT = function (t) {\n\t\tif (t < 0 || t > 1) {\n\t\t\t_throwRangeError('t', t);\n\t\t}\n\n\t\t// Special cases t = 0, t = 1: Curve can be cloned for one side, the other\n\t\t// side is a linear curve (with duration 0)\n\t\tif (t === 0 || t === 1) {\n\t\t\tvar curves = [];\n\t\t\tcurves[t] = CubicBezier.linear();\n\t\t\tcurves[1 - t] = this.clone();\n\t\t\treturn curves;\n\t\t}\n\n\t\tvar left = {},\n\t\t\tright = {},\n\t\t\tpoints = this._getAuxPoints(t);\n\n\t\tvar i0 = points.i0,\n\t\t\ti2 = points.i2,\n\t\t\tj0 = points.j0,\n\t\t\tj1 = points.j1,\n\t\t\tk = points.k;\n\n\t\t// Normalize derived points, so that the new curves starting/ending point\n\t\t// coordinates are (0, 0) respectively (1, 1)\n\t\tvar factorX = k.x,\n\t\t\tfactorY = k.y;\n\n\t\tleft.p1 = {\n\t\t\tx: i0.x / factorX,\n\t\t\ty: i0.y / factorY\n\t\t};\n\t\tleft.p2 = {\n\t\t\tx: j0.x / factorX,\n\t\t\ty: j0.y / factorY\n\t\t};\n\n\t\tright.p1 = {\n\t\t\tx: (j1.x - factorX) / (1 - factorX),\n\t\t\ty: (j1.y - factorY) / (1 - factorY)\n\t\t};\n\n\t\tright.p2 = {\n\t\t\tx: (i2.x - factorX) / (1 - factorX),\n\t\t\ty: (i2.y - factorY) / (1 - factorY)\n\t\t};\n\n\t\treturn [\n\t\t\tnew CubicBezier(left.p1.x, left.p1.y, left.p2.x, left.p2.y),\n\t\t\tnew CubicBezier(right.p1.x, right.p1.y, right.p2.x, right.p2.y)\n\t\t];\n\t};\n\n\tCubicBezier.prototype.divideAtX = function (x, epsilon) {\n\t\tif (x < 0 || x > 1) {\n\t\t\t_throwRangeError('x', x);\n\t\t}\n\n\t\tvar t = this.getTForX(x, epsilon);\n\t\treturn this.divideAtT(t);\n\t};\n\n\tCubicBezier.prototype.divideAtY = function (y, epsilon) {\n\t\tif (y < 0 || y > 1) {\n\t\t\t_throwRangeError('y', y);\n\t\t}\n\n\t\tvar t = this.getTForY(y, epsilon);\n\t\treturn this.divideAtT(t);\n\t};\n\n\tCubicBezier.prototype.clone = function () {\n\t\treturn new CubicBezier(this._p1.x, this._p1.y, this._p2.x, this._p2.y);\n\t};\n\n\tCubicBezier.prototype.toString = function () {\n\t\treturn \"cubic-bezier(\" + [\n\t\t\tthis._p1.x,\n\t\t\tthis._p1.y,\n\t\t\tthis._p2.x,\n\t\t\tthis._p2.y\n\t\t].join(\", \") + \")\";\n\t};\n\n\tCubicBezier.linear = function () {\n\t\treturn new CubicBezier();\n\t};\n\n\tCubicBezier.ease = function () {\n\t\treturn new CubicBezier(0.25, 0.1, 0.25, 1.0);\n\t};\n\tCubicBezier.linear = function () {\n\t\treturn new CubicBezier(0.0, 0.0, 1.0, 1.0);\n\t};\n\tCubicBezier.easeIn = function () {\n\t\treturn new CubicBezier(0.42, 0, 1.0, 1.0);\n\t};\n\tCubicBezier.easeOut = function () {\n\t\treturn new CubicBezier(0, 0, 0.58, 1.0);\n\t};\n\tCubicBezier.easeInOut = function () {\n\t\treturn new CubicBezier(0.42, 0, 0.58, 1.0);\n\t};\n}());\n\nif (typeof define !== 'undefined' && define.amd) {\n\t// AMD. Register as an anonymous module.\n\tdefine(function() {\n\t\t'use strict';\n\t\treturn {\n\t\t\tFTScroller: FTScroller,\n\t\t\tCubicBezier: CubicBezier\n\t\t};\n\t});\n} else if (typeof module !== 'undefined' && module.exports) {\n\tmodule.exports = function(domNode, options) {\n\t\t'use strict';\n\t\treturn new FTScroller(domNode, options);\n\t};\n\n\tmodule.exports.FTScroller = FTScroller;\n\tmodule.exports.CubicBezier = CubicBezier;\n}\n","active":false,"path":"/Users/matthew.brennan/Documents/ft-app/node_modules/ftscroller/lib/ftscroller.js","scroll":1246.3277318902497,"cursor":{"row":1319,"column":21}},{"diskText":"/**\n * FTScroller: touch and mouse-based scrolling for DOM elements larger than their containers.\n *\n * While this is a rewrite, it is heavily inspired by two projects:\n * 1) Uxebu TouchScroll (https://github.com/davidaurelio/TouchScroll), BSD licensed:\n *    Copyright (c) 2010 uxebu Consulting Ltd. & Co. KG\n *    Copyright (c) 2010 David Aurelio\n * 2) Zynga Scroller (https://github.com/zynga/scroller), MIT licensed:\n *    Copyright 2011, Zynga Inc.\n *    Copyright 2011, Deutsche Telekom AG\n *\n * Includes CubicBezier:\n *\n * Copyright (C) 2008 Apple Inc. All Rights Reserved.\n * Copyright (C) 2010 David Aurelio. All Rights Reserved.\n * Copyright (C) 2010 uxebu Consulting Ltd. & Co. KG. All Rights Reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY APPLE INC., DAVID AURELIO, AND UXEBU\n * CONSULTING LTD. & CO. KG ``AS IS'' AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL APPLE INC. OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *\n * @copyright The Financial Times Ltd [All rights reserved]\n * @codingstandard ftlabs-jslint\n * @version 0.5.1\n */\n/**\n * @license FTScroller is (c) 2012 The Financial Times Ltd [All rights reserved] and licensed under the MIT license.\n *\n * Inspired by Uxebu TouchScroll, (c) 2010 uxebu Consulting Ltd. & Co. KG and David Aurelio, which is BSD licensed (https://github.com/davidaurelio/TouchScroll)\n * Inspired by Zynga Scroller, (c) 2011 Zynga Inc and Deutsche Telekom AG, which is MIT licensed (https://github.com/zynga/scroller)\n * Includes CubicBezier, (c) 2008 Apple Inc [All rights reserved], (c) 2010 David Aurelio and uxebu Consulting Ltd. & Co. KG. [All rights reserved], which is 2-clause BSD licensed (see above or https://github.com/davidaurelio/TouchScroll).\n */\n\n/*jslint nomen: true, vars: true, browser: true, continue: true, white: true*/\n/*globals FTScrollerOptions*/\n\nvar FTScroller, CubicBezier;\n\n(function () {\n\t'use strict';\n\n\t// Determine the browser engine and prefix, trying to use the unprefixed version where available.\n\tvar _vendorCSSPrefix, _vendorStylePropertyPrefix, _vendorTransformLookup,\n\t\t_pointerEventsPrefixed, _setPointerCapture, _releasePointerCapture, _lostPointerCapture, _trackPointerEvents, _pointerTypeTouch;\n\tif (document.createElement('div').style.transform !== undefined) {\n\t\t_vendorCSSPrefix = '';\n\t\t_vendorStylePropertyPrefix = '';\n\t\t_vendorTransformLookup = 'transform';\n\t} else if (window.opera && Object.prototype.toString.call(window.opera) === '[object Opera]') {\n\t\t_vendorCSSPrefix = '-o-';\n\t\t_vendorStylePropertyPrefix = 'O';\n\t\t_vendorTransformLookup = 'OTransform';\n\t} else if (document.documentElement.style.MozTransform !== undefined) {\n\t\t_vendorCSSPrefix = '-moz-';\n\t\t_vendorStylePropertyPrefix = 'Moz';\n\t\t_vendorTransformLookup = 'MozTransform';\n\t} else if (document.documentElement.style.webkitTransform !== undefined) {\n\t\t_vendorCSSPrefix = '-webkit-';\n\t\t_vendorStylePropertyPrefix = 'webkit';\n\t\t_vendorTransformLookup = '-webkit-transform';\n\t} else if (typeof navigator.cpuClass === 'string') {\n\t\t_vendorCSSPrefix = '-ms-';\n\t\t_vendorStylePropertyPrefix = 'ms';\n\t\t_vendorTransformLookup = '-ms-transform';\n\t}\n\n\t// Pointer Events are unprefixed in IE11\n\tif ('pointerEnabled' in window.navigator) {\n\t\t_pointerEventsPrefixed = false;\n\t\t_trackPointerEvents    = window.navigator.pointerEnabled;\n\t\t_setPointerCapture     = 'setPointerCapture';\n\t\t_releasePointerCapture = 'releasePointerCapture';\n\t\t_lostPointerCapture    = 'lostpointercapture';\n\t\t_pointerTypeTouch      = 'touch';\n\t} else if ('msPointerEnabled' in window.navigator) {\n\t\t_pointerEventsPrefixed = true;\n\t\t_trackPointerEvents    = window.navigator.msPointerEnabled;\n\t\t_setPointerCapture     = 'msSetPointerCapture';\n\t\t_releasePointerCapture = 'msReleasePointerCapture';\n\t\t_lostPointerCapture    = 'MSLostPointerCapture';\n\t\t_pointerTypeTouch      = 2; // PointerEvent.MSPOINTER_TYPE_TOUCH = 2 in IE10\n\t}\n\n\t// Global flag to determine if any scroll is currently active.  This prevents\n\t// issues when using multiple scrollers, particularly when they're nested.\n\tvar _ftscrollerMoving = false;\n\n\t// Determine whether pointer events or touch events can be used\n\tvar _trackTouchEvents = false;\n\tif ('propertyIsEnumerable' in window || 'hasOwnProperty' in window.document) {\n\t\t_trackTouchEvents = !_trackPointerEvents && (window.propertyIsEnumerable('ontouchstart') || window.document.hasOwnProperty('ontouchstart'));\n\t}\n\n\t// Determine whether to use modern hardware acceleration rules or dynamic/toggleable rules.\n\t// Certain older browsers - particularly Android browsers - have problems with hardware\n\t// acceleration, so being able to toggle the behaviour dynamically via a CSS cascade is desirable.\n\tvar _useToggleableHardwareAcceleration = false;\n\tif ('hasOwnProperty' in window) {\n\t\t_useToggleableHardwareAcceleration = !window.hasOwnProperty('ArrayBuffer');\n\t}\n\n\t// Feature detection\n\tvar _canClearSelection = (window.Selection && window.Selection.prototype.removeAllRanges);\n\n\t// If hardware acceleration is using the standard path, but perspective doesn't seem to be supported,\n\t// 3D transforms likely aren't supported either\n\tif (!_useToggleableHardwareAcceleration && document.createElement('div').style[_vendorStylePropertyPrefix + (_vendorStylePropertyPrefix ? 'P' : 'p') + 'erspective'] === undefined) {\n\t\t_useToggleableHardwareAcceleration = true;\n\t}\n\n\t// Style prefixes\n\tvar _transformProperty = _vendorStylePropertyPrefix + (_vendorStylePropertyPrefix ? 'T' : 't') + 'ransform';\n\tvar _transitionProperty = _vendorStylePropertyPrefix + (_vendorStylePropertyPrefix ? 'T' : 't') + 'ransition';\n\tvar _translateRulePrefix = _useToggleableHardwareAcceleration ? 'translate(' : 'translate3d(';\n\tvar _transformPrefixes = { x: '', y: '0,' };\n\tvar _transformSuffixes = { x: ',0' + (_useToggleableHardwareAcceleration ? ')' : ',0)'), y: (_useToggleableHardwareAcceleration ? ')' : ',0)') };\n\n\t// Constants.  Note that the bezier curve should be changed along with the friction!\n\tvar _kFriction = 0.998;\n\tvar _kMinimumSpeed = 0.01;\n\n\t// Create a global stylesheet to set up stylesheet rules and track dynamic entries\n\t(function () {\n\t\tvar stylesheetContainerNode = document.getElementsByTagName('head')[0] || document.documentElement;\n\t\tvar newStyleNode = document.createElement('style');\n\t\tvar hardwareAccelerationRule;\n\t\tvar _styleText;\n\t\tnewStyleNode.type = 'text/css';\n\n\t\t// Determine the hardware acceleration logic to use\n\t\tif (_useToggleableHardwareAcceleration) {\n\t\t\thardwareAccelerationRule = _vendorCSSPrefix + 'transform-style: preserve-3d;';\n\t\t} else {\n\t\t\thardwareAccelerationRule = _vendorCSSPrefix + 'transform: translateZ(0);';\n\t\t}\n\n\t\t// Add our rules\n\t\t_styleText = [\n\t\t\t'.ftscroller_container { overflow: hidden; position: relative; max-height: 100%; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); -ms-touch-action: none }',\n\t\t\t'.ftscroller_hwaccelerated { ' + hardwareAccelerationRule  + ' }',\n\t\t\t'.ftscroller_x, .ftscroller_y { position: relative; min-width: 100%; min-height: 100%; overflow: hidden }',\n\t\t\t'.ftscroller_x { display: inline-block }',\n\t\t\t'.ftscroller_scrollbar { pointer-events: none; position: absolute; width: 5px; height: 5px; border: 1px solid rgba(255, 255, 255, 0.3); -webkit-border-radius: 3px; border-radius: 6px; opacity: 0; ' + _vendorCSSPrefix + 'transition: opacity 350ms; z-index: 10; -webkit-box-sizing: content-box; -moz-box-sizing: content-box; box-sizing: content-box }',\n\t\t\t'.ftscroller_scrollbarx { bottom: 2px; left: 2px }',\n\t\t\t'.ftscroller_scrollbary { right: 2px; top: 2px }',\n\t\t\t'.ftscroller_scrollbarinner { height: 100%; background: #000; -webkit-border-radius: 2px; border-radius: 4px / 6px }',\n\t\t\t'.ftscroller_scrollbar.active { opacity: 0.5; ' + _vendorCSSPrefix + 'transition: none; -o-transition: all 0 none }'\n\t\t];\n\n\t\tif (newStyleNode.styleSheet) {\n\t\t\tnewStyleNode.styleSheet.cssText = _styleText.join('\\n');\n\t\t} else {\n\t\t\tnewStyleNode.appendChild(document.createTextNode(_styleText.join('\\n')));\n\t\t}\n\n\t\t// Add the stylesheet\n\t\tstylesheetContainerNode.insertBefore(newStyleNode, stylesheetContainerNode.firstChild);\n\t}());\n\n\t/**\n\t * Master constructor for the scrolling function, including which element to\n\t * construct the scroller in, and any scrolling options.\n\t * Note that app-wide options can also be set using a global FTScrollerOptions\n\t * object.\n\t */\n\tFTScroller = function (domNode, options) {\n\t\tvar key;\n\t\tvar destroy, setSnapSize, scrollTo, scrollBy, updateDimensions, addEventListener, removeEventListener, setDisabledInputMethods, _startScroll, _updateScroll, _endScroll, _finalizeScroll, _interruptScroll, _flingScroll, _snapScroll, _getSnapPositionForIndexes, _getSnapIndexForPosition, _constrainAndRenderTargetScrollPosition, _limitToBounds, _initializeDOM, _existingDOMValid, _domChanged, _updateDimensions, _updateScrollbarDimensions, _updateElementPosition, _updateSegments, _setAxisPosition, _getPosition, _scheduleAxisPosition, _fireEvent, _childFocused, _modifyDistanceBeyondBounds, _distancesBeyondBounds, _startAnimation, _scheduleRender, _cancelAnimation, _addEventHandlers, _removeEventHandlers, _resetEventHandlers, _onTouchStart, _onTouchMove, _onTouchEnd, _onMouseDown, _onMouseMove, _onMouseUp, _onPointerDown, _onPointerMove, _onPointerUp, _onPointerCancel, _onPointerCaptureEnd, _onClick, _onMouseScroll, _captureInput, _releaseInputCapture, _getBoundingRect;\n\n\n\t\t/* Note that actual object instantiation occurs at the end of the closure to avoid jslint errors */\n\n\n\t\t/*                         Options                       */\n\n\t\tvar _instanceOptions = {\n\n\t\t\t// Whether to display scrollbars as appropriate\n\t\t\tscrollbars: true,\n\n\t\t\t// Enable scrolling on the X axis if content is available\n\t\t\tscrollingX: true,\n\n\t\t\t// Enable scrolling on the Y axis if content is available\n\t\t\tscrollingY: true,\n\n\t\t\t// The initial movement required to trigger a scroll, in pixels; this is the point at which\n\t\t\t// the scroll is exclusive to this particular FTScroller instance.\n\t\t\tscrollBoundary: 1,\n\n\t\t\t// The initial movement required to trigger a visual indication that scrolling is occurring,\n\t\t\t// in pixels.  This is enforced to be less than or equal to the scrollBoundary, and is used to\n\t\t\t// define when the scroller starts drawing changes in response to an input, even if the scroll\n\t\t\t// is not treated as having begun/locked yet.\n\t\t\tscrollResponseBoundary: 1,\n\n\t\t\t// Whether to always enable scrolling, even if the content of the scroller does not\n\t\t\t// require the scroller to function.  This makes the scroller behave more like an\n\t\t\t// element set to \"overflow: scroll\", with bouncing always occurring if enabled.\n\t\t\talwaysScroll: false,\n\n\t\t\t// The content width to use when determining scroller dimensions.  If this\n\t\t\t// is false, the width will be detected based on the actual content.\n\t\t\tcontentWidth: undefined,\n\n\t\t\t// The content height to use when determining scroller dimensions.  If this\n\t\t\t// is false, the height will be detected based on the actual content.\n\t\t\tcontentHeight: undefined,\n\n\t\t\t// Enable snapping of content to 'pages' or a pixel grid\n\t\t\tsnapping: false,\n\n\t\t\t// Define the horizontal interval of the pixel grid; snapping must be enabled for this to\n\t\t\t// take effect.  If this is not defined, snapping will use intervals based on container size.\n\t\t\tsnapSizeX: undefined,\n\n\t\t\t// Define the vertical interval of the pixel grid; snapping must be enabled for this to\n\t\t\t// take effect.  If this is not defined, snapping will use intervals based on container size.\n\t\t\tsnapSizeY: undefined,\n\n\t\t\t// Control whether snapping should be curtailed to only ever flick to the next page\n\t\t\t// and not beyond.  Snapping needs to be enabled for this to take effect.\n\t\t\tsinglePageScrolls: false,\n\n\t\t\t// Allow scroll bouncing and elasticity near the ends and grid\n\t\t\tbouncing: true,\n\n\t\t\t// Allow a fast scroll to continue with momentum when released\n\t\t\tflinging: true,\n\n\t\t\t// Automatically detects changes to the contained markup and\n\t\t\t// updates its dimensions whenever the content changes. This is\n\t\t\t// set to false if a contentWidth or contentHeight are supplied.\n\t\t\tupdateOnChanges: true,\n\n\t\t\t// Automatically catches changes to the window size and updates\n\t\t\t// its dimensions.\n\t\t\tupdateOnWindowResize: false,\n\n\t\t\t// The alignment to use if the content is smaller than the container;\n\t\t\t// this also applies to initial positioning of scrollable content.\n\t\t\t// Valid alignments are -1 (top or left), 0 (center), and 1 (bottom or right).\n\t\t\tbaseAlignments: { x: -1, y: -1 },\n\n\t\t\t// Whether to use a window scroll flag, eg window.foo, to control whether\n\t\t\t// to allow scrolling to start or now.  If the window flag is set to true,\n\t\t\t// this element will not start scrolling; this element will also toggle\n\t\t\t// the variable while scrolling\n\t\t\twindowScrollingActiveFlag: undefined,\n\n\t\t\t// Instead of always using translate3d for transforms, a mix of translate3d\n\t\t\t// and translate with a hardware acceleration class used to trigger acceleration\n\t\t\t// is used; this is to allow CSS inheritance to be used to allow dynamic\n\t\t\t// disabling of backing layers on older platforms.\n\t\t\thwAccelerationClass: 'ftscroller_hwaccelerated',\n\n\t\t\t// While use of requestAnimationFrame is highly recommended on platforms\n\t\t\t// which support it, it can result in the animation being a further half-frame\n\t\t\t// behind the input method, increasing perceived lag slightly.  To disable this,\n\t\t\t// set this property to false.\n\t\t\tenableRequestAnimationFrameSupport: true,\n\n\t\t\t// Set the maximum time (ms) that a fling can take to complete; if\n\t\t\t// this is not set, flings will complete instantly\n\t\t\tmaxFlingDuration: 1000,\n\n\t\t\t// Whether to disable any input methods; on some multi-input devices\n\t\t\t// custom behaviour may be desired for some scrollers.  Use with care!\n\t\t\tdisabledInputMethods: {\n\t\t\t\tmouse: false,\n\t\t\t\ttouch: false,\n\t\t\t\tscroll: false,\n\t\t\t\tpointer: false,\n\t\t\t\tfocus: false\n\t\t\t},\n\n\t\t\t// Define a scrolling class to be added to the scroller container\n\t\t\t// when scrolling is active.  Note that this can cause a relayout on\n\t\t\t// scroll start if defined, but allows custom styling in response to scrolls\n\t\t\tscrollingClassName: undefined,\n\n\t\t\t// Bezier curves defining the feel of the fling (momentum) deceleration,\n\t\t\t// the bounce decleration deceleration (as a fling exceeds the bounds),\n\t\t\t// and the bounce bezier (used for bouncing back).\n\t\t\tflingBezier: new CubicBezier(0.103, 0.389, 0.307, 0.966),\n\t\t\tbounceDecelerationBezier: new CubicBezier(0, 0.5, 0.5, 1),\n\t\t\tbounceBezier: new CubicBezier(0.7, 0, 0.9, 0.6)\n\t\t};\n\n\n\t\t/*                     Local variables                   */\n\n\t\t// Cache the DOM node and set up variables for other nodes\n\t\tvar _publicSelf;\n\t\tvar _self = this;\n\t\tvar _scrollableMasterNode = domNode;\n\t\tvar _containerNode;\n\t\tvar _contentParentNode;\n\t\tvar _scrollNodes = { x: null, y: null };\n\t\tvar _scrollbarNodes = { x: null, y: null };\n\n\t\t// Dimensions of the container element and the content element\n\t\tvar _metrics = {\n\t\t\tcontainer: { x: null, y: null },\n\t\t\tcontent: { x: null, y: null, rawX: null, rawY: null },\n\t\t\tscrollEnd: { x: null, y: null }\n\t\t};\n\n\t\t// Snapping details\n\t\tvar _snapGridSize = {\n\t\t\tx: false,\n\t\t\ty: false,\n\t\t\tuserX: false,\n\t\t\tuserY: false\n\t\t};\n\t\tvar _snapIndex = {\n\t\t\tx: 0,\n\t\t\ty: 0\n\t\t};\n\t\tvar _baseSegment = { x: 0, y: 0 };\n\t\tvar _activeSegment = { x: 0, y: 0 };\n\n\t\t// Track the identifier of any input being tracked\n\t\tvar _inputIdentifier = false;\n\t\tvar _inputIndex = 0;\n\t\tvar _inputCaptured = false;\n\n\t\t// Current scroll positions and tracking\n\t\tvar _isScrolling = false;\n\t\tvar _isDisplayingScroll = false;\n\t\tvar _isAnimating = false;\n\t\tvar _baseScrollPosition = { x: 0, y: 0 };\n\t\tvar _lastScrollPosition = { x: 0, y: 0 };\n\t\tvar _targetScrollPosition = { x: 0, y: 0 };\n\t\tvar _scrollAtExtremity = { x: null, y: null };\n\t\tvar _preventClick = false;\n\t\tvar _timeouts = [];\n\t\tvar _hasBeenScrolled = false;\n\n\t\t// Gesture details\n\t\tvar _baseScrollableAxes = {};\n\t\tvar _scrollableAxes = { x: true, y: true };\n\t\tvar _gestureStart = { x: 0, y: 0, t: 0 };\n\t\tvar _cumulativeScroll = { x: 0, y: 0 };\n\t\tvar _eventHistory = [];\n\n\t\t// Allow certain events to be debounced\n\t\tvar _domChangeDebouncer = false;\n\t\tvar _scrollWheelEndDebouncer = false;\n\n\t\t// Performance switches on browsers supporting requestAnimationFrame\n\t\tvar _animationFrameRequest = false;\n\t\tvar _reqAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || false;\n\t\tvar _cancelAnimationFrame = window.cancelAnimationFrame || window.cancelRequestAnimationFrame || window.mozCancelAnimationFrame || window.mozCancelRequestAnimationFrame || window.webkitCancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.msCancelAnimationFrame || window.msCancelRequestAnimationFrame || false;\n\n\t\t// Event listeners\n\t\tvar _eventListeners = {\n\t\t\t'scrollstart': [],\n\t\t\t'scroll': [],\n\t\t\t'scrollend': [],\n\t\t\t'segmentwillchange': [],\n\t\t\t'segmentdidchange': [],\n\t\t\t'reachedstart': [],\n\t\t\t'reachedend': [],\n\t\t\t'scrollinteractionend': []\n\t\t};\n\n\t\t// MutationObserver instance, when supported and if DOM change sniffing is enabled\n\t\tvar _mutationObserver;\n\n\n\t\t/* Parsing supplied options */\n\n\t\t// Override default instance options with global - or closure'd - options\n\t\tif (typeof FTScrollerOptions === 'object' && FTScrollerOptions) {\n\t\t\tfor (key in FTScrollerOptions) {\n\t\t\t\tif (FTScrollerOptions.hasOwnProperty(key) && _instanceOptions.hasOwnProperty(key)) {\n\t\t\t\t\t_instanceOptions[key] = FTScrollerOptions[key];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Override default and global options with supplied options\n\t\tif (options) {\n\t\t\tfor (key in options) {\n\t\t\t\tif (options.hasOwnProperty(key)) {\n\n\t\t\t\t\t// If a deprecated flag was passed in, warn, and convert to the new flag name\n\t\t\t\t\tif ('paginatedSnap' === key) {\n\t\t\t\t\t\tconsole.warn('FTScroller: \"paginatedSnap\" is deprecated; converting to \"singlePageScrolls\"');\n\t\t\t\t\t\t_instanceOptions.singlePageScrolls = options.paginatedSnap;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (_instanceOptions.hasOwnProperty(key)) {\n\t\t\t\t\t\t_instanceOptions[key] = options[key];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If snap grid size options were supplied, store them\n\t\t\tif (options.hasOwnProperty('snapSizeX') && !isNaN(options.snapSizeX)) {\n\t\t\t\t_snapGridSize.userX = _snapGridSize.x = options.snapSizeX;\n\t\t\t}\n\t\t\tif (options.hasOwnProperty('snapSizeY') && !isNaN(options.snapSizeY)) {\n\t\t\t\t_snapGridSize.userY = _snapGridSize.y = options.snapSizeY;\n\t\t\t}\n\n\t\t\t// If content width and height were defined, disable updateOnChanges for performance\n\t\t\tif (options.contentWidth && options.contentHeight) {\n\t\t\t\toptions.updateOnChanges = false;\n\t\t\t}\n\t\t}\n\n\t\t// Validate the scroll response parameter\n\t\t_instanceOptions.scrollResponseBoundary = Math.min(_instanceOptions.scrollBoundary, _instanceOptions.scrollResponseBoundary);\n\n\t\t// Update base scrollable axes\n\t\tif (_instanceOptions.scrollingX) {\n\t\t\t_baseScrollableAxes.x = true;\n\t\t}\n\t\tif (_instanceOptions.scrollingY) {\n\t\t\t_baseScrollableAxes.y = true;\n\t\t}\n\n\t\t// Only enable animation frame support if the instance options permit it\n\t\t_reqAnimationFrame = _instanceOptions.enableRequestAnimationFrameSupport && _reqAnimationFrame;\n\t\t_cancelAnimationFrame = _reqAnimationFrame && _cancelAnimationFrame;\n\n\n\t\t/*                    Scoped Functions                   */\n\n\t\t/**\n\t\t * Unbinds all event listeners to prevent circular references preventing items\n\t\t * from being deallocated, and clean up references to dom elements. Pass in\n\t\t * \"removeElements\" to also remove FTScroller DOM elements for special reuse cases.\n\t\t */\n\t\tdestroy = function destroy(removeElements) {\n\t\t\tvar i, l;\n\n\t\t\t_removeEventHandlers();\n\t\t\t_cancelAnimation();\n\t\t\tif (_domChangeDebouncer) {\n\t\t\t\twindow.clearTimeout(_domChangeDebouncer);\n\t\t\t\t_domChangeDebouncer = false;\n\t\t\t}\n\t\t\tfor (i = 0, l = _timeouts.length; i < l; i = i + 1) {\n\t\t\t\twindow.clearTimeout(_timeouts[i]);\n\t\t\t}\n\t\t\t_timeouts.length = 0;\n\n\t\t\t// Destroy DOM elements if required\n\t\t\tif (removeElements && _scrollableMasterNode) {\n\t\t\t\twhile (_contentParentNode.firstChild) {\n\t\t\t\t\t_scrollableMasterNode.appendChild(_contentParentNode.firstChild);\n\t\t\t\t}\n\t\t\t\t_scrollableMasterNode.removeChild(_containerNode);\n\t\t\t}\n\n\t\t\t_scrollableMasterNode = null;\n\t\t\t_containerNode = null;\n\t\t\t_contentParentNode = null;\n\t\t\t_scrollNodes.x = null;\n\t\t\t_scrollNodes.y = null;\n\t\t\t_scrollbarNodes.x = null;\n\t\t\t_scrollbarNodes.y = null;\n\t\t\tfor (i in _eventListeners) {\n\t\t\t\tif (_eventListeners.hasOwnProperty(i)) {\n\t\t\t\t\t_eventListeners[i].length = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If this is currently tracked as a scrolling instance, clear the flag\n\t\t\tif (_ftscrollerMoving && _ftscrollerMoving === _self) {\n\t\t\t\t_ftscrollerMoving = false;\n\t\t\t\tif (_instanceOptions.windowScrollingActiveFlag) {\n\t\t\t\t\twindow[_instanceOptions.windowScrollingActiveFlag] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Configures the snapping boundaries within the scrolling element if\n\t\t * snapping is active.  If this is never called, snapping defaults to\n\t\t * using the bounding box, eg page-at-a-time.\n\t\t */\n\t\tsetSnapSize = function setSnapSize(width, height) {\n\t\t\t_snapGridSize.userX = width;\n\t\t\t_snapGridSize.userY = height;\n\t\t\t_snapGridSize.x = width;\n\t\t\t_snapGridSize.y = height;\n\n\t\t\t// Ensure the content dimensions conform to the grid\n\t\t\t_metrics.content.x = Math.ceil(_metrics.content.rawX / width) * width;\n\t\t\t_metrics.content.y = Math.ceil(_metrics.content.rawY / height) * height;\n\t\t\t_metrics.scrollEnd.x = _metrics.container.x - _metrics.content.x;\n\t\t\t_metrics.scrollEnd.y = _metrics.container.y - _metrics.content.y;\n\t\t\t_updateScrollbarDimensions();\n\n\t\t\t// Snap to the new grid if necessary\n\t\t\t_snapScroll();\n\t\t\t_updateSegments(true);\n\t\t};\n\n\t\t/**\n\t\t * Scroll to a supplied position, including whether or not to animate the\n\t\t * scroll and how fast to perform the animation (pass in true to select a\n\t\t * dynamic duration).  The inputs will be constrained to bounds and snapped.\n\t\t * If false is supplied for a position, that axis will not be scrolled.\n\t\t */\n\t\tscrollTo = function scrollTo(left, top, animationDuration) {\n\t\t\tvar targetPosition, duration, positions, axis, maxDuration = 0, scrollPositionsToApply = {};\n\n\t\t\t// If a manual scroll is in progress, cancel it\n\t\t\t_endScroll(Date.now());\n\n\t\t\t// Move supplied coordinates into an object for iteration, also inverting the values into\n\t\t\t// our coordinate system\n\t\t\tpositions = {\n\t\t\t\tx: -left,\n\t\t\t\ty: -top\n\t\t\t};\n\n\t\t\tfor (axis in _baseScrollableAxes) {\n\t\t\t\tif (_baseScrollableAxes.hasOwnProperty(axis)) {\n\t\t\t\t\ttargetPosition = positions[axis];\n\t\t\t\t\tif (targetPosition === false) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Constrain to bounds\n\t\t\t\t\ttargetPosition = Math.min(0, Math.max(_metrics.scrollEnd[axis], targetPosition));\n\n\t\t\t\t\t// Snap if appropriate\n\t\t\t\t\tif (_instanceOptions.snapping && _snapGridSize[axis]) {\n\t\t\t\t\t\ttargetPosition = Math.round(targetPosition / _snapGridSize[axis]) * _snapGridSize[axis];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Get a duration\n\t\t\t\t\tduration = animationDuration || 0;\n\t\t\t\t\tif (duration === true) {\n\t\t\t\t\t\tduration = Math.sqrt(Math.abs(_baseScrollPosition[axis] - targetPosition)) * 20;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Trigger the position change\n\t\t\t\t\t_setAxisPosition(axis, targetPosition, duration);\n\t\t\t\t\tscrollPositionsToApply[axis] = targetPosition;\n\t\t\t\t\tmaxDuration = Math.max(maxDuration, duration);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If the scroll had resulted in a change in position, perform some additional actions:\n\t\t\tif (_baseScrollPosition.x !== positions.x || _baseScrollPosition.y !== positions.y) {\n\n\t\t\t\t// Mark a scroll as having ever occurred\n\t\t\t\t_hasBeenScrolled = true;\n\n\t\t\t\t// If an animation duration is present, fire a scroll start event and a\n\t\t\t\t// scroll event for any listeners to act on\n\t\t\t\t_fireEvent('scrollstart', _getPosition());\n\t\t\t\tconsole.log('firing scroll event from scrollTo');\n\t\t\t\t_fireEvent('scroll', _getPosition());\n\t\t\t}\n\n\t\t\tif (maxDuration) {\n\t\t\t\t_timeouts.push(setTimeout(function () {\n\t\t\t\t\tvar anAxis;\n\t\t\t\t\tfor (anAxis in scrollPositionsToApply) {\n\t\t\t\t\t\tif (scrollPositionsToApply.hasOwnProperty(anAxis)) {\n\t\t\t\t\t\t\t_lastScrollPosition[anAxis] = scrollPositionsToApply[anAxis];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t_finalizeScroll();\n\t\t\t\t}, maxDuration));\n\t\t\t} else {\n\t\t\t\t_finalizeScroll();\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Alter the current scroll position, including whether or not to animate\n\t\t * the scroll and how fast to perform the animation (pass in true to\n\t\t * select a dynamic duration).  The inputs will be checked against the\n\t\t * current position.\n\t\t */\n\t\tscrollBy = function scrollBy(horizontal, vertical, animationDuration) {\n\n\t\t\t// Wrap the scrollTo function for simplicity\n\t\t\tscrollTo(parseFloat(horizontal) - _baseScrollPosition.x, parseFloat(vertical) - _baseScrollPosition.y, animationDuration);\n\t\t};\n\n\t\t/**\n\t\t * Provide a public method to detect changes in dimensions for either the content or the\n\t\t * container.\n\t\t */\n\t\tupdateDimensions = function updateDimensions(contentWidth, contentHeight, ignoreSnapScroll) {\n\t\t\toptions.contentWidth = contentWidth || options.contentWidth;\n\t\t\toptions.contentHeight = contentHeight || options.contentHeight;\n\n\t\t\t// Currently just wrap the private API\n\t\t\t_updateDimensions(!!ignoreSnapScroll);\n\t\t};\n\n\t\t/**\n\t\t * Add an event handler for a supported event.  Current events include:\n\t\t * scroll - fired whenever the scroll position changes\n\t\t * scrollstart - fired when a scroll movement starts\n\t\t * scrollend - fired when a scroll movement ends\n\t\t * segmentwillchange - fired whenever the segment changes, including during scrolling\n\t\t * segmentdidchange - fired when a segment has conclusively changed, after scrolling.\n\t\t */\n\t\taddEventListener = function addEventListener(eventname, eventlistener) {\n\n\t\t\t// Ensure this is a valid event\n\t\t\tif (!_eventListeners.hasOwnProperty(eventname)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Add the listener\n\t\t\t_eventListeners[eventname].push(eventlistener);\n\t\t\treturn true;\n\t\t};\n\n\t\t/**\n\t\t * Remove an event handler for a supported event.  The listener must be exactly the same as\n\t\t * an added listener to be removed.\n\t\t */\n\t\tremoveEventListener = function removeEventListener(eventname, eventlistener) {\n\t\t\tvar i;\n\n\t\t\t// Ensure this is a valid event\n\t\t\tif (!_eventListeners.hasOwnProperty(eventname)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tfor (i = _eventListeners[eventname].length; i >= 0; i = i - 1) {\n\t\t\t\tif (_eventListeners[eventname][i] === eventlistener) {\n\t\t\t\t\t_eventListeners[eventname].splice(i, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\n\t\t/**\n\t\t * Set the input methods to disable. No inputs methods are disabled by default.\n\t\t * (object, default { mouse: false, touch: false, scroll: false, pointer: false, focus: false })\n\t\t */\n\t\tsetDisabledInputMethods = function setDisabledInputMethods(disabledInputMethods) {\n\t\t\tvar i, changed;\n\n\t\t\tfor (i in _instanceOptions.disabledInputMethods) {\n\t\t\t\tdisabledInputMethods[i] = !!disabledInputMethods[i];\n\n\t\t\t\tif (_instanceOptions.disabledInputMethods[i] !== disabledInputMethods[i]) changed = true;\n\t\t\t\t_instanceOptions.disabledInputMethods[i] = disabledInputMethods[i];\n\t\t\t}\n\n\t\t\tif (changed) {\n\t\t\t\t_resetEventHandlers();\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Start a scroll tracking input - this could be mouse, webkit-style touch,\n\t\t * or ms-style pointer events.\n\t\t */\n\t\t_startScroll = function _startScroll(inputX, inputY, inputTime, rawEvent) {\n\t\t\tvar triggerScrollInterrupt = _isAnimating;\n\n\t\t\t// Opera fix\n\t\t\tif (inputTime <= 0) {\n\t\t\t\tinputTime = Date.now();\n\t\t\t}\n\n\t\t\t// If a window scrolling flag is set, and evaluates to true, don't start checking touches\n\t\t\tif (_instanceOptions.windowScrollingActiveFlag && window[_instanceOptions.windowScrollingActiveFlag]) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// If an animation is in progress, stop the scroll.\n\t\t\tif (triggerScrollInterrupt) {\n\t\t\t\t_interruptScroll();\n\t\t\t} else {\n\n\t\t\t\t// Allow clicks again, but only if a scroll was not interrupted\n\t\t\t\t_preventClick = false;\n\t\t\t}\n\n\t\t\t// Store the initial event coordinates\n\t\t\t_gestureStart.x = inputX;\n\t\t\t_gestureStart.y = inputY;\n\t\t\t_gestureStart.t = inputTime;\n\t\t\t_targetScrollPosition.x = _lastScrollPosition.x;\n\t\t\t_targetScrollPosition.y = _lastScrollPosition.y;\n\n\t\t\t// Clear event history and add the start touch\n\t\t\t_eventHistory.length = 0;\n\t\t\t_eventHistory.push({ x: inputX, y: inputY, t: inputTime });\n\n\t\t\tif (triggerScrollInterrupt) {\n\t\t\t\t_updateScroll(inputX, inputY, inputTime, rawEvent, triggerScrollInterrupt);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t};\n\n\t\t/**\n\t\t * Continue a scroll as a result of an updated position\n\t\t */\n\t\t_updateScroll = function _updateScroll(inputX, inputY, inputTime, rawEvent, scrollInterrupt) {\n\t\t\tvar axis, otherScrollerActive, distancesBeyondBounds;\n\t\t\tvar initialScroll = false;\n\t\t\tvar gesture = {\n\t\t\t\tx: inputX - _gestureStart.x,\n\t\t\t\ty: inputY - _gestureStart.y\n\t\t\t};\n\n\t\t\t// Opera fix\n\t\t\tif (inputTime <= 0) {\n\t\t\t\tinputTime = Date.now();\n\t\t\t}\n\n\t\t\t// Update base target positions\n\t\t\t_targetScrollPosition.x = _baseScrollPosition.x + gesture.x;\n\t\t\t_targetScrollPosition.y = _baseScrollPosition.y + gesture.y;\n\n\t\t\t// If scrolling has not yet locked to this scroller, check whether to stop scrolling\n\t\t\tif (!_isScrolling) {\n\n\t\t\t\t// Check the internal flag to determine if another FTScroller is scrolling\n\t\t\t\tif (_ftscrollerMoving && _ftscrollerMoving !== _self) {\n\t\t\t\t\totherScrollerActive = true;\n\t\t\t\t}\n\n\t\t\t\t// Otherwise, check the window scrolling flag to see if anything else has claimed scrolling\n\t\t\t\telse if (_instanceOptions.windowScrollingActiveFlag && window[_instanceOptions.windowScrollingActiveFlag]) {\n\t\t\t\t\totherScrollerActive = true;\n\t\t\t\t}\n\n\t\t\t\t// If another scroller was active, clean up and stop processing.\n\t\t\t\tif (otherScrollerActive) {\n\t\t\t\t\t_releaseInputCapture();\n\t\t\t\t\t_inputIdentifier = false;\n\t\t\t\t\tif (_isDisplayingScroll) {\n\t\t\t\t\t\t_cancelAnimation();\n\t\t\t\t\t\tif (!_snapScroll(true)) {\n\t\t\t\t\t\t\t_finalizeScroll(true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If not yet displaying a scroll, determine whether that triggering boundary\n\t\t\t// has been exceeded\n\t\t\tif (!_isDisplayingScroll) {\n\n\t\t\t\t// Determine scroll distance beyond bounds\n\t\t\t\tdistancesBeyondBounds = _distancesBeyondBounds(_targetScrollPosition);\n\n\t\t\t\t// Determine whether to prevent the default scroll event - if the scroll could still\n\t\t\t\t// be triggered, prevent the default to avoid problems (particularly on PlayBook)\n\t\t\t\tif (_instanceOptions.bouncing || scrollInterrupt || (_scrollableAxes.x && gesture.x && distancesBeyondBounds.x < 0) || (_scrollableAxes.y && gesture.y && distancesBeyondBounds.y < 0)) {\n\t\t\t\t\trawEvent.preventDefault();\n\t\t\t\t}\n\n\t\t\t\t// Check scrolled distance against the boundary limit to see if scrolling can be triggered.\n\t\t\t\t// If the scroll has been interrupted, trigger at once\n\t\t\t\tif (!scrollInterrupt && (!_scrollableAxes.x || Math.abs(gesture.x) < _instanceOptions.scrollResponseBoundary) && (!_scrollableAxes.y || Math.abs(gesture.y) < _instanceOptions.scrollResponseBoundary)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// If bouncing is disabled, and already at an edge and scrolling beyond the edge, ignore the scroll for\n\t\t\t\t// now - this allows other scrollers to claim if appropriate, allowing nicer nested scrolls.\n\t\t\t\tif (!_instanceOptions.bouncing && !scrollInterrupt && (!_scrollableAxes.x || !gesture.x || distancesBeyondBounds.x > 0) && (!_scrollableAxes.y || !gesture.y || distancesBeyondBounds.y > 0)) {\n\n\t\t\t\t\t// Prevent the original click now that scrolling would be triggered\n\t\t\t\t\t_preventClick = true;\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Trigger the start of visual scrolling\n\t\t\t\t_startAnimation();\n\t\t\t\t_isDisplayingScroll = true;\n\t\t\t\t_hasBeenScrolled = true;\n\t\t\t\t_isAnimating = true;\n\t\t\t\tinitialScroll = true;\n\t\t\t} else {\n\n\t\t\t\t// Prevent the event default.  It is safe to call this in IE10 because the event is never\n\t\t\t\t// a window.event, always a \"true\" event.\n\t\t\t\trawEvent.preventDefault();\n\t\t\t}\n\n\t\t\t// If not yet locked to a scroll, determine whether to do so\n\t\t\tif (!_isScrolling) {\n\n\t\t\t\t// If the gesture distance has exceeded the scroll lock distance, or snapping is active\n\t\t\t\t// and the scroll has been interrupted, enter exclusive scrolling.\n\t\t\t\tif ((scrollInterrupt && _instanceOptions.snapping) || (_scrollableAxes.x && Math.abs(gesture.x) >= _instanceOptions.scrollBoundary) || (_scrollableAxes.y && Math.abs(gesture.y) >= _instanceOptions.scrollBoundary)) {\n\n\t\t\t\t\t_isScrolling = true;\n\t\t\t\t\t_preventClick = true;\n\t\t\t\t\t_ftscrollerMoving = _self;\n\t\t\t\t\tif (_instanceOptions.windowScrollingActiveFlag) {\n\t\t\t\t\t\twindow[_instanceOptions.windowScrollingActiveFlag] = _self;\n\t\t\t\t\t}\n\t\t\t\t\t_fireEvent('scrollstart', _getPosition());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Capture pointer if necessary\n\t\t\tif (_isScrolling) {\n\t\t\t\t_captureInput();\n\t\t\t}\n\n\t\t\t// Cancel text selections while dragging a cursor\n\t\t\tif (_canClearSelection) {\n\t\t\t\twindow.getSelection().removeAllRanges();\n\t\t\t}\n\n\t\t\t// Ensure the target scroll position is affected by bounds and render if needed\n\t\t\t_constrainAndRenderTargetScrollPosition();\n\n\t\t\t// To aid render/draw coalescing, perform other one-off actions here\n\t\t\tif (initialScroll) {\n\t\t\t\tif (gesture.x > 0) {\n\t\t\t\t\t_baseScrollPosition.x -= _instanceOptions.scrollResponseBoundary;\n\t\t\t\t} else if(gesture.x < 0) {\n\t\t\t\t\t_baseScrollPosition.x += _instanceOptions.scrollResponseBoundary;\n\t\t\t\t}\n\n\t\t\t\tif (gesture.y > 0) {\n\t\t\t\t\t_baseScrollPosition.y -= _instanceOptions.scrollResponseBoundary;\n\t\t\t\t} else if(gesture.y < 0) {\n\t\t\t\t\t_baseScrollPosition.y += _instanceOptions.scrollResponseBoundary;\n\t\t\t\t}\n\n\t\t\t\t_targetScrollPosition.x = _baseScrollPosition.x + gesture.x;\n\t\t\t\t_targetScrollPosition.y = _baseScrollPosition.y + gesture.y;\n\n\t\t\t\tif (_instanceOptions.scrollingClassName) {\n\t\t\t\t\t_containerNode.className += ' ' + _instanceOptions.scrollingClassName;\n\t\t\t\t}\n\t\t\t\tif (_instanceOptions.scrollbars) {\n\t\t\t\t\tfor (axis in _scrollableAxes) {\n\t\t\t\t\t\tif (_scrollableAxes.hasOwnProperty(axis)) {\n\t\t\t\t\t\t\t_scrollbarNodes[axis].className += ' active';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add an event to the event history, keeping it around twenty events long\n\t\t\t_eventHistory.push({ x: inputX, y: inputY, t: inputTime });\n\t\t\tif (_eventHistory.length > 30) {\n\t\t\t\t_eventHistory.splice(0, 15);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Complete a scroll with a final event time if available (it may\n\t\t * not be, depending on the input type); this may continue the scroll\n\t\t * with a fling and/or bounceback depending on options.\n\t\t */\n\t\t_endScroll = function _endScroll(inputTime, rawEvent) {\n\t\t\t_releaseInputCapture();\n\t\t\t_inputIdentifier = false;\n\t\t\t_cancelAnimation();\n\n\t\t\t_fireEvent('scrollinteractionend', {});\n\n\t\t\tif (!_isScrolling) {\n\t\t\t\tif (!_snapScroll(true) && _isDisplayingScroll) {\n\t\t\t\t\t_finalizeScroll(true);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Modify the last movement event to include the end event time\n\t\t\t_eventHistory[_eventHistory.length - 1].t = inputTime;\n\n\t\t\t// Update flags\n\t\t\t_isScrolling = false;\n\t\t\t_isDisplayingScroll = false;\n\t\t\t_ftscrollerMoving = false;\n\t\t\tif (_instanceOptions.windowScrollingActiveFlag) {\n\t\t\t\twindow[_instanceOptions.windowScrollingActiveFlag] = false;\n\t\t\t}\n\n\t\t\t// Stop the event default.  It is safe to call this in IE10 because\n\t\t\t// the event is never a window.event, always a \"true\" event.\n\t\t\tif (rawEvent) {\n\t\t\t\trawEvent.preventDefault();\n\t\t\t}\n\n\t\t\t// Trigger a fling or bounceback if necessary\n\t\t\tif (!_flingScroll() && !_snapScroll()) {\n\t\t\t\t_finalizeScroll();\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Remove the scrolling class, cleaning up display.\n\t\t */\n\t\t_finalizeScroll = function _finalizeScroll(scrollCancelled) {\n\t\t\tvar i, l, axis, scrollEvent, scrollRegex;\n\n\t\t\t_isAnimating = false;\n\t\t\t_isDisplayingScroll = false;\n\n\t\t\t// Remove scrolling class if set\n\t\t\tif (_instanceOptions.scrollingClassName) {\n\t\t\t\tscrollRegex = new RegExp('(?:^|\\\\s)' + _instanceOptions.scrollingClassName + '(?!\\\\S)', 'g');\n\t\t\t\t_containerNode.className = _containerNode.className.replace(scrollRegex, '');\n\t\t\t}\n\t\t\tif (_instanceOptions.scrollbars) {\n\t\t\t\tfor (axis in _scrollableAxes) {\n\t\t\t\t\tif (_scrollableAxes.hasOwnProperty(axis)) {\n\t\t\t\t\t\t_scrollbarNodes[axis].className = _scrollbarNodes[axis].className.replace(/ ?active/g, '');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Store final position if scrolling occurred\n\t\t\t_baseScrollPosition.x = _lastScrollPosition.x;\n\t\t\t_baseScrollPosition.y = _lastScrollPosition.y;\n\n\t\t\tscrollEvent = _getPosition();\n\n\t\t\tif (!scrollCancelled) {\n\t\t\t\tconsole.log('firing scroll event from _finalizeScroll');\n\t\t\t\t_fireEvent('scroll', scrollEvent);\n\t\t\t\t_updateSegments(true);\n\t\t\t}\n\n\t\t\t// Always fire the scroll end event, including an argument indicating whether\n\t\t\t// the scroll was cancelled\n\t\t\tscrollEvent.cancelled = scrollCancelled;\n\t\t\t_fireEvent('scrollend', scrollEvent);\n\n\t\t\t// Restore transitions\n\t\t\tfor (axis in _scrollableAxes) {\n\t\t\t\tif (_scrollableAxes.hasOwnProperty(axis)) {\n\t\t\t\t\t_scrollNodes[axis].style[_transitionProperty] = '';\n\t\t\t\t\tif (_instanceOptions.scrollbars) {\n\t\t\t\t\t\t_scrollbarNodes[axis].style[_transitionProperty] = '';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Clear any remaining timeouts\n\t\t\tfor (i = 0, l = _timeouts.length; i < l; i = i + 1) {\n\t\t\t\twindow.clearTimeout(_timeouts[i]);\n\t\t\t}\n\t\t\t_timeouts.length = 0;\n\t\t};\n\n\t\t/**\n\t\t * Interrupt a current scroll, allowing a start scroll during animation to trigger a new scroll\n\t\t */\n\t\t_interruptScroll = function _interruptScroll() {\n\t\t\tvar axis, i, l;\n\n\t\t\t_isAnimating = false;\n\n\t\t\t// Update the stored base position\n\t\t\t_updateElementPosition();\n\n\t\t\t// Ensure the parsed positions are set, also clearing transitions\n\t\t\tfor (axis in _scrollableAxes) {\n\t\t\t\tif (_scrollableAxes.hasOwnProperty(axis)) {\n\t\t\t\t\t_setAxisPosition(axis, _baseScrollPosition[axis], 16, _instanceOptions.bounceDecelerationBezier);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Update segment tracking if snapping is active\n\t\t\t_updateSegments(false);\n\n\t\t\t// Clear any remaining timeouts\n\t\t\tfor (i = 0, l = _timeouts.length; i < l; i = i + 1) {\n\t\t\t\twindow.clearTimeout(_timeouts[i]);\n\t\t\t}\n\t\t\t_timeouts.length = 0;\n\t\t};\n\n\t\t/**\n\t\t * Determine whether a scroll fling or bounceback is required, and set up the styles and\n\t\t * timeouts required.\n\t\t */\n\t\t_flingScroll = function _flingScroll() {\n\t\t\tvar i, axis, movementTime, movementSpeed, lastPosition, comparisonPosition, flingDuration, flingDistance, flingPosition, bounceDelay, bounceDistance, bounceDuration, bounceTarget, boundsBounce, modifiedDistance, flingBezier, timeProportion, boundsCrossDelay, flingStartSegment, beyondBoundsFlingDistance, baseFlingComponent;\n\t\t\tvar maxAnimationTime = 0;\n\t\t\tvar moveRequired = false;\n\t\t\tvar scrollPositionsToApply = {};\n\n\t\t\t// If we only have the start event available, or flinging is disabled,\n\t\t\t// or the scroll was triggered by a scrollwheel, no action required.\n\t\t\tif (_eventHistory.length === 1 || !_instanceOptions.flinging || _inputIdentifier === 'scrollwheel') {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tfor (axis in _scrollableAxes) {\n\t\t\t\tif (_scrollableAxes.hasOwnProperty(axis)) {\n\t\t\t\t\tbounceDuration = 350;\n\t\t\t\t\tbounceDistance = 0;\n\t\t\t\t\tboundsBounce = false;\n\t\t\t\t\tbounceTarget = false;\n\t\t\t\t\tboundsCrossDelay = undefined;\n\n\t\t\t\t\t// Re-set a default bezier curve for the animation for potential modification\n\t\t\t\t\tflingBezier = _instanceOptions.flingBezier;\n\n\t\t\t\t\t// Get the last movement speed, in pixels per millisecond.  To do this, look at the events\n\t\t\t\t\t// in the last 100ms and average out the speed, using a minimum number of two points.\n\t\t\t\t\tlastPosition = _eventHistory[_eventHistory.length - 1];\n\t\t\t\t\tcomparisonPosition = _eventHistory[_eventHistory.length - 2];\n\t\t\t\t\tfor (i = _eventHistory.length - 3; i >= 0; i = i - 1) {\n\t\t\t\t\t\tif (lastPosition.t - _eventHistory[i].t > 100) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcomparisonPosition = _eventHistory[i];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Get the last movement time.  If this is zero - as can happen with\n\t\t\t\t\t// some scrollwheel events on some platforms - increase it to 16ms as\n\t\t\t\t\t// if the movement occurred over a single frame at 60fps.\n\t\t\t\t\tmovementTime = lastPosition.t - comparisonPosition.t;\n\t\t\t\t\tif (!movementTime) {\n\t\t\t\t\t\tmovementTime = 16;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Derive the movement speed\n\t\t\t\t\tmovementSpeed = (lastPosition[axis] - comparisonPosition[axis]) / movementTime;\n\n\t\t\t\t\t// If there is little speed, no further action required except for a bounceback, below.\n\t\t\t\t\tif (Math.abs(movementSpeed) < _kMinimumSpeed) {\n\t\t\t\t\t\tflingDuration = 0;\n\t\t\t\t\t\tflingDistance = 0;\n\n\t\t\t\t\t} else {\n\n\n\t\t\t\t\t\t/* Calculate the fling duration.  As per TouchScroll, the speed at any particular\n\t\t\t\t\t\tpoint in time can be calculated as:\n\t\t\t\t\t\t\t{ speed } = { initial speed } * ({ friction } to the power of { duration })\n\t\t\t\t\t\t...assuming all values are in equal pixels/millisecond measurements.  As we know the\n\t\t\t\t\t\tminimum target speed, this can be altered to:\n\t\t\t\t\t\t\t{ duration } = log( { speed } / { initial speed } ) / log( { friction } )\n\t\t\t\t\t\t*/\n\n\t\t\t\t\t\tflingDuration = Math.log(_kMinimumSpeed / Math.abs(movementSpeed)) / Math.log(_kFriction);\n\n\n\t\t\t\t\t\t/* Calculate the fling distance (before any bouncing or snapping).  As per\n\t\t\t\t\t\tTouchScroll, the total distance covered can be approximated by summing\n\t\t\t\t\t\tthe distance per millisecond, per millisecond of duration - a divergent series,\n\t\t\t\t\t\tand so rather tricky to model otherwise!\n\t\t\t\t\t\tSo using values in pixels per millisecond:\n\t\t\t\t\t\t\t{ distance } = { initial speed } * (1 - ({ friction } to the power\n\t\t\t\t\t\t\t\tof { duration + 1 }) / (1 - { friction })\n\t\t\t\t\t\t*/\n\n\t\t\t\t\t\tflingDistance = movementSpeed * (1 - Math.pow(_kFriction, flingDuration + 1)) / (1 - _kFriction);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Determine a target fling position\n\t\t\t\t\tflingPosition = Math.floor(_lastScrollPosition[axis] + flingDistance);\n\n\t\t\t\t\t// If bouncing is disabled, and the last scroll position and fling position are both at a bound,\n\t\t\t\t\t// reset the fling position to the bound\n\t\t\t\t\tif (!_instanceOptions.bouncing) {\n\t\t\t\t\t\tif (_lastScrollPosition[axis] === 0 && flingPosition > 0) {\n\t\t\t\t\t\t\tflingPosition = 0;\n\t\t\t\t\t\t} else if (_lastScrollPosition[axis] === _metrics.scrollEnd[axis] && flingPosition < _lastScrollPosition[axis]) {\n\t\t\t\t\t\t\tflingPosition = _lastScrollPosition[axis];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// In single-page-scroll mode, determine the page to snap to - maximum one page\n\t\t\t\t\t// in either direction from the *start* page.\n\t\t\t\t\tif (_instanceOptions.singlePageScrolls && _instanceOptions.snapping) {\n\t\t\t\t\t\tflingStartSegment = -_lastScrollPosition[axis] / _snapGridSize[axis];\n\t\t\t\t\t\tif (_baseSegment[axis] < flingStartSegment) {\n\t\t\t\t\t\t\tflingStartSegment = Math.floor(flingStartSegment);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tflingStartSegment = Math.ceil(flingStartSegment);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If the target position will end up beyond another page, target that page edge\n\t\t\t\t\t\tif (flingPosition > -(_baseSegment[axis] - 1) * _snapGridSize[axis]) {\n\t\t\t\t\t\t\tbounceDistance = flingPosition + (_baseSegment[axis] - 1) * _snapGridSize[axis];\n\t\t\t\t\t\t} else if (flingPosition < -(_baseSegment[axis] + 1) * _snapGridSize[axis]) {\n\t\t\t\t\t\t\tbounceDistance = flingPosition + (_baseSegment[axis] + 1) * _snapGridSize[axis];\n\n\t\t\t\t\t\t// Otherwise, if the movement speed was above the minimum velocity, continue\n\t\t\t\t\t\t// in the move direction.\n\t\t\t\t\t\t} else if (Math.abs(movementSpeed) > _kMinimumSpeed) {\n\n\t\t\t\t\t\t\t// Determine the target segment\n\t\t\t\t\t\t\tif (movementSpeed < 0) {\n\t\t\t\t\t\t\t\tflingPosition = Math.floor(_lastScrollPosition[axis] / _snapGridSize[axis]) * _snapGridSize[axis];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tflingPosition = Math.ceil(_lastScrollPosition[axis] / _snapGridSize[axis]) * _snapGridSize[axis];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tflingDuration = Math.min(_instanceOptions.maxFlingDuration, flingDuration * (flingPosition - _lastScrollPosition[axis]) / flingDistance);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// In non-paginated snapping mode, snap to the nearest grid location to the target\n\t\t\t\t\t} else if (_instanceOptions.snapping) {\n\t\t\t\t\t\tbounceDistance = flingPosition - (Math.round(flingPosition / _snapGridSize[axis]) * _snapGridSize[axis]);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Deal with cases where the target is beyond the bounds\n\t\t\t\t\tif (flingPosition - bounceDistance > 0) {\n\t\t\t\t\t\tbounceDistance = flingPosition;\n\t\t\t\t\t\tboundsBounce = true;\n\t\t\t\t\t} else if (flingPosition - bounceDistance < _metrics.scrollEnd[axis]) {\n\t\t\t\t\t\tbounceDistance = flingPosition - _metrics.scrollEnd[axis];\n\t\t\t\t\t\tboundsBounce = true;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Amend the positions and bezier curve if necessary\n\t\t\t\t\tif (bounceDistance) {\n\n\t\t\t\t\t\t// If the fling moves the scroller beyond the normal scroll bounds, and\n\t\t\t\t\t\t// the bounce is snapping the scroll back after the fling:\n\t\t\t\t\t\tif (boundsBounce && _instanceOptions.bouncing && flingDistance) {\n\t\t\t\t\t\t\tflingDistance = Math.floor(flingDistance);\n\n\t\t\t\t\t\t\tif (flingPosition > 0) {\n\t\t\t\t\t\t\t\tbeyondBoundsFlingDistance = flingPosition - Math.max(0, _lastScrollPosition[axis]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbeyondBoundsFlingDistance = flingPosition - Math.min(_metrics.scrollEnd[axis], _lastScrollPosition[axis]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbaseFlingComponent = flingDistance - beyondBoundsFlingDistance;\n\n\t\t\t\t\t\t\t// Determine the time proportion the original bound is along the fling curve\n\t\t\t\t\t\t\tif (!flingDistance || !flingDuration) {\n\t\t\t\t\t\t\t\ttimeProportion = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimeProportion = flingBezier._getCoordinateForT(flingBezier.getTForY((flingDistance - beyondBoundsFlingDistance) / flingDistance, 1 / flingDuration), flingBezier._p1.x, flingBezier._p2.x);\n\t\t\t\t\t\t\t\tboundsCrossDelay = timeProportion * flingDuration;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Eighth the distance beyonds the bounds\n\t\t\t\t\t\t\tmodifiedDistance = Math.ceil(beyondBoundsFlingDistance / 8);\n\n\t\t\t\t\t\t\t// Further limit the bounce to half the container dimensions\n\t\t\t\t\t\t\tif (Math.abs(modifiedDistance) > _metrics.container[axis] / 2) {\n\t\t\t\t\t\t\t\tif (modifiedDistance < 0) {\n\t\t\t\t\t\t\t\t\tmodifiedDistance = -Math.floor(_metrics.container[axis] / 2);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tmodifiedDistance = Math.floor(_metrics.container[axis] / 2);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (flingPosition > 0) {\n\t\t\t\t\t\t\t\tbounceTarget = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbounceTarget = _metrics.scrollEnd[axis];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// If the entire fling is a bounce, modify appropriately\n\t\t\t\t\t\t\tif (timeProportion === 0) {\n\t\t\t\t\t\t\t\tflingDuration = flingDuration / 6;\n\t\t\t\t\t\t\t\tflingPosition = _lastScrollPosition[axis] + baseFlingComponent + modifiedDistance;\n\t\t\t\t\t\t\t\tbounceDelay = flingDuration;\n\n\t\t\t\t\t\t\t// Otherwise, take a new curve and add it to the timeout stack for the bounce\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// The new bounce delay is the pre-boundary fling duration, plus a\n\t\t\t\t\t\t\t\t// sixth of the post-boundary fling.\n\t\t\t\t\t\t\t\tbounceDelay = (timeProportion + ((1 - timeProportion) / 6)) * flingDuration;\n\n\t\t\t\t\t\t\t\t_scheduleAxisPosition(axis, (_lastScrollPosition[axis] + baseFlingComponent + modifiedDistance), ((1 - timeProportion) * flingDuration / 6), _instanceOptions.bounceDecelerationBezier, boundsCrossDelay);\n\n\t\t\t\t\t\t\t\t// Modify the fling to match, clipping to prevent over-fling\n\t\t\t\t\t\t\t\tflingBezier = flingBezier.divideAtX(bounceDelay / flingDuration, 1 / flingDuration)[0];\n\t\t\t\t\t\t\t\tflingDuration = bounceDelay;\n\t\t\t\t\t\t\t\tflingPosition = (_lastScrollPosition[axis] + baseFlingComponent + modifiedDistance);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If the fling requires snapping to a snap location, and the bounce needs to\n\t\t\t\t\t\t// reverse the fling direction after the fling completes:\n\t\t\t\t\t\t} else if ((flingDistance < 0 && bounceDistance < flingDistance) || (flingDistance > 0 && bounceDistance > flingDistance)) {\n\n\t\t\t\t\t\t\t// Shorten the original fling duration to reflect the bounce\n\t\t\t\t\t\t\tflingPosition = flingPosition - Math.floor(flingDistance / 2);\n\t\t\t\t\t\t\tbounceDistance = bounceDistance - Math.floor(flingDistance / 2);\n\t\t\t\t\t\t\tbounceDuration = Math.sqrt(Math.abs(bounceDistance)) * 50;\n\t\t\t\t\t\t\tbounceTarget = flingPosition - bounceDistance;\n\t\t\t\t\t\t\tflingDuration = 350;\n\t\t\t\t\t\t\tbounceDelay = flingDuration * 0.97;\n\n\t\t\t\t\t\t// If the bounce is truncating the fling, or continuing the fling on in the same\n\t\t\t\t\t\t// direction to hit the next boundary:\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tflingPosition = flingPosition - bounceDistance;\n\n\t\t\t\t\t\t\t// If there was no fling distance originally, use the bounce details\n\t\t\t\t\t\t\tif (!flingDistance) {\n\t\t\t\t\t\t\t\tflingDuration = bounceDuration;\n\n\t\t\t\t\t\t\t// If truncating the fling at a snapping edge:\n\t\t\t\t\t\t\t} else if ((flingDistance < 0 && bounceDistance < 0) || (flingDistance > 0 && bounceDistance > 0)) {\n\t\t\t\t\t\t\t\ttimeProportion = flingBezier._getCoordinateForT(flingBezier.getTForY((Math.abs(flingDistance) - Math.abs(bounceDistance)) / Math.abs(flingDistance), 1 / flingDuration), flingBezier._p1.x, flingBezier._p2.x);\n\t\t\t\t\t\t\t\tflingBezier = flingBezier.divideAtX(timeProportion, 1 / flingDuration)[0];\n\t\t\t\t\t\t\t\tflingDuration = Math.round(flingDuration * timeProportion);\n\n\t\t\t\t\t\t\t// If extending the fling to reach the next snapping boundary, no further\n\t\t\t\t\t\t\t// action is required.\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbounceDistance = 0;\n\t\t\t\t\t\t\tbounceDuration = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// If no fling or bounce is required, continue\n\t\t\t\t\tif (flingPosition === _lastScrollPosition[axis] && !bounceDistance) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tmoveRequired = true;\n\n\t\t\t\t\t// Perform the fling\n\t\t\t\t\t_setAxisPosition(axis, flingPosition, flingDuration, flingBezier, boundsCrossDelay);\n\n\t\t\t\t\t// Schedule a bounce if appropriate\n\t\t\t\t\tif (bounceDistance && bounceDuration) {\n\t\t\t\t\t\t_scheduleAxisPosition(axis, bounceTarget, bounceDuration, _instanceOptions.bounceBezier, bounceDelay);\n\t\t\t\t\t}\n\n\t\t\t\t\tmaxAnimationTime = Math.max(maxAnimationTime, bounceDistance ? (bounceDelay + bounceDuration) : flingDuration);\n\t\t\t\t\tscrollPositionsToApply[axis] = (bounceTarget === false) ? flingPosition : bounceTarget;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (moveRequired && maxAnimationTime) {\n\t\t\t\t_timeouts.push(setTimeout(function () {\n\t\t\t\t\tvar anAxis;\n\n\t\t\t\t\t// Update the stored scroll position ready for finalising\n\t\t\t\t\tfor (anAxis in scrollPositionsToApply) {\n\t\t\t\t\t\tif (scrollPositionsToApply.hasOwnProperty(anAxis)) {\n\t\t\t\t\t\t\t_lastScrollPosition[anAxis] = scrollPositionsToApply[anAxis];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t_finalizeScroll();\n\t\t\t\t}, maxAnimationTime));\n\t\t\t}\n\n\t\t\treturn moveRequired;\n\t\t};\n\n\t\t/**\n\t\t * Bounce back into bounds if necessary, or snap to a grid location.\n\t\t */\n\t\t_snapScroll = function _snapScroll(scrollCancelled) {\n\t\t\tvar axis;\n\t\t\tvar snapDuration = scrollCancelled ? 100 : 350;\n\t\t\tvar targetPosition = _lastScrollPosition;\n\n\t\t\t// Get the current position and see if a snap is required\n\t\t\tif (_instanceOptions.snapping) {\n\n\t\t\t\t// Store current snap index\n\t\t\t\t_snapIndex = _getSnapIndexForPosition(targetPosition);\n\t\t\t\ttargetPosition = _getSnapPositionForIndexes(_snapIndex, targetPosition);\n\t\t\t}\n\t\t\ttargetPosition = _limitToBounds(targetPosition);\n\n\t\t\tvar snapRequired = false;\n\t\t\tfor (axis in _baseScrollableAxes) {\n\t\t\t\tif (_baseScrollableAxes.hasOwnProperty(axis)) {\n\t\t\t\t\tif (targetPosition[axis] !== _lastScrollPosition[axis]) {\n\t\t\t\t\t\tsnapRequired = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!snapRequired) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Perform the snap\n\t\t\tfor (axis in _baseScrollableAxes) {\n\t\t\t\tif (_baseScrollableAxes.hasOwnProperty(axis)) {\n\t\t\t\t\t_setAxisPosition(axis, targetPosition[axis], snapDuration);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_timeouts.push(setTimeout(function () {\n\n\t\t\t\t// Update the stored scroll position ready for finalizing\n\t\t\t\t_lastScrollPosition = targetPosition;\n\n\t\t\t\t_finalizeScroll(scrollCancelled);\n\t\t\t}, snapDuration));\n\n\t\t\treturn true;\n\t\t};\n\n\t\t/**\n\t\t * Get an appropriate snap index for a supplied point.\n\t\t */\n\t\t_getSnapIndexForPosition = function _getSnapIndexForPosition(coordinates) {\n\t\t\tvar axis;\n\t\t\tvar indexes = {x: 0, y: 0};\n\t\t\tfor (axis in _scrollableAxes) {\n\t\t\t\tif (_scrollableAxes.hasOwnProperty(axis) && _snapGridSize[axis]) {\n\t\t\t\t\tindexes[axis] = Math.round(coordinates[axis] / _snapGridSize[axis]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn indexes;\n\t\t};\n\n\t\t/**\n\t\t * Get an appropriate snap point for a supplied index.\n\t\t */\n\t\t_getSnapPositionForIndexes = function _getSnapPositionForIndexes(indexes, currentCoordinates) {\n\t\t\tvar axis;\n\t\t\tvar coordinatesToReturn = {\n\t\t\t\tx: currentCoordinates.x,\n\t\t\t\ty: currentCoordinates.y\n\t\t\t};\n\t\t\tfor (axis in _scrollableAxes) {\n\t\t\t\tif (_scrollableAxes.hasOwnProperty(axis)) {\n\t\t\t\t\tcoordinatesToReturn[axis] = indexes[axis] * _snapGridSize[axis];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn coordinatesToReturn;\n\t\t};\n\n\t\t/**\n\t\t * Update the scroll position while scrolling is active, checking the position\n\t\t * within bounds and rubberbanding/constraining as appropriate; also triggers a\n\t\t * scroll position render if a requestAnimationFrame loop isn't active\n\t\t */\n\t\t_constrainAndRenderTargetScrollPosition = function _constrainAndRenderTargetScrollPosition() {\n\t\t\tvar axis, upperBound, lowerBound;\n\n\t\t\t// Update axes target positions if beyond bounds\n\t\t\tfor (axis in _scrollableAxes) {\n\t\t\t\tif (_scrollableAxes.hasOwnProperty(axis)) {\n\n\t\t\t\t\t// Set bounds to the left and right of the container\n\t\t\t\t\tupperBound = 0;\n\t\t\t\t\tlowerBound = _metrics.scrollEnd[axis];\n\n\t\t\t\t\tif (_instanceOptions.singlePageScrolls && _instanceOptions.snapping) {\n\n\t\t\t\t\t\t// For a single-page-scroll, set the bounds to the left and right of the\n\t\t\t\t\t\t// current segment\n\t\t\t\t\t\tupperBound = Math.min(upperBound, -(_baseSegment[axis] - 1) * _snapGridSize[axis]);\n\t\t\t\t\t\tlowerBound = Math.max(lowerBound, -(_baseSegment[axis] + 1) * _snapGridSize[axis]);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (_targetScrollPosition[axis] > upperBound) {\n\t\t\t\t\t\t_targetScrollPosition[axis] = upperBound + _modifyDistanceBeyondBounds(_targetScrollPosition[axis] - upperBound, axis);\n\t\t\t\t\t} else if (_targetScrollPosition[axis] < lowerBound) {\n\t\t\t\t\t\t_targetScrollPosition[axis] = lowerBound + _modifyDistanceBeyondBounds(_targetScrollPosition[axis] - lowerBound, axis);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Trigger a scroll position update for platforms not using requestAnimationFrames\n\t\t\tif (!_reqAnimationFrame) {\n\t\t\t\t_scheduleRender();\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Limit coordinates within the bounds of the scrollable viewport.\n\t\t */\n\t\t_limitToBounds = function _limitToBounds(coordinates) {\n\t\t\tvar axis;\n\t\t\tvar coordinatesToReturn = { x: coordinates.x, y: coordinates.y };\n\n\t\t\tfor (axis in _scrollableAxes) {\n\t\t\t\tif (_scrollableAxes.hasOwnProperty(axis)) {\n\n\t\t\t\t\t// If the coordinate is beyond the edges of the scroller, use the closest edge\n\t\t\t\t\tif (coordinates[axis] > 0) {\n\t\t\t\t\t\tcoordinatesToReturn[axis] = 0;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (coordinates[axis] < _metrics.scrollEnd[axis]) {\n\t\t\t\t\t\tcoordinatesToReturn[axis] = _metrics.scrollEnd[axis];\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn coordinatesToReturn;\n\t\t};\n\n\n\t\t/**\n\t\t * Sets up the DOM around the node to be scrolled.\n\t\t */\n\t\t_initializeDOM = function _initializeDOM() {\n\t\t\tvar offscreenFragment, offscreenNode, scrollYParent;\n\n\t\t\t// Check whether the DOM is already present and valid - if so, no further action required.\n\t\t\tif (_existingDOMValid()) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Otherwise, the DOM needs to be created inside the originally supplied node.  The node\n\t\t\t// has a container inserted inside it - which acts as an anchor element with constraints -\n\t\t\t// and then the scrollable layers as appropriate.\n\n\t\t\t// Create a new document fragment to temporarily hold the scrollable content\n\t\t\toffscreenFragment = _scrollableMasterNode.ownerDocument.createDocumentFragment();\n\t\t\toffscreenNode = document.createElement('DIV');\n\t\t\toffscreenFragment.appendChild(offscreenNode);\n\n\t\t\t// Drop in the wrapping HTML\n\t\t\toffscreenNode.innerHTML = FTScroller.prototype.getPrependedHTML(!_instanceOptions.scrollingX, !_instanceOptions.scrollingY, _instanceOptions.hwAccelerationClass) + FTScroller.prototype.getAppendedHTML(!_instanceOptions.scrollingX, !_instanceOptions.scrollingY, _instanceOptions.hwAccelerationClass, _instanceOptions.scrollbars);\n\n\t\t\t// Update references as appropriate\n\t\t\t_containerNode = offscreenNode.firstElementChild;\n\t\t\tscrollYParent = _containerNode;\n\t\t\tif (_instanceOptions.scrollingX) {\n\t\t\t\t_scrollNodes.x = _containerNode.firstElementChild;\n\t\t\t\tscrollYParent = _scrollNodes.x;\n\t\t\t\tif (_instanceOptions.scrollbars) {\n\t\t\t\t\t_scrollbarNodes.x = _containerNode.getElementsByClassName('ftscroller_scrollbarx')[0];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (_instanceOptions.scrollingY) {\n\t\t\t\t_scrollNodes.y = scrollYParent.firstElementChild;\n\t\t\t\tif (_instanceOptions.scrollbars) {\n\t\t\t\t\t_scrollbarNodes.y = _containerNode.getElementsByClassName('ftscroller_scrollbary')[0];\n\t\t\t\t}\n\t\t\t\t_contentParentNode = _scrollNodes.y;\n\t\t\t} else {\n\t\t\t\t_contentParentNode = _scrollNodes.x;\n\t\t\t}\n\n\t\t\t// Take the contents of the scrollable element, and copy them into the new container\n\t\t\twhile (_scrollableMasterNode.firstChild) {\n\t\t\t\t_contentParentNode.appendChild(_scrollableMasterNode.firstChild);\n\t\t\t}\n\n\t\t\t// Move the wrapped elements back into the document\n\t\t\t_scrollableMasterNode.appendChild(_containerNode);\n\t\t};\n\n\t\t/**\n\t\t * Attempts to use any existing DOM scroller nodes if possible, returning true if so;\n\t\t * updates all internal element references.\n\t\t */\n\t\t_existingDOMValid = function _existingDOMValid() {\n\t\t\tvar scrollerContainer, layerX, layerY, yParent, scrollerX, scrollerY, candidates, i, l;\n\n\t\t\t// Check that there's an initial child node, and make sure it's the container class\n\t\t\tscrollerContainer = _scrollableMasterNode.firstElementChild;\n\t\t\tif (!scrollerContainer || scrollerContainer.className.indexOf('ftscroller_container') === -1) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If x-axis scrolling is enabled, find and verify the x scroller layer\n\t\t\tif (_instanceOptions.scrollingX) {\n\n\t\t\t\t// Find and verify the x scroller layer\n\t\t\t\tlayerX = scrollerContainer.firstElementChild;\n\t\t\t\tif (!layerX || layerX.className.indexOf('ftscroller_x') === -1) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tyParent = layerX;\n\n\t\t\t\t// Find and verify the x scrollbar if enabled\n\t\t\t\tif (_instanceOptions.scrollbars) {\n\t\t\t\t\tcandidates = scrollerContainer.getElementsByClassName('ftscroller_scrollbarx');\n\t\t\t\t\tif (candidates) {\n\t\t\t\t\t\tfor (i = 0, l = candidates.length; i < l; i = i + 1) {\n\t\t\t\t\t\t\tif (candidates[i].parentNode === scrollerContainer) {\n\t\t\t\t\t\t\t\tscrollerX = candidates[i];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!scrollerX) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tyParent = scrollerContainer;\n\t\t\t}\n\n\t\t\t// If y-axis scrolling is enabled, find and verify the y scroller layer\n\t\t\tif (_instanceOptions.scrollingY) {\n\n\t\t\t\t// Find and verify the x scroller layer\n\t\t\t\tlayerY = yParent.firstElementChild;\n\t\t\t\tif (!layerY || layerY.className.indexOf('ftscroller_y') === -1) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Find and verify the y scrollbar if enabled\n\t\t\t\tif (_instanceOptions.scrollbars) {\n\t\t\t\t\tcandidates = scrollerContainer.getElementsByClassName('ftscroller_scrollbary');\n\t\t\t\t\tif (candidates) {\n\t\t\t\t\t\tfor (i = 0, l = candidates.length; i < l; i = i + 1) {\n\t\t\t\t\t\t\tif (candidates[i].parentNode === scrollerContainer) {\n\t\t\t\t\t\t\t\tscrollerY = candidates[i];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!scrollerY) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Elements found and verified - update the references and return success\n\t\t\t_containerNode = scrollerContainer;\n\t\t\tif (layerX) {\n\t\t\t\t_scrollNodes.x = layerX;\n\t\t\t}\n\t\t\tif (layerY) {\n\t\t\t\t_scrollNodes.y = layerY;\n\t\t\t}\n\t\t\tif (scrollerX) {\n\t\t\t\t_scrollbarNodes.x = scrollerX;\n\t\t\t}\n\t\t\tif (scrollerY) {\n\t\t\t\t_scrollbarNodes.y = scrollerY;\n\t\t\t}\n\t\t\tif (_instanceOptions.scrollingY) {\n\t\t\t\t_contentParentNode = layerY;\n\t\t\t} else {\n\t\t\t\t_contentParentNode = layerX;\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\n\t\t_domChanged = function _domChanged(e) {\n\n\t\t\t// If the timer is active, clear it\n\t\t\tif (_domChangeDebouncer) {\n\t\t\t\twindow.clearTimeout(_domChangeDebouncer);\n\t\t\t}\n\n\t\t\t// React to resizes at once\n\t\t\tif (e && e.type === 'resize') {\n\t\t\t\t_updateDimensions();\n\n\t\t\t// For other changes, which may occur in groups, set up the DOM changed timer\n\t\t\t} else {\n\t\t\t\t_domChangeDebouncer = setTimeout(function () {\n\t\t\t\t\t_updateDimensions();\n\t\t\t\t}, 100);\n\t\t\t}\n\t\t};\n\n\t\t_updateDimensions = function _updateDimensions(ignoreSnapScroll) {\n\t\t\tvar axis;\n\n\t\t\t// Only update dimensions if the container node exists (DOM elements can go away if\n\t\t\t// the scroller instance is not destroyed correctly)\n\t\t\tif (!_containerNode || !_contentParentNode) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (_domChangeDebouncer) {\n\t\t\t\twindow.clearTimeout(_domChangeDebouncer);\n\t\t\t\t_domChangeDebouncer = false;\n\t\t\t}\n\t\t\tvar containerWidth, containerHeight, startAlignments;\n\n\t\t\t// Calculate the starting alignment for comparison later\n\t\t\tstartAlignments = { x: false, y: false };\n\t\t\tfor (axis in startAlignments) {\n\t\t\t\tif (startAlignments.hasOwnProperty(axis)) {\n\t\t\t\t\tif (_lastScrollPosition[axis] === 0) {\n\t\t\t\t\t\tstartAlignments[axis] = -1;\n\t\t\t\t\t} else if (_lastScrollPosition[axis] <= _metrics.scrollEnd[axis]) {\n\t\t\t\t\t\tstartAlignments[axis] = 1;\n\t\t\t\t\t} else if (_lastScrollPosition[axis] * 2 <= _metrics.scrollEnd[axis] + 5 && _lastScrollPosition[axis] * 2 >= _metrics.scrollEnd[axis] - 5) {\n\t\t\t\t\t\tstartAlignments[axis] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcontainerWidth = _containerNode.offsetWidth;\n\t\t\tcontainerHeight = _containerNode.offsetHeight;\n\n\t\t\t// Grab the dimensions\n\t\t\tvar rawScrollWidth = options.contentWidth || _contentParentNode.offsetWidth;\n\t\t\tvar rawScrollHeight = options.contentHeight || _contentParentNode.offsetHeight;\n\t\t\tvar scrollWidth = rawScrollWidth;\n\t\t\tvar scrollHeight = rawScrollHeight;\n\t\t\tvar targetPosition = { x: _lastScrollPosition.x, y: _lastScrollPosition.y };\n\n\t\t\t// Update snap grid\n\t\t\tif (!_snapGridSize.userX) {\n\t\t\t\t_snapGridSize.x = containerWidth;\n\t\t\t}\n\t\t\tif (!_snapGridSize.userY) {\n\t\t\t\t_snapGridSize.y = containerHeight;\n\t\t\t}\n\n\t\t\t// If there is a grid, conform to the grid\n\t\t\tif (_instanceOptions.snapping) {\n\t\t\t\tif (_snapGridSize.userX) {\n\t\t\t\t\tscrollWidth = Math.ceil(scrollWidth / _snapGridSize.userX) * _snapGridSize.userX;\n\t\t\t\t} else {\n\t\t\t\t\tscrollWidth = Math.ceil(scrollWidth / _snapGridSize.x) * _snapGridSize.x;\n\t\t\t\t}\n\t\t\t\tif (_snapGridSize.userY) {\n\t\t\t\t\tscrollHeight = Math.ceil(scrollHeight / _snapGridSize.userY) * _snapGridSize.userY;\n\t\t\t\t} else {\n\t\t\t\t\tscrollHeight = Math.ceil(scrollHeight / _snapGridSize.y) * _snapGridSize.y;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If no details have changed, return.\n\t\t\tif (_metrics.container.x === containerWidth && _metrics.container.y === containerHeight && _metrics.content.x === scrollWidth && _metrics.content.y === scrollHeight) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Update the sizes\n\t\t\t_metrics.container.x = containerWidth;\n\t\t\t_metrics.container.y = containerHeight;\n\t\t\t_metrics.content.x = scrollWidth;\n\t\t\t_metrics.content.rawX = rawScrollWidth;\n\t\t\t_metrics.content.y = scrollHeight;\n\t\t\t_metrics.content.rawY = rawScrollHeight;\n\t\t\t_metrics.scrollEnd.x = containerWidth - scrollWidth;\n\t\t\t_metrics.scrollEnd.y = containerHeight - scrollHeight;\n\n\t\t\t_updateScrollbarDimensions();\n\n\t\t\t// If scrolling is in progress, trigger a scroll update\n\t\t\tif (_isScrolling) {\n\t\t\t\t_lastScrollPosition.x--;\n\t\t\t\t_lastScrollPosition.y--;\n\t\t\t\t_constrainAndRenderTargetScrollPosition();\n\n\t\t\t// If scrolling *isn't* in progress, snap and realign.\n\t\t\t} else {\n\t\t\t\tif (!ignoreSnapScroll && _instanceOptions.snapping) {\n\n\t\t\t        // Ensure bounds are correct\n\t\t\t\t\t_updateSegments();\n\t\t\t\t\ttargetPosition = _getSnapPositionForIndexes(_snapIndex, _lastScrollPosition);\n\t\t\t\t}\n\n\t\t\t\t// Apply base alignment if appropriate\n\t\t\t\tfor (axis in targetPosition) {\n\t\t\t\t\tif (targetPosition.hasOwnProperty(axis)) {\n\n\t\t\t\t\t\t// If the container is smaller than the content, determine whether to apply the\n\t\t\t\t\t\t// alignment.  This occurs if a scroll has never taken place, or if the position\n\t\t\t\t\t\t// was previously at the correct \"end\" and can be maintained.\n\t\t\t\t\t\tif (_metrics.container[axis] < _metrics.content[axis]) {\n\t\t\t\t\t\t\tif (_hasBeenScrolled && _instanceOptions.baseAlignments[axis] !== startAlignments[axis]) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Apply the alignment\n\t\t\t\t\t\tif (_instanceOptions.baseAlignments[axis] === 1) {\n\t\t\t\t\t\t\ttargetPosition[axis] = _metrics.scrollEnd[axis];\n\t\t\t\t\t\t} else if (_instanceOptions.baseAlignments[axis] === 0) {\n\t\t\t\t\t\t\ttargetPosition[axis] = Math.floor(_metrics.scrollEnd[axis] / 2);\n\t\t\t\t\t\t} else if (_instanceOptions.baseAlignments[axis] === -1) {\n\t\t\t\t\t\t\ttargetPosition[axis] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Limit to bounds\n\t\t\t\ttargetPosition = _limitToBounds(targetPosition);\n\n\t\t\t\tif (_instanceOptions.scrollingX && targetPosition.x !== _lastScrollPosition.x) {\n\t\t\t\t\t_setAxisPosition('x', targetPosition.x, 0);\n\t\t\t\t\t_baseScrollPosition.x = targetPosition.x;\n\t\t\t\t}\n\t\t\t\tif (_instanceOptions.scrollingY && targetPosition.y !== _lastScrollPosition.y) {\n\t\t\t\t\t_setAxisPosition('y', targetPosition.y, 0);\n\t\t\t\t\t_baseScrollPosition.y = targetPosition.y;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t_updateScrollbarDimensions = function _updateScrollbarDimensions() {\n\n\t\t\t// Update scrollbar sizes\n\t\t\tif (_instanceOptions.scrollbars) {\n\t\t\t\tif (_instanceOptions.scrollingX) {\n\t\t\t\t\t_scrollbarNodes.x.style.width = Math.max(6, Math.round(_metrics.container.x * (_metrics.container.x / _metrics.content.x) - 4)) + 'px';\n\t\t\t\t}\n\t\t\t\tif (_instanceOptions.scrollingY) {\n\t\t\t\t\t_scrollbarNodes.y.style.height = Math.max(6, Math.round(_metrics.container.y * (_metrics.container.y / _metrics.content.y) - 4)) + 'px';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Update scroll caches\n\t\t\t_scrollableAxes = {};\n\t\t\tif (_instanceOptions.scrollingX && (_metrics.content.x > _metrics.container.x || _instanceOptions.alwaysScroll)) {\n\t\t\t\t_scrollableAxes.x = true;\n\t\t\t}\n\t\t\tif (_instanceOptions.scrollingY && (_metrics.content.y > _metrics.container.y || _instanceOptions.alwaysScroll)) {\n\t\t\t\t_scrollableAxes.y = true;\n\t\t\t}\n\t\t};\n\n\t\t_updateElementPosition = function _updateElementPosition() {\n\t\t\tvar axis, computedStyle, splitStyle;\n\n\t\t\t// Retrieve the current position of each active axis.\n\t\t\t// Custom parsing is used instead of native matrix support for speed and for\n\t\t\t// backwards compatibility.\n\t\t\tfor (axis in _scrollableAxes) {\n\t\t\t\tif (_scrollableAxes.hasOwnProperty(axis)) {\n\t\t\t\t\tcomputedStyle = window.getComputedStyle(_scrollNodes[axis], null)[_vendorTransformLookup];\n\t\t\t\t\tsplitStyle = computedStyle.split(', ');\n\n\t\t\t\t\t// For 2d-style transforms, pull out elements four or five\n\t\t\t\t\tif (splitStyle.length === 6) {\n\t\t\t\t\t\t_baseScrollPosition[axis] = parseInt(splitStyle[(axis === 'y') ? 5 : 4], 10);\n\n\t\t\t\t\t// For 3d-style transforms, pull out elements twelve or thirteen\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_baseScrollPosition[axis] = parseInt(splitStyle[(axis === 'y') ? 13 : 12], 10);\n\t\t\t\t\t}\n\t\t\t\t\t_lastScrollPosition[axis] = _baseScrollPosition[axis];\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t_updateSegments = function _updateSegments(scrollFinalised) {\n\t\t\tvar axis;\n\t\t\tvar newSegment = { x: 0, y: 0 };\n\n\t\t\t// If snapping is disabled, return without any further action required\n\t\t\tif (!_instanceOptions.snapping) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Calculate the new segments\n\t\t\tfor (axis in _scrollableAxes) {\n\t\t\t\tif (_scrollableAxes.hasOwnProperty(axis)) {\n\t\t\t\t\tnewSegment[axis] = Math.max(0, Math.min(Math.ceil(_metrics.content[axis] / _snapGridSize[axis]) - 1, Math.round(-_lastScrollPosition[axis] / _snapGridSize[axis])));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// In all cases update the active segment if appropriate\n\t\t\tif (newSegment.x !== _activeSegment.x || newSegment.y !== _activeSegment.y) {\n\t\t\t\t_activeSegment.x = newSegment.x;\n\t\t\t\t_activeSegment.y = newSegment.y;\n\t\t\t\t_fireEvent('segmentwillchange', { segmentX: newSegment.x, segmentY: newSegment.y });\n\t\t\t}\n\n\t\t\t// If the scroll has been finalised, also update the base segment\n\t\t\tif (scrollFinalised) {\n\t\t\t\tif (newSegment.x !== _baseSegment.x || newSegment.y !== _baseSegment.y) {\n\t\t\t\t\t_baseSegment.x = newSegment.x;\n\t\t\t\t\t_baseSegment.y = newSegment.y;\n\t\t\t\t\t_fireEvent('segmentdidchange', { segmentX: newSegment.x, segmentY: newSegment.y });\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t_setAxisPosition = function _setAxisPosition(axis, position, animationDuration, animationBezier, boundsCrossDelay) {\n\t\t\tvar transitionCSSString, newPositionAtExtremity = null;\n\n\t\t\t// Only update position if the axis node exists (DOM elements can go away if\n\t\t\t// the scroller instance is not destroyed correctly)\n\t\t\tif (!_scrollNodes[axis]) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Determine the transition property to apply to both the scroll element and the scrollbar\n\t\t\tif (animationDuration) {\n\t\t\t\tif (!animationBezier) {\n\t\t\t\t\tanimationBezier = _instanceOptions.flingBezier;\n\t\t\t\t}\n\n\t\t\t\ttransitionCSSString = _vendorCSSPrefix + 'transform ' + animationDuration + 'ms ' + animationBezier.toString();\n\t\t\t} else {\n\t\t\t\ttransitionCSSString = '';\n\t\t\t}\n\n\t\t\t// Apply the transition property to elements\n\t\t\t_scrollNodes[axis].style[_transitionProperty] = transitionCSSString;\n\t\t\tif (_instanceOptions.scrollbars) {\n\t\t\t\t_scrollbarNodes[axis].style[_transitionProperty] = transitionCSSString;\n\t\t\t}\n\n\t\t\t// Update the positions\n\t\t\t_scrollNodes[axis].style[_transformProperty] = _translateRulePrefix + _transformPrefixes[axis] + position + 'px' + _transformSuffixes[axis];\n\t\t\tif (_instanceOptions.scrollbars) {\n\t\t\t\t_scrollbarNodes[axis].style[_transformProperty] = _translateRulePrefix + _transformPrefixes[axis] + (-position * _metrics.container[axis] / _metrics.content[axis]) + 'px' + _transformSuffixes[axis];\n\t\t\t}\n\n\t\t\t// Determine whether the scroll is at an extremity.\n\t\t\tif (position >= 0) {\n\t\t\t\tnewPositionAtExtremity = 'start';\n\t\t\t} else if (position <= _metrics.scrollEnd[axis]) {\n\t\t\t\tnewPositionAtExtremity = 'end';\n\t\t\t}\n\n\t\t\t// If the extremity status has changed, fire an appropriate event\n\t\t\tif (newPositionAtExtremity !== _scrollAtExtremity[axis]) {\n\t\t\t\tif (newPositionAtExtremity !== null) {\n\t\t\t\t\tif (animationDuration) {\n\t\t\t\t\t\t_timeouts.push(setTimeout(function() {\n\t\t\t\t\t\t\t_fireEvent('reached' + newPositionAtExtremity, { axis: axis });\n\t\t\t\t\t\t}, boundsCrossDelay || animationDuration));\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_fireEvent('reached' + newPositionAtExtremity, { axis: axis });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_scrollAtExtremity[axis] = newPositionAtExtremity;\n\t\t\t}\n\n\t\t\t// Update the recorded position if there's no duration\n\t\t\tif (!animationDuration) {\n\t\t\t\t_lastScrollPosition[axis] = position;\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Retrieve the current position as an object with scrollLeft and scrollTop\n\t\t * properties.\n\t\t */\n\t\t_getPosition = function _getPosition() {\n\t\t\treturn {\n\t\t\t\tscrollLeft: -_lastScrollPosition.x,\n\t\t\t\tscrollTop: -_lastScrollPosition.y\n\t\t\t};\n\t\t};\n\n\t\t_scheduleAxisPosition = function _scheduleAxisPosition(axis, position, animationDuration, animationBezier, afterDelay) {\n\t\t\t_timeouts.push(setTimeout(function () {\n\t\t\t\t_setAxisPosition(axis, position, animationDuration, animationBezier);\n\t\t\t}, afterDelay));\n\t\t};\n\n\t\t_fireEvent = function _fireEvent(eventName, eventObject) {\n\t\t\tvar i, l;\n\t\t\teventObject.srcObject = _publicSelf;\n\n\t\t\t// Iterate through any listeners\n\t\t\tfor (i = 0, l = _eventListeners[eventName].length; i < l; i = i + 1) {\n\n\t\t\t\t// Execute each in a try/catch\n\t\t\t\ttry {\n\t\t\t\t\t_eventListeners[eventName][i](eventObject);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tif (window.console && window.console.error) {\n\t\t\t\t\t\tif (error.message) {\n\t\t\t\t\t\t\twindow.console.error(error.message + ' (' + error.sourceURL + ', line ' + error.line + ')');\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twindow.console.error('Error encountered executing FTScroller event listener callback for [' + eventName + ']. Add a \"debugger\" statement here to obtain a full backtrace.');\n\t\t\t\t\t\t\tif (window.console.dir) window.console.dir(error);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Update the scroll position so that the child element is in view.\n\t\t */\n\t\t_childFocused = function _childFocused(event) {\n\t\t\tvar offset, axis, visibleChildPortion;\n\t\t\tvar focusedNodeRect = _getBoundingRect(event.target);\n\t\t\tvar containerRect = _getBoundingRect(_containerNode);\n\t\t\tvar edgeMap = { x: 'left', y: 'top' };\n\t\t\tvar opEdgeMap = { x: 'right', y: 'bottom' };\n\t\t\tvar dimensionMap = { x: 'width', y: 'height' };\n\n\t\t\t// If an input is currently being tracked, ignore the focus event\n\t\t\tif (_inputIdentifier !== false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (axis in _scrollableAxes) {\n\t\t\t\tif (_scrollableAxes.hasOwnProperty(axis)) {\n\n\t\t\t\t\t// If the focussed node is entirely in view, there is no need to center it\n\t\t\t\t\tif (focusedNodeRect[edgeMap[axis]] >= containerRect[edgeMap[axis]] && focusedNodeRect[opEdgeMap[axis]] <= containerRect[opEdgeMap[axis]]) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If the focussed node is larger than the container...\n\t\t\t\t\tif (focusedNodeRect[dimensionMap[axis]] > containerRect[dimensionMap[axis]]) {\n\n\t\t\t\t\t\tvisibleChildPortion = focusedNodeRect[dimensionMap[axis]] - Math.max(0, containerRect[edgeMap[axis]] - focusedNodeRect[edgeMap[axis]]) - Math.max(0, focusedNodeRect[opEdgeMap[axis]] - containerRect[opEdgeMap[axis]]);\n\n\t\t\t\t\t\t// If more than half a container's portion of the focussed node is visible, there's no need to center it\n\t\t\t\t\t\tif (visibleChildPortion >= (containerRect[dimensionMap[axis]] / 2)) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Set the target offset to be in the middle of the container, or as close as bounds permit\n\t\t\t\t\toffset = -Math.round((focusedNodeRect[dimensionMap[axis]] / 2) - _lastScrollPosition[axis] + focusedNodeRect[edgeMap[axis]] - containerRect[edgeMap[axis]]  - (containerRect[dimensionMap[axis]] / 2));\n\t\t\t\t\toffset = Math.min(0, Math.max(_metrics.scrollEnd[axis], offset));\n\n\t\t\t\t\t// Perform the scroll\n\t\t\t\t\t_setAxisPosition(axis, offset, 0);\n\t\t\t\t\t_baseScrollPosition[axis] = offset;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconsole.log('firing scroll event from _childFocused');\n\t\t\t_fireEvent('scroll', _getPosition());\n\t\t};\n\n\t\t/**\n\t\t * Given a relative distance beyond the element bounds, returns a modified version to\n\t\t * simulate bouncy/springy edges.\n\t\t */\n\t\t_modifyDistanceBeyondBounds = function _modifyDistanceBeyondBounds(distance, axis) {\n\t\t\tif (!_instanceOptions.bouncing) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tvar e = Math.exp(distance / _metrics.container[axis]);\n\t\t\treturn Math.round(_metrics.container[axis] * 0.6 * (e - 1) / (e + 1));\n\t\t};\n\n\t\t/**\n\t\t * Given positions for each enabled axis, returns an object showing how far each axis is beyond\n\t\t * bounds. If within bounds, -1 is returned; if at the bounds, 0 is returned.\n\t\t */\n\t\t_distancesBeyondBounds = function _distancesBeyondBounds(positions) {\n\t\t\tvar axis, position;\n\t\t\tvar distances = {};\n\t\t\tfor (axis in positions) {\n\t\t\t\tif (positions.hasOwnProperty(axis)) {\n\t\t\t\t\tposition = positions[axis];\n\n\t\t\t\t\t// If the position is to the left/top, no further modification required\n\t\t\t\t\tif (position >= 0) {\n\t\t\t\t\t\tdistances[axis] = position;\n\n\t\t\t\t\t// If it's within the bounds, use -1\n\t\t\t\t\t} else if (position > _metrics.scrollEnd[axis]) {\n\t\t\t\t\t\tdistances[axis] = -1;\n\n\t\t\t\t\t// Otherwise, amend by the distance of the maximum edge\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdistances[axis] = _metrics.scrollEnd[axis] - position;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn distances;\n\t\t};\n\n\t\t/**\n\t\t * On platforms which support it, use RequestAnimationFrame to group\n\t\t * position updates for speed.  Starts the render process.\n\t\t */\n\t\t_startAnimation = function _startAnimation() {\n\t\t\tif (_reqAnimationFrame) {\n\t\t\t\t_cancelAnimation();\n\t\t\t\t_animationFrameRequest = _reqAnimationFrame(_scheduleRender);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * On platforms which support RequestAnimationFrame, provide the rendering loop.\n\t\t * Takes two arguments; the first is the render/position update function to\n\t\t * be called, and the second is a string controlling the render type to\n\t\t * allow previous changes to be cancelled - should be 'pan' or 'scroll'.\n\t\t */\n\t\t_scheduleRender = function _scheduleRender() {\n\t\t\tvar axis, positionUpdated;\n\n\t\t\t// If using requestAnimationFrame schedule the next update at once\n\t\t\tif (_reqAnimationFrame) {\n\t\t\t\t_animationFrameRequest = _reqAnimationFrame(_scheduleRender);\n\t\t\t}\n\n\t\t\t// Perform the draw.\n\t\t\tfor (axis in _scrollableAxes) {\n\t\t\t\tif (_scrollableAxes.hasOwnProperty(axis) && _targetScrollPosition[axis] !== _lastScrollPosition[axis]) {\n\t\t\t\t\t_setAxisPosition(axis, _targetScrollPosition[axis]);\n\t\t\t\t\tpositionUpdated = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If full, locked scrolling has enabled, fire any scroll and segment change events\n\t\t\tif (_isScrolling && positionUpdated) {\n\t\t\t\tconsole.log('firing scroll event from _scheduleRender');\n\t\t\t\t_fireEvent('scroll', _getPosition());\n\t\t\t\t_updateSegments(false);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Stops the animation process.\n\t\t */\n\t\t_cancelAnimation = function _cancelAnimation() {\n\t\t\tif (_animationFrameRequest === false || !_cancelAnimationFrame) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_cancelAnimationFrame(_animationFrameRequest);\n\t\t\t_animationFrameRequest = false;\n\t\t};\n\n\t\t/**\n\t\t * Remove then re-set event handlers\n\t\t */\n\t\t_resetEventHandlers = function() {\n\t\t\t_removeEventHandlers();\n\t\t\t_addEventHandlers();\n\t\t};\n\n\t\t/**\n\t\t * Register event handlers\n\t\t */\n\t\t_addEventHandlers = function _addEventHandlers() {\n\t\t\tvar MutationObserver;\n\n\t\t\t// Only remove the event if the node exists (DOM elements can go away)\n\t\t\tif (!_containerNode) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (_trackPointerEvents && !_instanceOptions.disabledInputMethods.pointer) {\n\t\t\t\tif (_pointerEventsPrefixed) {\n\t\t\t\t\t_containerNode.addEventListener('MSPointerDown', _onPointerDown);\n\t\t\t\t\t_containerNode.addEventListener('MSPointerMove', _onPointerMove);\n\t\t\t\t\t_containerNode.addEventListener('MSPointerUp', _onPointerUp);\n\t\t\t\t\t_containerNode.addEventListener('MSPointerCancel', _onPointerCancel);\n\t\t\t\t} else {\n\t\t\t\t\t_containerNode.addEventListener('pointerdown', _onPointerDown);\n\t\t\t\t\t_containerNode.addEventListener('pointermove', _onPointerMove);\n\t\t\t\t\t_containerNode.addEventListener('pointerup', _onPointerUp);\n\t\t\t\t\t_containerNode.addEventListener('pointercancel', _onPointerCancel);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (_trackTouchEvents && !_instanceOptions.disabledInputMethods.touch) {\n\t\t\t\t\t_containerNode.addEventListener('touchstart', _onTouchStart);\n\t\t\t\t\t_containerNode.addEventListener('touchmove', _onTouchMove);\n\t\t\t\t\t_containerNode.addEventListener('touchend', _onTouchEnd);\n\t\t\t\t\t_containerNode.addEventListener('touchcancel', _onTouchEnd);\n\t\t\t\t}\n\t\t\t\tif (!_instanceOptions.disabledInputMethods.mouse) {\n\t\t\t\t\t_containerNode.addEventListener('mousedown', _onMouseDown);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!_instanceOptions.disabledInputMethods.scroll) {\n\t\t\t\t_containerNode.addEventListener('DOMMouseScroll', _onMouseScroll);\n\t\t\t\t_containerNode.addEventListener('mousewheel', _onMouseScroll);\n\t\t\t}\n\n\t\t\t// If any of the input methods which would eventually trigger a click are\n\t\t\t// enabled, add a click event listener so that phantom clicks can be prevented\n\t\t\t// at the end of a scroll. Otherwise, don't add a listener and don't prevent\n\t\t\t// clicks.\n\t\t\tif (!_instanceOptions.disabledInputMethods.mouse || !_instanceOptions.disabledInputMethods.touch || !_instanceOptions.disabledInputMethods.pointer) {\n\n\t\t\t\t// Add a click listener.  On IE, add the listener to the document, to allow\n\t\t\t\t// clicks to be cancelled if a scroll ends outside the bounds of the container; on\n\t\t\t\t// other platforms, add to the container node.\n\t\t\t\tif (_trackPointerEvents) {\n\t\t\t\t\tdocument.addEventListener('click', _onClick, true);\n\t\t\t\t} else {\n\t\t\t\t\t_containerNode.addEventListener('click', _onClick, true);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Watch for changes inside the contained element to update bounds - de-bounced slightly.\n\t\t\tif (!_instanceOptions.disabledInputMethods.focus) {\n\t\t\t\t_contentParentNode.addEventListener('focus', _childFocused);\n\t\t\t}\n\t\t\tif (_instanceOptions.updateOnChanges) {\n\n\t\t\t\t// Try and reuse the old, disconnected observer instance if available\n\t\t\t\t// Otherwise, check for support before proceeding\n\t\t\t\tif (!_mutationObserver) {\n\t\t\t\t\tMutationObserver = window.MutationObserver || window.WebKitMutationObserver || window[_vendorStylePropertyPrefix + 'MutationObserver'];\n\t\t\t\t\tif (MutationObserver) {\n\t\t\t\t\t\t_mutationObserver = new MutationObserver(_domChanged);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (_mutationObserver) {\n\t\t\t\t\t_mutationObserver.observe(_contentParentNode, {\n\t\t\t\t\t\tchildList: true,\n\t\t\t\t\t\tcharacterData: true,\n\t\t\t\t\t\tsubtree: true\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\t_contentParentNode.addEventListener('DOMSubtreeModified', function (e) {\n\n\t\t\t\t\t\t// Ignore changes to nested FT Scrollers - even updating a transform style\n\t\t\t\t\t\t// can trigger a DOMSubtreeModified in IE, causing nested scrollers to always\n\t\t\t\t\t\t// favour the deepest scroller as parent scrollers 'resize'/end scrolling.\n\t\t\t\t\t\tif (e && (e.srcElement === _contentParentNode || e.srcElement.className.indexOf('ftscroller_') !== -1)) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_domChanged();\n\t\t\t\t\t}, true);\n\t\t\t\t}\n\t\t\t\t_contentParentNode.addEventListener('load', _domChanged);\n\t\t\t}\n\t\t\tif (_instanceOptions.updateOnWindowResize) {\n\t\t\t\twindow.addEventListener('resize', _domChanged);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Remove event handlers.\n\t\t *\n\t\t * The current flags may not match the state when the event handlers were set up,\n\t\t * so remove all event handlers unconditionally, just in case they're bound.\n\t\t */\n\t\t_removeEventHandlers = function _removeEventHandlers() {\n\n\t\t\tif (_containerNode) {\n\t\t\t\t_containerNode.removeEventListener('MSPointerDown', _onPointerDown);\n\t\t\t\t_containerNode.removeEventListener('MSPointerMove', _onPointerMove);\n\t\t\t\t_containerNode.removeEventListener('MSPointerUp', _onPointerUp);\n\t\t\t\t_containerNode.removeEventListener('MSPointerCancel', _onPointerCancel);\n\t\t\t\t_containerNode.removeEventListener('pointerdown', _onPointerDown);\n\t\t\t\t_containerNode.removeEventListener('pointermove', _onPointerMove);\n\t\t\t\t_containerNode.removeEventListener('pointerup', _onPointerUp);\n\t\t\t\t_containerNode.removeEventListener('pointercancel', _onPointerCancel);\n\t\t\t\t_containerNode.removeEventListener('touchstart', _onTouchStart);\n\t\t\t\t_containerNode.removeEventListener('touchmove', _onTouchMove);\n\t\t\t\t_containerNode.removeEventListener('touchend', _onTouchEnd);\n\t\t\t\t_containerNode.removeEventListener('touchcancel', _onTouchEnd);\n\t\t\t\t_containerNode.removeEventListener('mousedown', _onMouseDown);\n\t\t\t\t_containerNode.removeEventListener('DOMMouseScroll', _onMouseScroll);\n\t\t\t\t_containerNode.removeEventListener('mousewheel', _onMouseScroll);\n\t\t\t\t_containerNode.removeEventListener('click', _onClick, true);\n\t\t\t}\n\n\t\t\tif (_contentParentNode) {\n\t\t\t\t_contentParentNode.removeEventListener('focus', _childFocused);\n\t\t\t\t_contentParentNode.removeEventListener('DOMSubtreeModified', _domChanged);\n\t\t\t\t_contentParentNode.removeEventListener('load', _domChanged);\n\t\t\t}\n\n\t\t\tif (_mutationObserver) {\n\t\t\t\t_mutationObserver.disconnect();\n\t\t\t}\n\n\t\t\tdocument.removeEventListener('mousemove', _onMouseMove);\n\t\t\tdocument.removeEventListener('mouseup', _onMouseUp);\n\t\t\tdocument.removeEventListener('click', _onClick, true);\n\t\t\twindow.removeEventListener('resize', _domChanged);\n\t\t};\n\n\t\t/**\n\t\t * Touch event handlers\n\t\t */\n\t\t_onTouchStart = function _onTouchStart(startEvent) {\n\t\t\tvar i, l, touchEvent;\n\n\t\t\t// If a touch is already active, ensure that the index\n\t\t\t// is mapped to the correct finger, and return.\n\t\t\tif (_inputIdentifier) {\n\t\t\t\tfor (i = 0, l = startEvent.touches.length; i < l; i = i + 1) {\n\t\t\t\t\tif (startEvent.touches[i].identifier === _inputIdentifier) {\n\t\t\t\t\t\t_inputIndex = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Track the new touch's identifier, reset index, and pass\n\t\t\t// the coordinates to the scroll start function.\n\t\t\ttouchEvent = startEvent.touches[0];\n\t\t\t_inputIdentifier = touchEvent.identifier;\n\t\t\t_inputIndex = 0;\n\t\t\t_startScroll(touchEvent.clientX, touchEvent.clientY, startEvent.timeStamp, startEvent);\n\t\t};\n\t\t_onTouchMove = function _onTouchMove(moveEvent) {\n\t\t\tif (_inputIdentifier === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Get the coordinates from the appropriate touch event and\n\t\t\t// pass them on to the scroll handler\n\t\t\tvar touchEvent = moveEvent.touches[_inputIndex];\n\t\t\t_updateScroll(touchEvent.clientX, touchEvent.clientY, moveEvent.timeStamp, moveEvent);\n\t\t};\n\t\t_onTouchEnd = function _onTouchEnd(endEvent) {\n\t\t\tvar i, l;\n\n\t\t\t// Check whether the original touch event is still active,\n\t\t\t// if it is, update the index and return.\n\t\t\tif (endEvent.touches) {\n\t\t\t\tfor (i = 0, l = endEvent.touches.length; i < l; i = i + 1) {\n\t\t\t\t\tif (endEvent.touches[i].identifier === _inputIdentifier) {\n\t\t\t\t\t\t_inputIndex = i;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Complete the scroll.  Note that touch end events\n\t\t\t// don't capture coordinates.\n\t\t\t_endScroll(endEvent.timeStamp, endEvent);\n\t\t};\n\n\t\t/**\n\t\t * Mouse event handlers\n\t\t */\n\t\t_onMouseDown = function _onMouseDown(startEvent) {\n\n\t\t\t// Don't track the right mouse buttons, or a context menu\n\t\t\tif ((startEvent.button && startEvent.button === 2) || startEvent.ctrlKey) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Capture if possible\n\t\t\tif (_containerNode.setCapture) {\n\t\t\t\t_containerNode.setCapture();\n\t\t\t}\n\n\t\t\t// Add move & up handlers to the *document* to allow handling outside the element\n\t\t\tdocument.addEventListener('mousemove', _onMouseMove, true);\n\t\t\tdocument.addEventListener('mouseup', _onMouseUp, true);\n\n\t\t\t_inputIdentifier = startEvent.button || 1;\n\t\t\t_inputIndex = 0;\n\t\t\t_startScroll(startEvent.clientX, startEvent.clientY, startEvent.timeStamp, startEvent);\n\t\t};\n\t\t_onMouseMove = function _onMouseMove(moveEvent) {\n\t\t\tif (!_inputIdentifier) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_updateScroll(moveEvent.clientX, moveEvent.clientY, moveEvent.timeStamp, moveEvent);\n\t\t};\n\t\t_onMouseUp = function _onMouseUp(endEvent) {\n\t\t\tif (endEvent.button && endEvent.button !== _inputIdentifier) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tdocument.removeEventListener('mousemove', _onMouseMove, true);\n\t\t\tdocument.removeEventListener('mouseup', _onMouseUp, true);\n\n\t\t\t// Release capture if possible\n\t\t\tif (_containerNode.releaseCapture) {\n\t\t\t\t_containerNode.releaseCapture();\n\t\t\t}\n\n\t\t\t_endScroll(endEvent.timeStamp, endEvent);\n\t\t};\n\n\t\t/**\n\t\t * Pointer event handlers\n\t\t */\n\t\t_onPointerDown = function _onPointerDown(startEvent) {\n\n\t\t\t// If there is already a pointer event being tracked, ignore subsequent.\n\t\t\t// However, if this pointer is seen as the primary pointer, override that.\n\t\t\tif (_inputIdentifier && !startEvent.isPrimary) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Disable specific input types if specified in the config.  Separate\n\t\t\t// out touch and other events (eg treat both pen and mouse as \"mouse\")\n\t\t\tif (startEvent.pointerType === _pointerTypeTouch) {\n\t\t\t\tif (_instanceOptions.disabledInputMethods.touch) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else if (_instanceOptions.disabledInputMethods.mouse) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_inputIdentifier = startEvent.pointerId;\n\t\t\t_startScroll(startEvent.clientX, startEvent.clientY, startEvent.timeStamp, startEvent);\n\t\t};\n\t\t_onPointerMove = function _onPointerMove(moveEvent) {\n\t\t\tif (_inputIdentifier !== moveEvent.pointerId) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t_updateScroll(moveEvent.clientX, moveEvent.clientY, moveEvent.timeStamp, moveEvent);\n\t\t};\n\t\t_onPointerUp = function _onPointerUp(endEvent) {\n\t\t\tif (_inputIdentifier !== endEvent.pointerId) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_endScroll(endEvent.timeStamp, endEvent);\n\t\t};\n\t\t_onPointerCancel = function _onPointerCancel(endEvent) {\n\t\t\t_endScroll(endEvent.timeStamp, endEvent);\n\t\t};\n\t\t_onPointerCaptureEnd = function _onPointerCaptureEnd(event) {\n\n\t\t\t// On pointer capture end - which can happen because of another element\n\t\t\t// releasing pointer capture - don't end scrolling, but do track that\n\t\t\t// input capture has been lost.  This will result in pointers leaving\n\t\t\t// the window possibly being lost, but further interactions will fix\n\t\t\t// the tracking again.\n\t\t\t_inputCaptured = false;\n\t\t};\n\n\n\t\t/**\n\t\t * Prevents click actions if appropriate\n\t\t */\n\t\t_onClick = function _onClick(clickEvent) {\n\n\t\t\t// If a scroll action hasn't resulted in the next scroll being prevented, and a scroll\n\t\t\t// isn't currently in progress with a different identifier, allow the click\n\t\t\tif (!_preventClick) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// Prevent clicks using the preventDefault() and stopPropagation() handlers on the event;\n\t\t\t// this is safe even in IE10 as this is always a \"true\" event, never a window.event.\n\t\t\tclickEvent.preventDefault();\n\t\t\tclickEvent.stopPropagation();\n\t\t\tif (!_inputIdentifier) {\n\t\t\t\t_preventClick = false;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\n\t\t/**\n\t\t * Process scroll wheel/input actions as scroller scrolls\n\t\t */\n\t\t_onMouseScroll = function _onMouseScroll(event) {\n\t\t\tvar scrollDeltaX, scrollDeltaY;\n\t\t\tif (_inputIdentifier !== 'scrollwheel') {\n\t\t\t\tif (_inputIdentifier !== false) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t_inputIdentifier = 'scrollwheel';\n\t\t\t\t_cumulativeScroll.x = 0;\n\t\t\t\t_cumulativeScroll.y = 0;\n\n\t\t\t\t// Start a scroll event\n\t\t\t\tif (!_startScroll(event.clientX, event.clientY, Date.now(), event)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Convert the scrollwheel values to a scroll value\n\t\t\tif (event.wheelDelta) {\n\t\t\t\tif (event.wheelDeltaX) {\n\t\t\t\t\tscrollDeltaX = event.wheelDeltaX / 2;\n\t\t\t\t\tscrollDeltaY = event.wheelDeltaY / 2;\n\t\t\t\t} else {\n\t\t\t\t\tscrollDeltaX = 0;\n\t\t\t\t\tscrollDeltaY = event.wheelDelta / 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (event.axis && event.axis === event.HORIZONTAL_AXIS) {\n\t\t\t\t\tscrollDeltaX = event.detail * -10;\n\t\t\t\t\tscrollDeltaY = 0;\n\t\t\t\t} else {\n\t\t\t\t\tscrollDeltaX = 0;\n\t\t\t\t\tscrollDeltaY = event.detail * -10;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If the scroller is constrained to an x axis, convert y scroll to allow single-axis scroll\n\t\t\t// wheels to scroll constrained content.\n\t\t\tif (!_instanceOptions.scrollingY && !scrollDeltaX) {\n\t\t\t\tscrollDeltaX = scrollDeltaY;\n\t\t\t\tscrollDeltaY = 0;\n\t\t\t}\n\n\t\t\t_cumulativeScroll.x = Math.round(_cumulativeScroll.x + scrollDeltaX);\n\t\t\t_cumulativeScroll.y = Math.round(_cumulativeScroll.y + scrollDeltaY);\n\n\t\t\t_updateScroll(_gestureStart.x + _cumulativeScroll.x, _gestureStart.y + _cumulativeScroll.y, event.timeStamp, event);\n\n\t\t\t// End scrolling state\n\t\t\tif (_scrollWheelEndDebouncer) {\n\t\t\t\tclearTimeout(_scrollWheelEndDebouncer);\n\t\t\t}\n\t\t\t_scrollWheelEndDebouncer = setTimeout(function () {\n\t\t\t\t_releaseInputCapture();\n\t\t\t\t_inputIdentifier = false;\n\t\t\t\t_isScrolling = false;\n\t\t\t\t_preventClick = false;\n\t\t\t\t_isDisplayingScroll = false;\n\t\t\t\t_ftscrollerMoving = false;\n\t\t\t\tif (_instanceOptions.windowScrollingActiveFlag) {\n\t\t\t\t\twindow[_instanceOptions.windowScrollingActiveFlag] = false;\n\t\t\t\t}\n\t\t\t\t_cancelAnimation();\n\t\t\t\tif (!_snapScroll()) {\n\t\t\t\t\t_finalizeScroll();\n\t\t\t\t}\n\t\t\t}, 300);\n\t\t};\n\n\t\t/**\n\t\t * Capture and release input support, particularly allowing tracking\n\t\t * of Metro pointers outside the docked view.  Note that _releaseInputCapture\n\t\t * should be called before the input identifier is cleared.\n\t\t */\n\t\t_captureInput = function _captureInput() {\n\t\t\tif (_inputCaptured || _inputIdentifier === false || _inputIdentifier === 'scrollwheel') {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (_trackPointerEvents) {\n\t\t\t\t_containerNode[_setPointerCapture](_inputIdentifier);\n\t\t\t\t_containerNode.addEventListener(_lostPointerCapture, _onPointerCaptureEnd, false);\n\t\t\t}\n\t\t\t_inputCaptured = true;\n\t\t};\n\t\t_releaseInputCapture = function _releaseInputCapture() {\n\t\t\tif (!_inputCaptured) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (_trackPointerEvents) {\n\t\t\t\t_containerNode.removeEventListener(_lostPointerCapture, _onPointerCaptureEnd, false);\n\t\t\t\t_containerNode[_releasePointerCapture](_inputIdentifier);\n\t\t\t}\n\t\t\t_inputCaptured = false;\n\t\t};\n\n\t\t/**\n\t\t * Utility function acting as a getBoundingClientRect polyfill.\n\t\t */\n\t\t_getBoundingRect = function _getBoundingRect(anElement) {\n\t\t\tif (anElement.getBoundingClientRect) {\n\t\t\t\treturn anElement.getBoundingClientRect();\n\t\t\t}\n\n\t\t\tvar x = 0, y = 0, eachElement = anElement;\n\t\t\twhile (eachElement) {\n\t\t\t\tx = x + eachElement.offsetLeft - eachElement.scrollLeft;\n\t\t\t\ty = y + eachElement.offsetTop - eachElement.scrollTop;\n\t\t\t\teachElement = eachElement.offsetParent;\n\t\t\t}\n\t\t\treturn { left: x, top: y, width: anElement.offsetWidth, height: anElement.offsetHeight };\n\t\t};\n\n\n\t\t/*                     Instantiation                     */\n\n\t\t// Set up the DOM node if appropriate\n\t\t_initializeDOM();\n\n\t\t// Update sizes\n\t\t_updateDimensions();\n\n\t\t// Set up the event handlers\n\t\t_addEventHandlers();\n\n\t\t// Define a public API to be returned at the bottom - this is the public-facing interface.\n\t\t_publicSelf = {\n\t\t\tdestroy: destroy,\n\t\t\tsetSnapSize: setSnapSize,\n\t\t\tscrollTo: scrollTo,\n\t\t\tscrollBy: scrollBy,\n\t\t\tupdateDimensions: updateDimensions,\n\t\t\taddEventListener: addEventListener,\n\t\t\tremoveEventListener: removeEventListener,\n\t\t\tsetDisabledInputMethods: setDisabledInputMethods\n\t\t};\n\n\t\tif (Object.defineProperties) {\n\t\t\tObject.defineProperties(_publicSelf, {\n\t\t\t\t'scrollHeight': {\n\t\t\t\t\tget: function() { return _metrics.content.y; },\n\t\t\t\t\tset: function(value) { throw new SyntaxError('scrollHeight is currently read-only - ignoring ' + value); }\n\t\t\t\t},\n\t\t\t\t'scrollLeft': {\n\t\t\t\t\tget: function() { return -_lastScrollPosition.x; },\n\t\t\t\t\tset: function(value) { scrollTo(value, false, false); return -_lastScrollPosition.x; }\n\t\t\t\t},\n\t\t\t\t'scrollTop': {\n\t\t\t\t\tget: function() { return -_lastScrollPosition.y; },\n\t\t\t\t\tset: function(value) { scrollTo(false, value, false); return -_lastScrollPosition.y; }\n\t\t\t\t},\n\t\t\t\t'scrollWidth': {\n\t\t\t\t\tget: function() { return _metrics.content.x; },\n\t\t\t\t\tset: function(value) { throw new SyntaxError('scrollWidth is currently read-only - ignoring ' + value); }\n\t\t\t\t},\n\t\t\t\t'segmentCount': {\n\t\t\t\t\tget: function() {\n\t\t\t\t\t\tif (!_instanceOptions.snapping) {\n\t\t\t\t\t\t\treturn { x: NaN, y: NaN };\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tx: Math.ceil(_metrics.content.x / _snapGridSize.x),\n\t\t\t\t\t\t\ty: Math.ceil(_metrics.content.y / _snapGridSize.y)\n\t\t\t\t\t\t};\n\t\t\t\t\t},\n\t\t\t\t\tset: function(value) { throw new SyntaxError('segmentCount is currently read-only - ignoring ' + value); }\n\t\t\t\t},\n\t\t\t\t'currentSegment': {\n\t\t\t\t\tget: function() { return { x: _activeSegment.x, y: _activeSegment.y }; },\n\t\t\t\t\tset: function(value) { throw new SyntaxError('currentSegment is currently read-only - ignoring ' + value); }\n\t\t\t\t},\n\t\t\t\t'contentContainerNode': {\n\t\t\t\t\tget: function() { return _contentParentNode; },\n\t\t\t\t\tset: function(value) { throw new SyntaxError('contentContainerNode is currently read-only - ignoring ' + value); }\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// Return the public interface.\n\t\treturn _publicSelf;\n\t};\n\n\n\t/*          Prototype Functions and Properties           */\n\n\t/**\n\t * The HTML to prepend to the scrollable content to wrap it. Used internally,\n\t * and may be used to pre-wrap scrollable content.  Axes can optionally\n\t * be excluded for speed improvements.\n\t */\n\tFTScroller.prototype.getPrependedHTML = function (excludeXAxis, excludeYAxis, hwAccelerationClass) {\n\t\tif (!hwAccelerationClass) {\n\t\t\tif (typeof FTScrollerOptions === 'object' && FTScrollerOptions.hwAccelerationClass) {\n\t\t\t\thwAccelerationClass = FTScrollerOptions.hwAccelerationClass;\n\t\t\t} else {\n\t\t\t\thwAccelerationClass = 'ftscroller_hwaccelerated';\n\t\t\t}\n\t\t}\n\n\t\tvar output = '<div class=\"ftscroller_container\">';\n\t\tif (!excludeXAxis) {\n\t\t\toutput += '<div class=\"ftscroller_x ' + hwAccelerationClass + '\">';\n\t\t}\n\t\tif (!excludeYAxis) {\n\t\t\toutput += '<div class=\"ftscroller_y ' + hwAccelerationClass + '\">';\n\t\t}\n\n\t\treturn output;\n\t};\n\n\t/**\n\t * The HTML to append to the scrollable content to wrap it; again, used internally,\n\t * and may be used to pre-wrap scrollable content.\n\t */\n\tFTScroller.prototype.getAppendedHTML = function (excludeXAxis, excludeYAxis, hwAccelerationClass, scrollbars) {\n\t\tif (!hwAccelerationClass) {\n\t\t\tif (typeof FTScrollerOptions === 'object' && FTScrollerOptions.hwAccelerationClass) {\n\t\t\t\thwAccelerationClass = FTScrollerOptions.hwAccelerationClass;\n\t\t\t} else {\n\t\t\t\thwAccelerationClass = 'ftscroller_hwaccelerated';\n\t\t\t}\n\t\t}\n\n\t\tvar output = '';\n\t\tif (!excludeXAxis) {\n\t\t\toutput += '</div>';\n\t\t}\n\t\tif (!excludeYAxis) {\n\t\t\toutput += '</div>';\n\t\t}\n\t\tif (scrollbars) {\n\t\t\tif (!excludeXAxis) {\n\t\t\t\toutput += '<div class=\"ftscroller_scrollbar ftscroller_scrollbarx ' + hwAccelerationClass + '\"><div class=\"ftscroller_scrollbarinner\"></div></div>';\n\t\t\t}\n\t\t\tif (!excludeYAxis) {\n\t\t\t\toutput += '<div class=\"ftscroller_scrollbar ftscroller_scrollbary ' + hwAccelerationClass + '\"><div class=\"ftscroller_scrollbarinner\"></div></div>';\n\t\t\t}\n\t\t}\n\t\toutput += '</div>';\n\n\t\treturn output;\n\t};\n}());\n\n\n(function () {\n\t'use strict';\n\n\tfunction clamp(value) {\n\t\tif (value > 1.0) return 1.0;\n\t\tif (value < 0.0) return 0.0;\n\t\treturn value;\n\t}\n\n\t/**\n\t * Represents a two-dimensional cubic bezier curve with the starting\n\t * point (0, 0) and the end point (1, 1). The two control points p1 and p2\n\t * have x and y coordinates between 0 and 1.\n\t *\n\t * This type of bezier curves can be used as CSS transform timing functions.\n\t */\n\tCubicBezier = function (p1x, p1y, p2x, p2y) {\n\t\t// Control points\n\t\tthis._p1 = { x: clamp(p1x), y: clamp(p1y) };\n\t\tthis._p2 = { x: clamp(p2x), y: clamp(p2y) };\n\t};\n\n\tCubicBezier.prototype._getCoordinateForT = function (t, p1, p2) {\n\t\tvar c = 3 * p1,\n\t\t\tb = 3 * (p2 - p1) - c,\n\t\t\ta = 1 - c - b;\n\n\t\treturn ((a * t + b) * t + c) * t;\n\t};\n\n\tCubicBezier.prototype._getCoordinateDerivateForT = function (t, p1, p2) {\n\t\tvar c = 3 * p1,\n\t\t\tb = 3 * (p2 - p1) - c,\n\t\t\ta = 1 - c - b;\n\n\t\treturn (3 * a * t + 2 * b) * t + c;\n\t};\n\n\tCubicBezier.prototype._getTForCoordinate = function (c, p1, p2, epsilon) {\n\t\tif (!isFinite(epsilon) || epsilon <= 0) {\n\t\t\tthrow new RangeError('\"epsilon\" must be a number greater than 0.');\n\t\t}\n\t\tvar t2, i, c2, d2;\n\n\t\t// First try a few iterations of Newton's method -- normally very fast.\n\t\tfor (t2 = c, i = 0; i < 8; i = i + 1) {\n\t\t\tc2 = this._getCoordinateForT(t2, p1, p2) - c;\n\t\t\tif (Math.abs(c2) < epsilon) {\n\t\t\t\treturn t2;\n\t\t\t}\n\t\t\td2 = this._getCoordinateDerivateForT(t2, p1, p2);\n\t\t\tif (Math.abs(d2) < 1e-6) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tt2 = t2 - c2 / d2;\n\t\t}\n\n\t\t// Fall back to the bisection method for reliability.\n\t\tt2 = c;\n\t\tvar t0 = 0,\n\t\t\tt1 = 1;\n\n\t\tif (t2 < t0) {\n\t\t\treturn t0;\n\t\t}\n\t\tif (t2 > t1) {\n\t\t\treturn t1;\n\t\t}\n\n\t\twhile (t0 < t1) {\n\t\t\tc2 = this._getCoordinateForT(t2, p1, p2);\n\t\t\tif (Math.abs(c2 - c) < epsilon) {\n\t\t\t\treturn t2;\n\t\t\t}\n\t\t\tif (c > c2) {\n\t\t\t\tt0 = t2;\n\t\t\t} else {\n\t\t\t\tt1 = t2;\n\t\t\t}\n\t\t\tt2 = (t1 - t0) * 0.5 + t0;\n\t\t}\n\n\t\t// Failure.\n\t\treturn t2;\n\t};\n\n\t/**\n\t * Computes the point for a given t value.\n\t *\n\t * @param {number} t\n\t * @returns {Object} Returns an object with x and y properties\n\t */\n\tCubicBezier.prototype.getPointForT = function (t) {\n\n\t\t// Special cases: starting and ending points\n\t\tif (t === 0 || t === 1) {\n\t\t\treturn { x: t, y: t };\n\t\t}\n\n\t\t// Check for correct t value (must be between 0 and 1)\n\t\tif (t < 0 || t > 1) {\n\t\t\t_throwRangeError('t', t);\n\t\t}\n\n\t\treturn {\n\t\t\tx: this._getCoordinateForT(t, this._p1.x, this._p2.x),\n\t\t\ty: this._getCoordinateForT(t, this._p1.y, this._p2.y)\n\t\t};\n\t};\n\n\tCubicBezier.prototype.getTForX = function (x, epsilon) {\n\t\treturn this._getTForCoordinate(x, this._p1.x, this._p2.x, epsilon);\n\t};\n\n\tCubicBezier.prototype.getTForY = function (y, epsilon) {\n\t\treturn this._getTForCoordinate(y, this._p1.y, this._p2.y, epsilon);\n\t};\n\n\t/**\n\t * Computes auxiliary points using De Casteljau's algorithm.\n\t *\n\t * @param {number} t must be greater than 0 and lower than 1.\n\t * @returns {Object} with members i0, i1, i2 (first iteration),\n\t *    j1, j2 (second iteration) and k (the exact point for t)\n\t */\n\tCubicBezier.prototype._getAuxPoints = function (t) {\n\t\tif (t <= 0 || t >= 1) {\n\t\t\t_throwRangeError('t', t);\n\t\t}\n\n\n\t\t/* First series of auxiliary points */\n\n\t\t// First control point of the left curve\n\t\tvar i0 = {\n\t\t\t\tx: t * this._p1.x,\n\t\t\t\ty: t * this._p1.y\n\t\t\t},\n\t\t\ti1 = {\n\t\t\t\tx: this._p1.x + t * (this._p2.x - this._p1.x),\n\t\t\t\ty: this._p1.y + t * (this._p2.y - this._p1.y)\n\t\t\t},\n\n\t\t\t// Second control point of the right curve\n\t\t\ti2  = {\n\t\t\t\tx: this._p2.x + t * (1 - this._p2.x),\n\t\t\t\ty: this._p2.y + t * (1 - this._p2.y)\n\t\t\t};\n\n\n\t\t/* Second series of auxiliary points */\n\n\t\t// Second control point of the left curve\n\t\tvar j0 = {\n\t\t\t\tx: i0.x + t * (i1.x - i0.x),\n\t\t\t\ty: i0.y + t * (i1.y - i0.y)\n\t\t\t},\n\n\t\t\t// First control point of the right curve\n\t\t\tj1 = {\n\t\t\t\tx: i1.x + t * (i2.x - i1.x),\n\t\t\t\ty: i1.y + t * (i2.y - i1.y)\n\t\t\t};\n\n\t\t// The division point (ending point of left curve, starting point of right curve)\n\t\tvar k = {\n\t\t\t\tx: j0.x + t * (j1.x - j0.x),\n\t\t\t\ty: j0.y + t * (j1.y - j0.y)\n\t\t\t};\n\n\t\treturn {\n\t\t\ti0: i0,\n\t\t\ti1: i1,\n\t\t\ti2: i2,\n\t\t\tj0: j0,\n\t\t\tj1: j1,\n\t\t\tk: k\n\t\t};\n\t};\n\n\t/**\n\t * Divides the bezier curve into two bezier functions.\n\t *\n\t * De Casteljau's algorithm is used to compute the new starting, ending, and\n\t * control points.\n\t *\n\t * @param {number} t must be greater than 0 and lower than 1.\n\t *     t === 1 or t === 0 are the starting/ending points of the curve, so no\n\t *     division is needed.\n\t *\n\t * @returns {CubicBezier[]} Returns an array containing two bezier curves\n\t *     to the left and the right of t.\n\t */\n\tCubicBezier.prototype.divideAtT = function (t) {\n\t\tif (t < 0 || t > 1) {\n\t\t\t_throwRangeError('t', t);\n\t\t}\n\n\t\t// Special cases t = 0, t = 1: Curve can be cloned for one side, the other\n\t\t// side is a linear curve (with duration 0)\n\t\tif (t === 0 || t === 1) {\n\t\t\tvar curves = [];\n\t\t\tcurves[t] = CubicBezier.linear();\n\t\t\tcurves[1 - t] = this.clone();\n\t\t\treturn curves;\n\t\t}\n\n\t\tvar left = {},\n\t\t\tright = {},\n\t\t\tpoints = this._getAuxPoints(t);\n\n\t\tvar i0 = points.i0,\n\t\t\ti2 = points.i2,\n\t\t\tj0 = points.j0,\n\t\t\tj1 = points.j1,\n\t\t\tk = points.k;\n\n\t\t// Normalize derived points, so that the new curves starting/ending point\n\t\t// coordinates are (0, 0) respectively (1, 1)\n\t\tvar factorX = k.x,\n\t\t\tfactorY = k.y;\n\n\t\tleft.p1 = {\n\t\t\tx: i0.x / factorX,\n\t\t\ty: i0.y / factorY\n\t\t};\n\t\tleft.p2 = {\n\t\t\tx: j0.x / factorX,\n\t\t\ty: j0.y / factorY\n\t\t};\n\n\t\tright.p1 = {\n\t\t\tx: (j1.x - factorX) / (1 - factorX),\n\t\t\ty: (j1.y - factorY) / (1 - factorY)\n\t\t};\n\n\t\tright.p2 = {\n\t\t\tx: (i2.x - factorX) / (1 - factorX),\n\t\t\ty: (i2.y - factorY) / (1 - factorY)\n\t\t};\n\n\t\treturn [\n\t\t\tnew CubicBezier(left.p1.x, left.p1.y, left.p2.x, left.p2.y),\n\t\t\tnew CubicBezier(right.p1.x, right.p1.y, right.p2.x, right.p2.y)\n\t\t];\n\t};\n\n\tCubicBezier.prototype.divideAtX = function (x, epsilon) {\n\t\tif (x < 0 || x > 1) {\n\t\t\t_throwRangeError('x', x);\n\t\t}\n\n\t\tvar t = this.getTForX(x, epsilon);\n\t\treturn this.divideAtT(t);\n\t};\n\n\tCubicBezier.prototype.divideAtY = function (y, epsilon) {\n\t\tif (y < 0 || y > 1) {\n\t\t\t_throwRangeError('y', y);\n\t\t}\n\n\t\tvar t = this.getTForY(y, epsilon);\n\t\treturn this.divideAtT(t);\n\t};\n\n\tCubicBezier.prototype.clone = function () {\n\t\treturn new CubicBezier(this._p1.x, this._p1.y, this._p2.x, this._p2.y);\n\t};\n\n\tCubicBezier.prototype.toString = function () {\n\t\treturn \"cubic-bezier(\" + [\n\t\t\tthis._p1.x,\n\t\t\tthis._p1.y,\n\t\t\tthis._p2.x,\n\t\t\tthis._p2.y\n\t\t].join(\", \") + \")\";\n\t};\n\n\tCubicBezier.linear = function () {\n\t\treturn new CubicBezier();\n\t};\n\n\tCubicBezier.ease = function () {\n\t\treturn new CubicBezier(0.25, 0.1, 0.25, 1.0);\n\t};\n\tCubicBezier.linear = function () {\n\t\treturn new CubicBezier(0.0, 0.0, 1.0, 1.0);\n\t};\n\tCubicBezier.easeIn = function () {\n\t\treturn new CubicBezier(0.42, 0, 1.0, 1.0);\n\t};\n\tCubicBezier.easeOut = function () {\n\t\treturn new CubicBezier(0, 0, 0.58, 1.0);\n\t};\n\tCubicBezier.easeInOut = function () {\n\t\treturn new CubicBezier(0.42, 0, 0.58, 1.0);\n\t};\n}());\n\nif (typeof define !== 'undefined' && define.amd) {\n\t// AMD. Register as an anonymous module.\n\tdefine(function() {\n\t\t'use strict';\n\t\treturn {\n\t\t\tFTScroller: FTScroller,\n\t\t\tCubicBezier: CubicBezier\n\t\t};\n\t});\n} else if (typeof module !== 'undefined' && module.exports) {\n\tmodule.exports = function(domNode, options) {\n\t\t'use strict';\n\t\treturn new FTScroller(domNode, options);\n\t};\n\n\tmodule.exports.FTScroller = FTScroller;\n\tmodule.exports.CubicBezier = CubicBezier;\n}\n","text":"/**\n * FTScroller: touch and mouse-based scrolling for DOM elements larger than their containers.\n *\n * While this is a rewrite, it is heavily inspired by two projects:\n * 1) Uxebu TouchScroll (https://github.com/davidaurelio/TouchScroll), BSD licensed:\n *    Copyright (c) 2010 uxebu Consulting Ltd. & Co. KG\n *    Copyright (c) 2010 David Aurelio\n * 2) Zynga Scroller (https://github.com/zynga/scroller), MIT licensed:\n *    Copyright 2011, Zynga Inc.\n *    Copyright 2011, Deutsche Telekom AG\n *\n * Includes CubicBezier:\n *\n * Copyright (C) 2008 Apple Inc. All Rights Reserved.\n * Copyright (C) 2010 David Aurelio. All Rights Reserved.\n * Copyright (C) 2010 uxebu Consulting Ltd. & Co. KG. All Rights Reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY APPLE INC., DAVID AURELIO, AND UXEBU\n * CONSULTING LTD. & CO. KG ``AS IS'' AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL APPLE INC. OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *\n * @copyright The Financial Times Ltd [All rights reserved]\n * @codingstandard ftlabs-jslint\n * @version 0.5.1\n */\n/**\n * @license FTScroller is (c) 2012 The Financial Times Ltd [All rights reserved] and licensed under the MIT license.\n *\n * Inspired by Uxebu TouchScroll, (c) 2010 uxebu Consulting Ltd. & Co. KG and David Aurelio, which is BSD licensed (https://github.com/davidaurelio/TouchScroll)\n * Inspired by Zynga Scroller, (c) 2011 Zynga Inc and Deutsche Telekom AG, which is MIT licensed (https://github.com/zynga/scroller)\n * Includes CubicBezier, (c) 2008 Apple Inc [All rights reserved], (c) 2010 David Aurelio and uxebu Consulting Ltd. & Co. KG. [All rights reserved], which is 2-clause BSD licensed (see above or https://github.com/davidaurelio/TouchScroll).\n */\n\n/*jslint nomen: true, vars: true, browser: true, continue: true, white: true*/\n/*globals FTScrollerOptions*/\n\nvar FTScroller, CubicBezier;\n\n(function () {\n\t'use strict';\n\n\t// Determine the browser engine and prefix, trying to use the unprefixed version where available.\n\tvar _vendorCSSPrefix, _vendorStylePropertyPrefix, _vendorTransformLookup,\n\t\t_pointerEventsPrefixed, _setPointerCapture, _releasePointerCapture, _lostPointerCapture, _trackPointerEvents, _pointerTypeTouch;\n\tif (document.createElement('div').style.transform !== undefined) {\n\t\t_vendorCSSPrefix = '';\n\t\t_vendorStylePropertyPrefix = '';\n\t\t_vendorTransformLookup = 'transform';\n\t} else if (window.opera && Object.prototype.toString.call(window.opera) === '[object Opera]') {\n\t\t_vendorCSSPrefix = '-o-';\n\t\t_vendorStylePropertyPrefix = 'O';\n\t\t_vendorTransformLookup = 'OTransform';\n\t} else if (document.documentElement.style.MozTransform !== undefined) {\n\t\t_vendorCSSPrefix = '-moz-';\n\t\t_vendorStylePropertyPrefix = 'Moz';\n\t\t_vendorTransformLookup = 'MozTransform';\n\t} else if (document.documentElement.style.webkitTransform !== undefined) {\n\t\t_vendorCSSPrefix = '-webkit-';\n\t\t_vendorStylePropertyPrefix = 'webkit';\n\t\t_vendorTransformLookup = '-webkit-transform';\n\t} else if (typeof navigator.cpuClass === 'string') {\n\t\t_vendorCSSPrefix = '-ms-';\n\t\t_vendorStylePropertyPrefix = 'ms';\n\t\t_vendorTransformLookup = '-ms-transform';\n\t}\n\n\t// Pointer Events are unprefixed in IE11\n\tif ('pointerEnabled' in window.navigator) {\n\t\t_pointerEventsPrefixed = false;\n\t\t_trackPointerEvents    = window.navigator.pointerEnabled;\n\t\t_setPointerCapture     = 'setPointerCapture';\n\t\t_releasePointerCapture = 'releasePointerCapture';\n\t\t_lostPointerCapture    = 'lostpointercapture';\n\t\t_pointerTypeTouch      = 'touch';\n\t} else if ('msPointerEnabled' in window.navigator) {\n\t\t_pointerEventsPrefixed = true;\n\t\t_trackPointerEvents    = window.navigator.msPointerEnabled;\n\t\t_setPointerCapture     = 'msSetPointerCapture';\n\t\t_releasePointerCapture = 'msReleasePointerCapture';\n\t\t_lostPointerCapture    = 'MSLostPointerCapture';\n\t\t_pointerTypeTouch      = 2; // PointerEvent.MSPOINTER_TYPE_TOUCH = 2 in IE10\n\t}\n\n\t// Global flag to determine if any scroll is currently active.  This prevents\n\t// issues when using multiple scrollers, particularly when they're nested.\n\tvar _ftscrollerMoving = false;\n\n\t// Determine whether pointer events or touch events can be used\n\tvar _trackTouchEvents = false;\n\tif ('propertyIsEnumerable' in window || 'hasOwnProperty' in window.document) {\n\t\t_trackTouchEvents = !_trackPointerEvents && (window.propertyIsEnumerable('ontouchstart') || window.document.hasOwnProperty('ontouchstart'));\n\t}\n\n\t// Determine whether to use modern hardware acceleration rules or dynamic/toggleable rules.\n\t// Certain older browsers - particularly Android browsers - have problems with hardware\n\t// acceleration, so being able to toggle the behaviour dynamically via a CSS cascade is desirable.\n\tvar _useToggleableHardwareAcceleration = false;\n\tif ('hasOwnProperty' in window) {\n\t\t_useToggleableHardwareAcceleration = !window.hasOwnProperty('ArrayBuffer');\n\t}\n\n\t// Feature detection\n\tvar _canClearSelection = (window.Selection && window.Selection.prototype.removeAllRanges);\n\n\t// If hardware acceleration is using the standard path, but perspective doesn't seem to be supported,\n\t// 3D transforms likely aren't supported either\n\tif (!_useToggleableHardwareAcceleration && document.createElement('div').style[_vendorStylePropertyPrefix + (_vendorStylePropertyPrefix ? 'P' : 'p') + 'erspective'] === undefined) {\n\t\t_useToggleableHardwareAcceleration = true;\n\t}\n\n\t// Style prefixes\n\tvar _transformProperty = _vendorStylePropertyPrefix + (_vendorStylePropertyPrefix ? 'T' : 't') + 'ransform';\n\tvar _transitionProperty = _vendorStylePropertyPrefix + (_vendorStylePropertyPrefix ? 'T' : 't') + 'ransition';\n\tvar _translateRulePrefix = _useToggleableHardwareAcceleration ? 'translate(' : 'translate3d(';\n\tvar _transformPrefixes = { x: '', y: '0,' };\n\tvar _transformSuffixes = { x: ',0' + (_useToggleableHardwareAcceleration ? ')' : ',0)'), y: (_useToggleableHardwareAcceleration ? ')' : ',0)') };\n\n\t// Constants.  Note that the bezier curve should be changed along with the friction!\n\tvar _kFriction = 0.998;\n\tvar _kMinimumSpeed = 0.01;\n\n\t// Create a global stylesheet to set up stylesheet rules and track dynamic entries\n\t(function () {\n\t\tvar stylesheetContainerNode = document.getElementsByTagName('head')[0] || document.documentElement;\n\t\tvar newStyleNode = document.createElement('style');\n\t\tvar hardwareAccelerationRule;\n\t\tvar _styleText;\n\t\tnewStyleNode.type = 'text/css';\n\n\t\t// Determine the hardware acceleration logic to use\n\t\tif (_useToggleableHardwareAcceleration) {\n\t\t\thardwareAccelerationRule = _vendorCSSPrefix + 'transform-style: preserve-3d;';\n\t\t} else {\n\t\t\thardwareAccelerationRule = _vendorCSSPrefix + 'transform: translateZ(0);';\n\t\t}\n\n\t\t// Add our rules\n\t\t_styleText = [\n\t\t\t'.ftscroller_container { overflow: hidden; position: relative; max-height: 100%; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); -ms-touch-action: none }',\n\t\t\t'.ftscroller_hwaccelerated { ' + hardwareAccelerationRule  + ' }',\n\t\t\t'.ftscroller_x, .ftscroller_y { position: relative; min-width: 100%; min-height: 100%; overflow: hidden }',\n\t\t\t'.ftscroller_x { display: inline-block }',\n\t\t\t'.ftscroller_scrollbar { pointer-events: none; position: absolute; width: 5px; height: 5px; border: 1px solid rgba(255, 255, 255, 0.3); -webkit-border-radius: 3px; border-radius: 6px; opacity: 0; ' + _vendorCSSPrefix + 'transition: opacity 350ms; z-index: 10; -webkit-box-sizing: content-box; -moz-box-sizing: content-box; box-sizing: content-box }',\n\t\t\t'.ftscroller_scrollbarx { bottom: 2px; left: 2px }',\n\t\t\t'.ftscroller_scrollbary { right: 2px; top: 2px }',\n\t\t\t'.ftscroller_scrollbarinner { height: 100%; background: #000; -webkit-border-radius: 2px; border-radius: 4px / 6px }',\n\t\t\t'.ftscroller_scrollbar.active { opacity: 0.5; ' + _vendorCSSPrefix + 'transition: none; -o-transition: all 0 none }'\n\t\t];\n\n\t\tif (newStyleNode.styleSheet) {\n\t\t\tnewStyleNode.styleSheet.cssText = _styleText.join('\\n');\n\t\t} else {\n\t\t\tnewStyleNode.appendChild(document.createTextNode(_styleText.join('\\n')));\n\t\t}\n\n\t\t// Add the stylesheet\n\t\tstylesheetContainerNode.insertBefore(newStyleNode, stylesheetContainerNode.firstChild);\n\t}());\n\n\t/**\n\t * Master constructor for the scrolling function, including which element to\n\t * construct the scroller in, and any scrolling options.\n\t * Note that app-wide options can also be set using a global FTScrollerOptions\n\t * object.\n\t */\n\tFTScroller = function (domNode, options) {\n\t\tvar key;\n\t\tvar destroy, setSnapSize, scrollTo, scrollBy, updateDimensions, addEventListener, removeEventListener, setDisabledInputMethods, _startScroll, _updateScroll, _endScroll, _finalizeScroll, _interruptScroll, _flingScroll, _snapScroll, _getSnapPositionForIndexes, _getSnapIndexForPosition, _constrainAndRenderTargetScrollPosition, _limitToBounds, _initializeDOM, _existingDOMValid, _domChanged, _updateDimensions, _updateScrollbarDimensions, _updateElementPosition, _updateSegments, _setAxisPosition, _getPosition, _scheduleAxisPosition, _fireEvent, _childFocused, _modifyDistanceBeyondBounds, _distancesBeyondBounds, _startAnimation, _scheduleRender, _cancelAnimation, _addEventHandlers, _removeEventHandlers, _resetEventHandlers, _onTouchStart, _onTouchMove, _onTouchEnd, _onMouseDown, _onMouseMove, _onMouseUp, _onPointerDown, _onPointerMove, _onPointerUp, _onPointerCancel, _onPointerCaptureEnd, _onClick, _onMouseScroll, _captureInput, _releaseInputCapture, _getBoundingRect;\n\n\n\t\t/* Note that actual object instantiation occurs at the end of the closure to avoid jslint errors */\n\n\n\t\t/*                         Options                       */\n\n\t\tvar _instanceOptions = {\n\n\t\t\t// Whether to display scrollbars as appropriate\n\t\t\tscrollbars: true,\n\n\t\t\t// Enable scrolling on the X axis if content is available\n\t\t\tscrollingX: true,\n\n\t\t\t// Enable scrolling on the Y axis if content is available\n\t\t\tscrollingY: true,\n\n\t\t\t// The initial movement required to trigger a scroll, in pixels; this is the point at which\n\t\t\t// the scroll is exclusive to this particular FTScroller instance.\n\t\t\tscrollBoundary: 1,\n\n\t\t\t// The initial movement required to trigger a visual indication that scrolling is occurring,\n\t\t\t// in pixels.  This is enforced to be less than or equal to the scrollBoundary, and is used to\n\t\t\t// define when the scroller starts drawing changes in response to an input, even if the scroll\n\t\t\t// is not treated as having begun/locked yet.\n\t\t\tscrollResponseBoundary: 1,\n\n\t\t\t// Whether to always enable scrolling, even if the content of the scroller does not\n\t\t\t// require the scroller to function.  This makes the scroller behave more like an\n\t\t\t// element set to \"overflow: scroll\", with bouncing always occurring if enabled.\n\t\t\talwaysScroll: false,\n\n\t\t\t// The content width to use when determining scroller dimensions.  If this\n\t\t\t// is false, the width will be detected based on the actual content.\n\t\t\tcontentWidth: undefined,\n\n\t\t\t// The content height to use when determining scroller dimensions.  If this\n\t\t\t// is false, the height will be detected based on the actual content.\n\t\t\tcontentHeight: undefined,\n\n\t\t\t// Enable snapping of content to 'pages' or a pixel grid\n\t\t\tsnapping: false,\n\n\t\t\t// Define the horizontal interval of the pixel grid; snapping must be enabled for this to\n\t\t\t// take effect.  If this is not defined, snapping will use intervals based on container size.\n\t\t\tsnapSizeX: undefined,\n\n\t\t\t// Define the vertical interval of the pixel grid; snapping must be enabled for this to\n\t\t\t// take effect.  If this is not defined, snapping will use intervals based on container size.\n\t\t\tsnapSizeY: undefined,\n\n\t\t\t// Control whether snapping should be curtailed to only ever flick to the next page\n\t\t\t// and not beyond.  Snapping needs to be enabled for this to take effect.\n\t\t\tsinglePageScrolls: false,\n\n\t\t\t// Allow scroll bouncing and elasticity near the ends and grid\n\t\t\tbouncing: true,\n\n\t\t\t// Allow a fast scroll to continue with momentum when released\n\t\t\tflinging: true,\n\n\t\t\t// Automatically detects changes to the contained markup and\n\t\t\t// updates its dimensions whenever the content changes. This is\n\t\t\t// set to false if a contentWidth or contentHeight are supplied.\n\t\t\tupdateOnChanges: true,\n\n\t\t\t// Automatically catches changes to the window size and updates\n\t\t\t// its dimensions.\n\t\t\tupdateOnWindowResize: false,\n\n\t\t\t// The alignment to use if the content is smaller than the container;\n\t\t\t// this also applies to initial positioning of scrollable content.\n\t\t\t// Valid alignments are -1 (top or left), 0 (center), and 1 (bottom or right).\n\t\t\tbaseAlignments: { x: -1, y: -1 },\n\n\t\t\t// Whether to use a window scroll flag, eg window.foo, to control whether\n\t\t\t// to allow scrolling to start or now.  If the window flag is set to true,\n\t\t\t// this element will not start scrolling; this element will also toggle\n\t\t\t// the variable while scrolling\n\t\t\twindowScrollingActiveFlag: undefined,\n\n\t\t\t// Instead of always using translate3d for transforms, a mix of translate3d\n\t\t\t// and translate with a hardware acceleration class used to trigger acceleration\n\t\t\t// is used; this is to allow CSS inheritance to be used to allow dynamic\n\t\t\t// disabling of backing layers on older platforms.\n\t\t\thwAccelerationClass: 'ftscroller_hwaccelerated',\n\n\t\t\t// While use of requestAnimationFrame is highly recommended on platforms\n\t\t\t// which support it, it can result in the animation being a further half-frame\n\t\t\t// behind the input method, increasing perceived lag slightly.  To disable this,\n\t\t\t// set this property to false.\n\t\t\tenableRequestAnimationFrameSupport: true,\n\n\t\t\t// Set the maximum time (ms) that a fling can take to complete; if\n\t\t\t// this is not set, flings will complete instantly\n\t\t\tmaxFlingDuration: 1000,\n\n\t\t\t// Whether to disable any input methods; on some multi-input devices\n\t\t\t// custom behaviour may be desired for some scrollers.  Use with care!\n\t\t\tdisabledInputMethods: {\n\t\t\t\tmouse: false,\n\t\t\t\ttouch: false,\n\t\t\t\tscroll: false,\n\t\t\t\tpointer: false,\n\t\t\t\tfocus: false\n\t\t\t},\n\n\t\t\t// Define a scrolling class to be added to the scroller container\n\t\t\t// when scrolling is active.  Note that this can cause a relayout on\n\t\t\t// scroll start if defined, but allows custom styling in response to scrolls\n\t\t\tscrollingClassName: undefined,\n\n\t\t\t// Bezier curves defining the feel of the fling (momentum) deceleration,\n\t\t\t// the bounce decleration deceleration (as a fling exceeds the bounds),\n\t\t\t// and the bounce bezier (used for bouncing back).\n\t\t\tflingBezier: new CubicBezier(0.103, 0.389, 0.307, 0.966),\n\t\t\tbounceDecelerationBezier: new CubicBezier(0, 0.5, 0.5, 1),\n\t\t\tbounceBezier: new CubicBezier(0.7, 0, 0.9, 0.6)\n\t\t};\n\n\n\t\t/*                     Local variables                   */\n\n\t\t// Cache the DOM node and set up variables for other nodes\n\t\tvar _publicSelf;\n\t\tvar _self = this;\n\t\tvar _scrollableMasterNode = domNode;\n\t\tvar _containerNode;\n\t\tvar _contentParentNode;\n\t\tvar _scrollNodes = { x: null, y: null };\n\t\tvar _scrollbarNodes = { x: null, y: null };\n\n\t\t// Dimensions of the container element and the content element\n\t\tvar _metrics = {\n\t\t\tcontainer: { x: null, y: null },\n\t\t\tcontent: { x: null, y: null, rawX: null, rawY: null },\n\t\t\tscrollEnd: { x: null, y: null }\n\t\t};\n\n\t\t// Snapping details\n\t\tvar _snapGridSize = {\n\t\t\tx: false,\n\t\t\ty: false,\n\t\t\tuserX: false,\n\t\t\tuserY: false\n\t\t};\n\t\tvar _snapIndex = {\n\t\t\tx: 0,\n\t\t\ty: 0\n\t\t};\n\t\tvar _baseSegment = { x: 0, y: 0 };\n\t\tvar _activeSegment = { x: 0, y: 0 };\n\n\t\t// Track the identifier of any input being tracked\n\t\tvar _inputIdentifier = false;\n\t\tvar _inputIndex = 0;\n\t\tvar _inputCaptured = false;\n\n\t\t// Current scroll positions and tracking\n\t\tvar _isScrolling = false;\n\t\tvar _isDisplayingScroll = false;\n\t\tvar _isAnimating = false;\n\t\tvar _baseScrollPosition = { x: 0, y: 0 };\n\t\tvar _lastScrollPosition = { x: 0, y: 0 };\n\t\tvar _targetScrollPosition = { x: 0, y: 0 };\n\t\tvar _scrollAtExtremity = { x: null, y: null };\n\t\tvar _preventClick = false;\n\t\tvar _timeouts = [];\n\t\tvar _hasBeenScrolled = false;\n\n\t\t// Gesture details\n\t\tvar _baseScrollableAxes = {};\n\t\tvar _scrollableAxes = { x: true, y: true };\n\t\tvar _gestureStart = { x: 0, y: 0, t: 0 };\n\t\tvar _cumulativeScroll = { x: 0, y: 0 };\n\t\tvar _eventHistory = [];\n\n\t\t// Allow certain events to be debounced\n\t\tvar _domChangeDebouncer = false;\n\t\tvar _scrollWheelEndDebouncer = false;\n\n\t\t// Performance switches on browsers supporting requestAnimationFrame\n\t\tvar _animationFrameRequest = false;\n\t\tvar _reqAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || false;\n\t\tvar _cancelAnimationFrame = window.cancelAnimationFrame || window.cancelRequestAnimationFrame || window.mozCancelAnimationFrame || window.mozCancelRequestAnimationFrame || window.webkitCancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.msCancelAnimationFrame || window.msCancelRequestAnimationFrame || false;\n\n\t\t// Event listeners\n\t\tvar _eventListeners = {\n\t\t\t'scrollstart': [],\n\t\t\t'scroll': [],\n\t\t\t'scrollend': [],\n\t\t\t'segmentwillchange': [],\n\t\t\t'segmentdidchange': [],\n\t\t\t'reachedstart': [],\n\t\t\t'reachedend': [],\n\t\t\t'scrollinteractionend': []\n\t\t};\n\n\t\t// MutationObserver instance, when supported and if DOM change sniffing is enabled\n\t\tvar _mutationObserver;\n\n\n\t\t/* Parsing supplied options */\n\n\t\t// Override default instance options with global - or closure'd - options\n\t\tif (typeof FTScrollerOptions === 'object' && FTScrollerOptions) {\n\t\t\tfor (key in FTScrollerOptions) {\n\t\t\t\tif (FTScrollerOptions.hasOwnProperty(key) && _instanceOptions.hasOwnProperty(key)) {\n\t\t\t\t\t_instanceOptions[key] = FTScrollerOptions[key];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Override default and global options with supplied options\n\t\tif (options) {\n\t\t\tfor (key in options) {\n\t\t\t\tif (options.hasOwnProperty(key)) {\n\n\t\t\t\t\t// If a deprecated flag was passed in, warn, and convert to the new flag name\n\t\t\t\t\tif ('paginatedSnap' === key) {\n\t\t\t\t\t\tconsole.warn('FTScroller: \"paginatedSnap\" is deprecated; converting to \"singlePageScrolls\"');\n\t\t\t\t\t\t_instanceOptions.singlePageScrolls = options.paginatedSnap;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (_instanceOptions.hasOwnProperty(key)) {\n\t\t\t\t\t\t_instanceOptions[key] = options[key];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If snap grid size options were supplied, store them\n\t\t\tif (options.hasOwnProperty('snapSizeX') && !isNaN(options.snapSizeX)) {\n\t\t\t\t_snapGridSize.userX = _snapGridSize.x = options.snapSizeX;\n\t\t\t}\n\t\t\tif (options.hasOwnProperty('snapSizeY') && !isNaN(options.snapSizeY)) {\n\t\t\t\t_snapGridSize.userY = _snapGridSize.y = options.snapSizeY;\n\t\t\t}\n\n\t\t\t// If content width and height were defined, disable updateOnChanges for performance\n\t\t\tif (options.contentWidth && options.contentHeight) {\n\t\t\t\toptions.updateOnChanges = false;\n\t\t\t}\n\t\t}\n\n\t\t// Validate the scroll response parameter\n\t\t_instanceOptions.scrollResponseBoundary = Math.min(_instanceOptions.scrollBoundary, _instanceOptions.scrollResponseBoundary);\n\n\t\t// Update base scrollable axes\n\t\tif (_instanceOptions.scrollingX) {\n\t\t\t_baseScrollableAxes.x = true;\n\t\t}\n\t\tif (_instanceOptions.scrollingY) {\n\t\t\t_baseScrollableAxes.y = true;\n\t\t}\n\n\t\t// Only enable animation frame support if the instance options permit it\n\t\t_reqAnimationFrame = _instanceOptions.enableRequestAnimationFrameSupport && _reqAnimationFrame;\n\t\t_cancelAnimationFrame = _reqAnimationFrame && _cancelAnimationFrame;\n\n\n\t\t/*                    Scoped Functions                   */\n\n\t\t/**\n\t\t * Unbinds all event listeners to prevent circular references preventing items\n\t\t * from being deallocated, and clean up references to dom elements. Pass in\n\t\t * \"removeElements\" to also remove FTScroller DOM elements for special reuse cases.\n\t\t */\n\t\tdestroy = function destroy(removeElements) {\n\t\t\tvar i, l;\n\n\t\t\t_removeEventHandlers();\n\t\t\t_cancelAnimation();\n\t\t\tif (_domChangeDebouncer) {\n\t\t\t\twindow.clearTimeout(_domChangeDebouncer);\n\t\t\t\t_domChangeDebouncer = false;\n\t\t\t}\n\t\t\tfor (i = 0, l = _timeouts.length; i < l; i = i + 1) {\n\t\t\t\twindow.clearTimeout(_timeouts[i]);\n\t\t\t}\n\t\t\t_timeouts.length = 0;\n\n\t\t\t// Destroy DOM elements if required\n\t\t\tif (removeElements && _scrollableMasterNode) {\n\t\t\t\twhile (_contentParentNode.firstChild) {\n\t\t\t\t\t_scrollableMasterNode.appendChild(_contentParentNode.firstChild);\n\t\t\t\t}\n\t\t\t\t_scrollableMasterNode.removeChild(_containerNode);\n\t\t\t}\n\n\t\t\t_scrollableMasterNode = null;\n\t\t\t_containerNode = null;\n\t\t\t_contentParentNode = null;\n\t\t\t_scrollNodes.x = null;\n\t\t\t_scrollNodes.y = null;\n\t\t\t_scrollbarNodes.x = null;\n\t\t\t_scrollbarNodes.y = null;\n\t\t\tfor (i in _eventListeners) {\n\t\t\t\tif (_eventListeners.hasOwnProperty(i)) {\n\t\t\t\t\t_eventListeners[i].length = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If this is currently tracked as a scrolling instance, clear the flag\n\t\t\tif (_ftscrollerMoving && _ftscrollerMoving === _self) {\n\t\t\t\t_ftscrollerMoving = false;\n\t\t\t\tif (_instanceOptions.windowScrollingActiveFlag) {\n\t\t\t\t\twindow[_instanceOptions.windowScrollingActiveFlag] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Configures the snapping boundaries within the scrolling element if\n\t\t * snapping is active.  If this is never called, snapping defaults to\n\t\t * using the bounding box, eg page-at-a-time.\n\t\t */\n\t\tsetSnapSize = function setSnapSize(width, height) {\n\t\t\t_snapGridSize.userX = width;\n\t\t\t_snapGridSize.userY = height;\n\t\t\t_snapGridSize.x = width;\n\t\t\t_snapGridSize.y = height;\n\n\t\t\t// Ensure the content dimensions conform to the grid\n\t\t\t_metrics.content.x = Math.ceil(_metrics.content.rawX / width) * width;\n\t\t\t_metrics.content.y = Math.ceil(_metrics.content.rawY / height) * height;\n\t\t\t_metrics.scrollEnd.x = _metrics.container.x - _metrics.content.x;\n\t\t\t_metrics.scrollEnd.y = _metrics.container.y - _metrics.content.y;\n\t\t\t_updateScrollbarDimensions();\n\n\t\t\t// Snap to the new grid if necessary\n\t\t\t_snapScroll();\n\t\t\t_updateSegments(true);\n\t\t};\n\n\t\t/**\n\t\t * Scroll to a supplied position, including whether or not to animate the\n\t\t * scroll and how fast to perform the animation (pass in true to select a\n\t\t * dynamic duration).  The inputs will be constrained to bounds and snapped.\n\t\t * If false is supplied for a position, that axis will not be scrolled.\n\t\t */\n\t\tscrollTo = function scrollTo(left, top, animationDuration) {\n\t\t\tvar targetPosition, duration, positions, axis, maxDuration = 0, scrollPositionsToApply = {};\n\n\t\t\t// If a manual scroll is in progress, cancel it\n\t\t\t_endScroll(Date.now());\n\n\t\t\t// Move supplied coordinates into an object for iteration, also inverting the values into\n\t\t\t// our coordinate system\n\t\t\tpositions = {\n\t\t\t\tx: -left,\n\t\t\t\ty: -top\n\t\t\t};\n\n\t\t\tfor (axis in _baseScrollableAxes) {\n\t\t\t\tif (_baseScrollableAxes.hasOwnProperty(axis)) {\n\t\t\t\t\ttargetPosition = positions[axis];\n\t\t\t\t\tif (targetPosition === false) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Constrain to bounds\n\t\t\t\t\ttargetPosition = Math.min(0, Math.max(_metrics.scrollEnd[axis], targetPosition));\n\n\t\t\t\t\t// Snap if appropriate\n\t\t\t\t\tif (_instanceOptions.snapping && _snapGridSize[axis]) {\n\t\t\t\t\t\ttargetPosition = Math.round(targetPosition / _snapGridSize[axis]) * _snapGridSize[axis];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Get a duration\n\t\t\t\t\tduration = animationDuration || 0;\n\t\t\t\t\tif (duration === true) {\n\t\t\t\t\t\tduration = Math.sqrt(Math.abs(_baseScrollPosition[axis] - targetPosition)) * 20;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Trigger the position change\n\t\t\t\t\t_setAxisPosition(axis, targetPosition, duration);\n\t\t\t\t\tscrollPositionsToApply[axis] = targetPosition;\n\t\t\t\t\tmaxDuration = Math.max(maxDuration, duration);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If the scroll had resulted in a change in position, perform some additional actions:\n\t\t\tif (_baseScrollPosition.x !== positions.x || _baseScrollPosition.y !== positions.y) {\n\n\t\t\t\t// Mark a scroll as having ever occurred\n\t\t\t\t_hasBeenScrolled = true;\n\n\t\t\t\t// If an animation duration is present, fire a scroll start event and a\n\t\t\t\t// scroll event for any listeners to act on\n\t\t\t\t_fireEvent('scrollstart', _getPosition());\n\t\t\t\tconsole.log('firing scroll event from scrollTo');\n\t\t\t\t_fireEvent('scroll', _getPosition());\n\t\t\t}\n\n\t\t\tif (maxDuration) {\n\t\t\t\t_timeouts.push(setTimeout(function () {\n\t\t\t\t\tvar anAxis;\n\t\t\t\t\tfor (anAxis in scrollPositionsToApply) {\n\t\t\t\t\t\tif (scrollPositionsToApply.hasOwnProperty(anAxis)) {\n\t\t\t\t\t\t\t_lastScrollPosition[anAxis] = scrollPositionsToApply[anAxis];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t_finalizeScroll();\n\t\t\t\t}, maxDuration));\n\t\t\t} else {\n\t\t\t\t_finalizeScroll();\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Alter the current scroll position, including whether or not to animate\n\t\t * the scroll and how fast to perform the animation (pass in true to\n\t\t * select a dynamic duration).  The inputs will be checked against the\n\t\t * current position.\n\t\t */\n\t\tscrollBy = function scrollBy(horizontal, vertical, animationDuration) {\n\n\t\t\t// Wrap the scrollTo function for simplicity\n\t\t\tscrollTo(parseFloat(horizontal) - _baseScrollPosition.x, parseFloat(vertical) - _baseScrollPosition.y, animationDuration);\n\t\t};\n\n\t\t/**\n\t\t * Provide a public method to detect changes in dimensions for either the content or the\n\t\t * container.\n\t\t */\n\t\tupdateDimensions = function updateDimensions(contentWidth, contentHeight, ignoreSnapScroll) {\n\t\t\toptions.contentWidth = contentWidth || options.contentWidth;\n\t\t\toptions.contentHeight = contentHeight || options.contentHeight;\n\n\t\t\t// Currently just wrap the private API\n\t\t\t_updateDimensions(!!ignoreSnapScroll);\n\t\t};\n\n\t\t/**\n\t\t * Add an event handler for a supported event.  Current events include:\n\t\t * scroll - fired whenever the scroll position changes\n\t\t * scrollstart - fired when a scroll movement starts\n\t\t * scrollend - fired when a scroll movement ends\n\t\t * segmentwillchange - fired whenever the segment changes, including during scrolling\n\t\t * segmentdidchange - fired when a segment has conclusively changed, after scrolling.\n\t\t */\n\t\taddEventListener = function addEventListener(eventname, eventlistener) {\n\n\t\t\t// Ensure this is a valid event\n\t\t\tif (!_eventListeners.hasOwnProperty(eventname)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Add the listener\n\t\t\t_eventListeners[eventname].push(eventlistener);\n\t\t\treturn true;\n\t\t};\n\n\t\t/**\n\t\t * Remove an event handler for a supported event.  The listener must be exactly the same as\n\t\t * an added listener to be removed.\n\t\t */\n\t\tremoveEventListener = function removeEventListener(eventname, eventlistener) {\n\t\t\tvar i;\n\n\t\t\t// Ensure this is a valid event\n\t\t\tif (!_eventListeners.hasOwnProperty(eventname)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tfor (i = _eventListeners[eventname].length; i >= 0; i = i - 1) {\n\t\t\t\tif (_eventListeners[eventname][i] === eventlistener) {\n\t\t\t\t\t_eventListeners[eventname].splice(i, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\n\t\t/**\n\t\t * Set the input methods to disable. No inputs methods are disabled by default.\n\t\t * (object, default { mouse: false, touch: false, scroll: false, pointer: false, focus: false })\n\t\t */\n\t\tsetDisabledInputMethods = function setDisabledInputMethods(disabledInputMethods) {\n\t\t\tvar i, changed;\n\n\t\t\tfor (i in _instanceOptions.disabledInputMethods) {\n\t\t\t\tdisabledInputMethods[i] = !!disabledInputMethods[i];\n\n\t\t\t\tif (_instanceOptions.disabledInputMethods[i] !== disabledInputMethods[i]) changed = true;\n\t\t\t\t_instanceOptions.disabledInputMethods[i] = disabledInputMethods[i];\n\t\t\t}\n\n\t\t\tif (changed) {\n\t\t\t\t_resetEventHandlers();\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Start a scroll tracking input - this could be mouse, webkit-style touch,\n\t\t * or ms-style pointer events.\n\t\t */\n\t\t_startScroll = function _startScroll(inputX, inputY, inputTime, rawEvent) {\n\t\t\tvar triggerScrollInterrupt = _isAnimating;\n\n\t\t\t// Opera fix\n\t\t\tif (inputTime <= 0) {\n\t\t\t\tinputTime = Date.now();\n\t\t\t}\n\n\t\t\t// If a window scrolling flag is set, and evaluates to true, don't start checking touches\n\t\t\tif (_instanceOptions.windowScrollingActiveFlag && window[_instanceOptions.windowScrollingActiveFlag]) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// If an animation is in progress, stop the scroll.\n\t\t\tif (triggerScrollInterrupt) {\n\t\t\t\t_interruptScroll();\n\t\t\t} else {\n\n\t\t\t\t// Allow clicks again, but only if a scroll was not interrupted\n\t\t\t\t_preventClick = false;\n\t\t\t}\n\n\t\t\t// Store the initial event coordinates\n\t\t\t_gestureStart.x = inputX;\n\t\t\t_gestureStart.y = inputY;\n\t\t\t_gestureStart.t = inputTime;\n\t\t\t_targetScrollPosition.x = _lastScrollPosition.x;\n\t\t\t_targetScrollPosition.y = _lastScrollPosition.y;\n\n\t\t\t// Clear event history and add the start touch\n\t\t\t_eventHistory.length = 0;\n\t\t\t_eventHistory.push({ x: inputX, y: inputY, t: inputTime });\n\n\t\t\tif (triggerScrollInterrupt) {\n\t\t\t\t_updateScroll(inputX, inputY, inputTime, rawEvent, triggerScrollInterrupt);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t};\n\n\t\t/**\n\t\t * Continue a scroll as a result of an updated position\n\t\t */\n\t\t_updateScroll = function _updateScroll(inputX, inputY, inputTime, rawEvent, scrollInterrupt) {\n\t\t\tvar axis, otherScrollerActive, distancesBeyondBounds;\n\t\t\tvar initialScroll = false;\n\t\t\tvar gesture = {\n\t\t\t\tx: inputX - _gestureStart.x,\n\t\t\t\ty: inputY - _gestureStart.y\n\t\t\t};\n\n\t\t\t// Opera fix\n\t\t\tif (inputTime <= 0) {\n\t\t\t\tinputTime = Date.now();\n\t\t\t}\n\n\t\t\t// Update base target positions\n\t\t\t_targetScrollPosition.x = _baseScrollPosition.x + gesture.x;\n\t\t\t_targetScrollPosition.y = _baseScrollPosition.y + gesture.y;\n\n\t\t\t// If scrolling has not yet locked to this scroller, check whether to stop scrolling\n\t\t\tif (!_isScrolling) {\n\n\t\t\t\t// Check the internal flag to determine if another FTScroller is scrolling\n\t\t\t\tif (_ftscrollerMoving && _ftscrollerMoving !== _self) {\n\t\t\t\t\totherScrollerActive = true;\n\t\t\t\t}\n\n\t\t\t\t// Otherwise, check the window scrolling flag to see if anything else has claimed scrolling\n\t\t\t\telse if (_instanceOptions.windowScrollingActiveFlag && window[_instanceOptions.windowScrollingActiveFlag]) {\n\t\t\t\t\totherScrollerActive = true;\n\t\t\t\t}\n\n\t\t\t\t// If another scroller was active, clean up and stop processing.\n\t\t\t\tif (otherScrollerActive) {\n\t\t\t\t\t_releaseInputCapture();\n\t\t\t\t\t_inputIdentifier = false;\n\t\t\t\t\tif (_isDisplayingScroll) {\n\t\t\t\t\t\t_cancelAnimation();\n\t\t\t\t\t\tif (!_snapScroll(true)) {\n\t\t\t\t\t\t\t_finalizeScroll(true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If not yet displaying a scroll, determine whether that triggering boundary\n\t\t\t// has been exceeded\n\t\t\tif (!_isDisplayingScroll) {\n\n\t\t\t\t// Determine scroll distance beyond bounds\n\t\t\t\tdistancesBeyondBounds = _distancesBeyondBounds(_targetScrollPosition);\n\n\t\t\t\t// Determine whether to prevent the default scroll event - if the scroll could still\n\t\t\t\t// be triggered, prevent the default to avoid problems (particularly on PlayBook)\n\t\t\t\tif (_instanceOptions.bouncing || scrollInterrupt || (_scrollableAxes.x && gesture.x && distancesBeyondBounds.x < 0) || (_scrollableAxes.y && gesture.y && distancesBeyondBounds.y < 0)) {\n\t\t\t\t\trawEvent.preventDefault();\n\t\t\t\t}\n\n\t\t\t\t// Check scrolled distance against the boundary limit to see if scrolling can be triggered.\n\t\t\t\t// If the scroll has been interrupted, trigger at once\n\t\t\t\tif (!scrollInterrupt && (!_scrollableAxes.x || Math.abs(gesture.x) < _instanceOptions.scrollResponseBoundary) && (!_scrollableAxes.y || Math.abs(gesture.y) < _instanceOptions.scrollResponseBoundary)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// If bouncing is disabled, and already at an edge and scrolling beyond the edge, ignore the scroll for\n\t\t\t\t// now - this allows other scrollers to claim if appropriate, allowing nicer nested scrolls.\n\t\t\t\tif (!_instanceOptions.bouncing && !scrollInterrupt && (!_scrollableAxes.x || !gesture.x || distancesBeyondBounds.x > 0) && (!_scrollableAxes.y || !gesture.y || distancesBeyondBounds.y > 0)) {\n\n\t\t\t\t\t// Prevent the original click now that scrolling would be triggered\n\t\t\t\t\t_preventClick = true;\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Trigger the start of visual scrolling\n\t\t\t\t_startAnimation();\n\t\t\t\t_isDisplayingScroll = true;\n\t\t\t\t_hasBeenScrolled = true;\n\t\t\t\t_isAnimating = true;\n\t\t\t\tinitialScroll = true;\n\t\t\t} else {\n\n\t\t\t\t// Prevent the event default.  It is safe to call this in IE10 because the event is never\n\t\t\t\t// a window.event, always a \"true\" event.\n\t\t\t\trawEvent.preventDefault();\n\t\t\t}\n\n\t\t\t// If not yet locked to a scroll, determine whether to do so\n\t\t\tif (!_isScrolling) {\n\n\t\t\t\t// If the gesture distance has exceeded the scroll lock distance, or snapping is active\n\t\t\t\t// and the scroll has been interrupted, enter exclusive scrolling.\n\t\t\t\tif ((scrollInterrupt && _instanceOptions.snapping) || (_scrollableAxes.x && Math.abs(gesture.x) >= _instanceOptions.scrollBoundary) || (_scrollableAxes.y && Math.abs(gesture.y) >= _instanceOptions.scrollBoundary)) {\n\n\t\t\t\t\t_isScrolling = true;\n\t\t\t\t\t_preventClick = true;\n\t\t\t\t\t_ftscrollerMoving = _self;\n\t\t\t\t\tif (_instanceOptions.windowScrollingActiveFlag) {\n\t\t\t\t\t\twindow[_instanceOptions.windowScrollingActiveFlag] = _self;\n\t\t\t\t\t}\n\t\t\t\t\t_fireEvent('scrollstart', _getPosition());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Capture pointer if necessary\n\t\t\tif (_isScrolling) {\n\t\t\t\t_captureInput();\n\t\t\t}\n\n\t\t\t// Cancel text selections while dragging a cursor\n\t\t\tif (_canClearSelection) {\n\t\t\t\twindow.getSelection().removeAllRanges();\n\t\t\t}\n\n\t\t\t// Ensure the target scroll position is affected by bounds and render if needed\n\t\t\t_constrainAndRenderTargetScrollPosition();\n\n\t\t\t// To aid render/draw coalescing, perform other one-off actions here\n\t\t\tif (initialScroll) {\n\t\t\t\tif (gesture.x > 0) {\n\t\t\t\t\t_baseScrollPosition.x -= _instanceOptions.scrollResponseBoundary;\n\t\t\t\t} else if(gesture.x < 0) {\n\t\t\t\t\t_baseScrollPosition.x += _instanceOptions.scrollResponseBoundary;\n\t\t\t\t}\n\n\t\t\t\tif (gesture.y > 0) {\n\t\t\t\t\t_baseScrollPosition.y -= _instanceOptions.scrollResponseBoundary;\n\t\t\t\t} else if(gesture.y < 0) {\n\t\t\t\t\t_baseScrollPosition.y += _instanceOptions.scrollResponseBoundary;\n\t\t\t\t}\n\n\t\t\t\t_targetScrollPosition.x = _baseScrollPosition.x + gesture.x;\n\t\t\t\t_targetScrollPosition.y = _baseScrollPosition.y + gesture.y;\n\n\t\t\t\tif (_instanceOptions.scrollingClassName) {\n\t\t\t\t\t_containerNode.className += ' ' + _instanceOptions.scrollingClassName;\n\t\t\t\t}\n\t\t\t\tif (_instanceOptions.scrollbars) {\n\t\t\t\t\tfor (axis in _scrollableAxes) {\n\t\t\t\t\t\tif (_scrollableAxes.hasOwnProperty(axis)) {\n\t\t\t\t\t\t\t_scrollbarNodes[axis].className += ' active';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add an event to the event history, keeping it around twenty events long\n\t\t\t_eventHistory.push({ x: inputX, y: inputY, t: inputTime });\n\t\t\tif (_eventHistory.length > 30) {\n\t\t\t\t_eventHistory.splice(0, 15);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Complete a scroll with a final event time if available (it may\n\t\t * not be, depending on the input type); this may continue the scroll\n\t\t * with a fling and/or bounceback depending on options.\n\t\t */\n\t\t_endScroll = function _endScroll(inputTime, rawEvent) {\n\t\t\t_releaseInputCapture();\n\t\t\t_inputIdentifier = false;\n\t\t\t_cancelAnimation();\n\n\t\t\t_fireEvent('scrollinteractionend', {});\n\n\t\t\tif (!_isScrolling) {\n\t\t\t\tif (!_snapScroll(true) && _isDisplayingScroll) {\n\t\t\t\t\t_finalizeScroll(true);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Modify the last movement event to include the end event time\n\t\t\t_eventHistory[_eventHistory.length - 1].t = inputTime;\n\n\t\t\t// Update flags\n\t\t\t_isScrolling = false;\n\t\t\t_isDisplayingScroll = false;\n\t\t\t_ftscrollerMoving = false;\n\t\t\tif (_instanceOptions.windowScrollingActiveFlag) {\n\t\t\t\twindow[_instanceOptions.windowScrollingActiveFlag] = false;\n\t\t\t}\n\n\t\t\t// Stop the event default.  It is safe to call this in IE10 because\n\t\t\t// the event is never a window.event, always a \"true\" event.\n\t\t\tif (rawEvent) {\n\t\t\t\trawEvent.preventDefault();\n\t\t\t}\n\n\t\t\t// Trigger a fling or bounceback if necessary\n\t\t\tif (!_flingScroll() && !_snapScroll()) {\n\t\t\t\t_finalizeScroll();\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Remove the scrolling class, cleaning up display.\n\t\t */\n\t\t_finalizeScroll = function _finalizeScroll(scrollCancelled) {\n\t\t\tvar i, l, axis, scrollEvent, scrollRegex;\n\n\t\t\t_isAnimating = false;\n\t\t\t_isDisplayingScroll = false;\n\n\t\t\t// Remove scrolling class if set\n\t\t\tif (_instanceOptions.scrollingClassName) {\n\t\t\t\tscrollRegex = new RegExp('(?:^|\\\\s)' + _instanceOptions.scrollingClassName + '(?!\\\\S)', 'g');\n\t\t\t\t_containerNode.className = _containerNode.className.replace(scrollRegex, '');\n\t\t\t}\n\t\t\tif (_instanceOptions.scrollbars) {\n\t\t\t\tfor (axis in _scrollableAxes) {\n\t\t\t\t\tif (_scrollableAxes.hasOwnProperty(axis)) {\n\t\t\t\t\t\t_scrollbarNodes[axis].className = _scrollbarNodes[axis].className.replace(/ ?active/g, '');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Store final position if scrolling occurred\n\t\t\t_baseScrollPosition.x = _lastScrollPosition.x;\n\t\t\t_baseScrollPosition.y = _lastScrollPosition.y;\n\n\t\t\tscrollEvent = _getPosition();\n\n\t\t\tif (!scrollCancelled) {\n\t\t\t\tconsole.log('firing scroll event from _finalizeScroll');\n\t\t\t\t_fireEvent('scroll', scrollEvent);\n\t\t\t\t_updateSegments(true);\n\t\t\t}\n\n\t\t\t// Always fire the scroll end event, including an argument indicating whether\n\t\t\t// the scroll was cancelled\n\t\t\tscrollEvent.cancelled = scrollCancelled;\n\t\t\t_fireEvent('scrollend', scrollEvent);\n\n\t\t\t// Restore transitions\n\t\t\tfor (axis in _scrollableAxes) {\n\t\t\t\tif (_scrollableAxes.hasOwnProperty(axis)) {\n\t\t\t\t\t_scrollNodes[axis].style[_transitionProperty] = '';\n\t\t\t\t\tif (_instanceOptions.scrollbars) {\n\t\t\t\t\t\t_scrollbarNodes[axis].style[_transitionProperty] = '';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Clear any remaining timeouts\n\t\t\tfor (i = 0, l = _timeouts.length; i < l; i = i + 1) {\n\t\t\t\twindow.clearTimeout(_timeouts[i]);\n\t\t\t}\n\t\t\t_timeouts.length = 0;\n\t\t};\n\n\t\t/**\n\t\t * Interrupt a current scroll, allowing a start scroll during animation to trigger a new scroll\n\t\t */\n\t\t_interruptScroll = function _interruptScroll() {\n\t\t\tvar axis, i, l;\n\n\t\t\t_isAnimating = false;\n\n\t\t\t// Update the stored base position\n\t\t\t_updateElementPosition();\n\n\t\t\t// Ensure the parsed positions are set, also clearing transitions\n\t\t\tfor (axis in _scrollableAxes) {\n\t\t\t\tif (_scrollableAxes.hasOwnProperty(axis)) {\n\t\t\t\t\t_setAxisPosition(axis, _baseScrollPosition[axis], 16, _instanceOptions.bounceDecelerationBezier);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Update segment tracking if snapping is active\n\t\t\t_updateSegments(false);\n\n\t\t\t// Clear any remaining timeouts\n\t\t\tfor (i = 0, l = _timeouts.length; i < l; i = i + 1) {\n\t\t\t\twindow.clearTimeout(_timeouts[i]);\n\t\t\t}\n\t\t\t_timeouts.length = 0;\n\t\t};\n\n\t\t/**\n\t\t * Determine whether a scroll fling or bounceback is required, and set up the styles and\n\t\t * timeouts required.\n\t\t */\n\t\t_flingScroll = function _flingScroll() {\n\t\t\tvar i, axis, movementTime, movementSpeed, lastPosition, comparisonPosition, flingDuration, flingDistance, flingPosition, bounceDelay, bounceDistance, bounceDuration, bounceTarget, boundsBounce, modifiedDistance, flingBezier, timeProportion, boundsCrossDelay, flingStartSegment, beyondBoundsFlingDistance, baseFlingComponent;\n\t\t\tvar maxAnimationTime = 0;\n\t\t\tvar moveRequired = false;\n\t\t\tvar scrollPositionsToApply = {};\n\n\t\t\t// If we only have the start event available, or flinging is disabled,\n\t\t\t// or the scroll was triggered by a scrollwheel, no action required.\n\t\t\tif (_eventHistory.length === 1 || !_instanceOptions.flinging || _inputIdentifier === 'scrollwheel') {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tfor (axis in _scrollableAxes) {\n\t\t\t\tif (_scrollableAxes.hasOwnProperty(axis)) {\n\t\t\t\t\tbounceDuration = 350;\n\t\t\t\t\tbounceDistance = 0;\n\t\t\t\t\tboundsBounce = false;\n\t\t\t\t\tbounceTarget = false;\n\t\t\t\t\tboundsCrossDelay = undefined;\n\n\t\t\t\t\t// Re-set a default bezier curve for the animation for potential modification\n\t\t\t\t\tflingBezier = _instanceOptions.flingBezier;\n\n\t\t\t\t\t// Get the last movement speed, in pixels per millisecond.  To do this, look at the events\n\t\t\t\t\t// in the last 100ms and average out the speed, using a minimum number of two points.\n\t\t\t\t\tlastPosition = _eventHistory[_eventHistory.length - 1];\n\t\t\t\t\tcomparisonPosition = _eventHistory[_eventHistory.length - 2];\n\t\t\t\t\tfor (i = _eventHistory.length - 3; i >= 0; i = i - 1) {\n\t\t\t\t\t\tif (lastPosition.t - _eventHistory[i].t > 100) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcomparisonPosition = _eventHistory[i];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Get the last movement time.  If this is zero - as can happen with\n\t\t\t\t\t// some scrollwheel events on some platforms - increase it to 16ms as\n\t\t\t\t\t// if the movement occurred over a single frame at 60fps.\n\t\t\t\t\tmovementTime = lastPosition.t - comparisonPosition.t;\n\t\t\t\t\tif (!movementTime) {\n\t\t\t\t\t\tmovementTime = 16;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Derive the movement speed\n\t\t\t\t\tmovementSpeed = (lastPosition[axis] - comparisonPosition[axis]) / movementTime;\n\n\t\t\t\t\t// If there is little speed, no further action required except for a bounceback, below.\n\t\t\t\t\tif (Math.abs(movementSpeed) < _kMinimumSpeed) {\n\t\t\t\t\t\tflingDuration = 0;\n\t\t\t\t\t\tflingDistance = 0;\n\n\t\t\t\t\t} else {\n\n\n\t\t\t\t\t\t/* Calculate the fling duration.  As per TouchScroll, the speed at any particular\n\t\t\t\t\t\tpoint in time can be calculated as:\n\t\t\t\t\t\t\t{ speed } = { initial speed } * ({ friction } to the power of { duration })\n\t\t\t\t\t\t...assuming all values are in equal pixels/millisecond measurements.  As we know the\n\t\t\t\t\t\tminimum target speed, this can be altered to:\n\t\t\t\t\t\t\t{ duration } = log( { speed } / { initial speed } ) / log( { friction } )\n\t\t\t\t\t\t*/\n\n\t\t\t\t\t\tflingDuration = Math.log(_kMinimumSpeed / Math.abs(movementSpeed)) / Math.log(_kFriction);\n\n\n\t\t\t\t\t\t/* Calculate the fling distance (before any bouncing or snapping).  As per\n\t\t\t\t\t\tTouchScroll, the total distance covered can be approximated by summing\n\t\t\t\t\t\tthe distance per millisecond, per millisecond of duration - a divergent series,\n\t\t\t\t\t\tand so rather tricky to model otherwise!\n\t\t\t\t\t\tSo using values in pixels per millisecond:\n\t\t\t\t\t\t\t{ distance } = { initial speed } * (1 - ({ friction } to the power\n\t\t\t\t\t\t\t\tof { duration + 1 }) / (1 - { friction })\n\t\t\t\t\t\t*/\n\n\t\t\t\t\t\tflingDistance = movementSpeed * (1 - Math.pow(_kFriction, flingDuration + 1)) / (1 - _kFriction);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Determine a target fling position\n\t\t\t\t\tflingPosition = Math.floor(_lastScrollPosition[axis] + flingDistance);\n\n\t\t\t\t\t// If bouncing is disabled, and the last scroll position and fling position are both at a bound,\n\t\t\t\t\t// reset the fling position to the bound\n\t\t\t\t\tif (!_instanceOptions.bouncing) {\n\t\t\t\t\t\tif (_lastScrollPosition[axis] === 0 && flingPosition > 0) {\n\t\t\t\t\t\t\tflingPosition = 0;\n\t\t\t\t\t\t} else if (_lastScrollPosition[axis] === _metrics.scrollEnd[axis] && flingPosition < _lastScrollPosition[axis]) {\n\t\t\t\t\t\t\tflingPosition = _lastScrollPosition[axis];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// In single-page-scroll mode, determine the page to snap to - maximum one page\n\t\t\t\t\t// in either direction from the *start* page.\n\t\t\t\t\tif (_instanceOptions.singlePageScrolls && _instanceOptions.snapping) {\n\t\t\t\t\t\tflingStartSegment = -_lastScrollPosition[axis] / _snapGridSize[axis];\n\t\t\t\t\t\tif (_baseSegment[axis] < flingStartSegment) {\n\t\t\t\t\t\t\tflingStartSegment = Math.floor(flingStartSegment);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tflingStartSegment = Math.ceil(flingStartSegment);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If the target position will end up beyond another page, target that page edge\n\t\t\t\t\t\tif (flingPosition > -(_baseSegment[axis] - 1) * _snapGridSize[axis]) {\n\t\t\t\t\t\t\tbounceDistance = flingPosition + (_baseSegment[axis] - 1) * _snapGridSize[axis];\n\t\t\t\t\t\t} else if (flingPosition < -(_baseSegment[axis] + 1) * _snapGridSize[axis]) {\n\t\t\t\t\t\t\tbounceDistance = flingPosition + (_baseSegment[axis] + 1) * _snapGridSize[axis];\n\n\t\t\t\t\t\t// Otherwise, if the movement speed was above the minimum velocity, continue\n\t\t\t\t\t\t// in the move direction.\n\t\t\t\t\t\t} else if (Math.abs(movementSpeed) > _kMinimumSpeed) {\n\n\t\t\t\t\t\t\t// Determine the target segment\n\t\t\t\t\t\t\tif (movementSpeed < 0) {\n\t\t\t\t\t\t\t\tflingPosition = Math.floor(_lastScrollPosition[axis] / _snapGridSize[axis]) * _snapGridSize[axis];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tflingPosition = Math.ceil(_lastScrollPosition[axis] / _snapGridSize[axis]) * _snapGridSize[axis];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tflingDuration = Math.min(_instanceOptions.maxFlingDuration, flingDuration * (flingPosition - _lastScrollPosition[axis]) / flingDistance);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// In non-paginated snapping mode, snap to the nearest grid location to the target\n\t\t\t\t\t} else if (_instanceOptions.snapping) {\n\t\t\t\t\t\tbounceDistance = flingPosition - (Math.round(flingPosition / _snapGridSize[axis]) * _snapGridSize[axis]);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Deal with cases where the target is beyond the bounds\n\t\t\t\t\tif (flingPosition - bounceDistance > 0) {\n\t\t\t\t\t\tbounceDistance = flingPosition;\n\t\t\t\t\t\tboundsBounce = true;\n\t\t\t\t\t} else if (flingPosition - bounceDistance < _metrics.scrollEnd[axis]) {\n\t\t\t\t\t\tbounceDistance = flingPosition - _metrics.scrollEnd[axis];\n\t\t\t\t\t\tboundsBounce = true;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Amend the positions and bezier curve if necessary\n\t\t\t\t\tif (bounceDistance) {\n\n\t\t\t\t\t\t// If the fling moves the scroller beyond the normal scroll bounds, and\n\t\t\t\t\t\t// the bounce is snapping the scroll back after the fling:\n\t\t\t\t\t\tif (boundsBounce && _instanceOptions.bouncing && flingDistance) {\n\t\t\t\t\t\t\tflingDistance = Math.floor(flingDistance);\n\n\t\t\t\t\t\t\tif (flingPosition > 0) {\n\t\t\t\t\t\t\t\tbeyondBoundsFlingDistance = flingPosition - Math.max(0, _lastScrollPosition[axis]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbeyondBoundsFlingDistance = flingPosition - Math.min(_metrics.scrollEnd[axis], _lastScrollPosition[axis]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbaseFlingComponent = flingDistance - beyondBoundsFlingDistance;\n\n\t\t\t\t\t\t\t// Determine the time proportion the original bound is along the fling curve\n\t\t\t\t\t\t\tif (!flingDistance || !flingDuration) {\n\t\t\t\t\t\t\t\ttimeProportion = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimeProportion = flingBezier._getCoordinateForT(flingBezier.getTForY((flingDistance - beyondBoundsFlingDistance) / flingDistance, 1 / flingDuration), flingBezier._p1.x, flingBezier._p2.x);\n\t\t\t\t\t\t\t\tboundsCrossDelay = timeProportion * flingDuration;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Eighth the distance beyonds the bounds\n\t\t\t\t\t\t\tmodifiedDistance = Math.ceil(beyondBoundsFlingDistance / 8);\n\n\t\t\t\t\t\t\t// Further limit the bounce to half the container dimensions\n\t\t\t\t\t\t\tif (Math.abs(modifiedDistance) > _metrics.container[axis] / 2) {\n\t\t\t\t\t\t\t\tif (modifiedDistance < 0) {\n\t\t\t\t\t\t\t\t\tmodifiedDistance = -Math.floor(_metrics.container[axis] / 2);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tmodifiedDistance = Math.floor(_metrics.container[axis] / 2);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (flingPosition > 0) {\n\t\t\t\t\t\t\t\tbounceTarget = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbounceTarget = _metrics.scrollEnd[axis];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// If the entire fling is a bounce, modify appropriately\n\t\t\t\t\t\t\tif (timeProportion === 0) {\n\t\t\t\t\t\t\t\tflingDuration = flingDuration / 6;\n\t\t\t\t\t\t\t\tflingPosition = _lastScrollPosition[axis] + baseFlingComponent + modifiedDistance;\n\t\t\t\t\t\t\t\tbounceDelay = flingDuration;\n\n\t\t\t\t\t\t\t// Otherwise, take a new curve and add it to the timeout stack for the bounce\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// The new bounce delay is the pre-boundary fling duration, plus a\n\t\t\t\t\t\t\t\t// sixth of the post-boundary fling.\n\t\t\t\t\t\t\t\tbounceDelay = (timeProportion + ((1 - timeProportion) / 6)) * flingDuration;\n\n\t\t\t\t\t\t\t\t_scheduleAxisPosition(axis, (_lastScrollPosition[axis] + baseFlingComponent + modifiedDistance), ((1 - timeProportion) * flingDuration / 6), _instanceOptions.bounceDecelerationBezier, boundsCrossDelay);\n\n\t\t\t\t\t\t\t\t// Modify the fling to match, clipping to prevent over-fling\n\t\t\t\t\t\t\t\tflingBezier = flingBezier.divideAtX(bounceDelay / flingDuration, 1 / flingDuration)[0];\n\t\t\t\t\t\t\t\tflingDuration = bounceDelay;\n\t\t\t\t\t\t\t\tflingPosition = (_lastScrollPosition[axis] + baseFlingComponent + modifiedDistance);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If the fling requires snapping to a snap location, and the bounce needs to\n\t\t\t\t\t\t// reverse the fling direction after the fling completes:\n\t\t\t\t\t\t} else if ((flingDistance < 0 && bounceDistance < flingDistance) || (flingDistance > 0 && bounceDistance > flingDistance)) {\n\n\t\t\t\t\t\t\t// Shorten the original fling duration to reflect the bounce\n\t\t\t\t\t\t\tflingPosition = flingPosition - Math.floor(flingDistance / 2);\n\t\t\t\t\t\t\tbounceDistance = bounceDistance - Math.floor(flingDistance / 2);\n\t\t\t\t\t\t\tbounceDuration = Math.sqrt(Math.abs(bounceDistance)) * 50;\n\t\t\t\t\t\t\tbounceTarget = flingPosition - bounceDistance;\n\t\t\t\t\t\t\tflingDuration = 350;\n\t\t\t\t\t\t\tbounceDelay = flingDuration * 0.97;\n\n\t\t\t\t\t\t// If the bounce is truncating the fling, or continuing the fling on in the same\n\t\t\t\t\t\t// direction to hit the next boundary:\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tflingPosition = flingPosition - bounceDistance;\n\n\t\t\t\t\t\t\t// If there was no fling distance originally, use the bounce details\n\t\t\t\t\t\t\tif (!flingDistance) {\n\t\t\t\t\t\t\t\tflingDuration = bounceDuration;\n\n\t\t\t\t\t\t\t// If truncating the fling at a snapping edge:\n\t\t\t\t\t\t\t} else if ((flingDistance < 0 && bounceDistance < 0) || (flingDistance > 0 && bounceDistance > 0)) {\n\t\t\t\t\t\t\t\ttimeProportion = flingBezier._getCoordinateForT(flingBezier.getTForY((Math.abs(flingDistance) - Math.abs(bounceDistance)) / Math.abs(flingDistance), 1 / flingDuration), flingBezier._p1.x, flingBezier._p2.x);\n\t\t\t\t\t\t\t\tflingBezier = flingBezier.divideAtX(timeProportion, 1 / flingDuration)[0];\n\t\t\t\t\t\t\t\tflingDuration = Math.round(flingDuration * timeProportion);\n\n\t\t\t\t\t\t\t// If extending the fling to reach the next snapping boundary, no further\n\t\t\t\t\t\t\t// action is required.\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbounceDistance = 0;\n\t\t\t\t\t\t\tbounceDuration = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// If no fling or bounce is required, continue\n\t\t\t\t\tif (flingPosition === _lastScrollPosition[axis] && !bounceDistance) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tmoveRequired = true;\n\n\t\t\t\t\t// Perform the fling\n\t\t\t\t\t_setAxisPosition(axis, flingPosition, flingDuration, flingBezier, boundsCrossDelay);\n\n\t\t\t\t\t// Schedule a bounce if appropriate\n\t\t\t\t\tif (bounceDistance && bounceDuration) {\n\t\t\t\t\t\t_scheduleAxisPosition(axis, bounceTarget, bounceDuration, _instanceOptions.bounceBezier, bounceDelay);\n\t\t\t\t\t}\n\n\t\t\t\t\tmaxAnimationTime = Math.max(maxAnimationTime, bounceDistance ? (bounceDelay + bounceDuration) : flingDuration);\n\t\t\t\t\tscrollPositionsToApply[axis] = (bounceTarget === false) ? flingPosition : bounceTarget;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (moveRequired && maxAnimationTime) {\n\t\t\t\t_timeouts.push(setTimeout(function () {\n\t\t\t\t\tvar anAxis;\n\n\t\t\t\t\t// Update the stored scroll position ready for finalising\n\t\t\t\t\tfor (anAxis in scrollPositionsToApply) {\n\t\t\t\t\t\tif (scrollPositionsToApply.hasOwnProperty(anAxis)) {\n\t\t\t\t\t\t\t_lastScrollPosition[anAxis] = scrollPositionsToApply[anAxis];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t_finalizeScroll();\n\t\t\t\t}, maxAnimationTime));\n\t\t\t}\n\n\t\t\treturn moveRequired;\n\t\t};\n\n\t\t/**\n\t\t * Bounce back into bounds if necessary, or snap to a grid location.\n\t\t */\n\t\t_snapScroll = function _snapScroll(scrollCancelled) {\n\t\t\tvar axis;\n\t\t\tvar snapDuration = scrollCancelled ? 100 : 350;\n\t\t\tvar targetPosition = _lastScrollPosition;\n\n\t\t\t// Get the current position and see if a snap is required\n\t\t\tif (_instanceOptions.snapping) {\n\n\t\t\t\t// Store current snap index\n\t\t\t\t_snapIndex = _getSnapIndexForPosition(targetPosition);\n\t\t\t\ttargetPosition = _getSnapPositionForIndexes(_snapIndex, targetPosition);\n\t\t\t}\n\t\t\ttargetPosition = _limitToBounds(targetPosition);\n\n\t\t\tvar snapRequired = false;\n\t\t\tfor (axis in _baseScrollableAxes) {\n\t\t\t\tif (_baseScrollableAxes.hasOwnProperty(axis)) {\n\t\t\t\t\tif (targetPosition[axis] !== _lastScrollPosition[axis]) {\n\t\t\t\t\t\tsnapRequired = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!snapRequired) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Perform the snap\n\t\t\tfor (axis in _baseScrollableAxes) {\n\t\t\t\tif (_baseScrollableAxes.hasOwnProperty(axis)) {\n\t\t\t\t\t_setAxisPosition(axis, targetPosition[axis], snapDuration);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_timeouts.push(setTimeout(function () {\n\n\t\t\t\t// Update the stored scroll position ready for finalizing\n\t\t\t\t_lastScrollPosition = targetPosition;\n\n\t\t\t\t_finalizeScroll(scrollCancelled);\n\t\t\t}, snapDuration));\n\n\t\t\treturn true;\n\t\t};\n\n\t\t/**\n\t\t * Get an appropriate snap index for a supplied point.\n\t\t */\n\t\t_getSnapIndexForPosition = function _getSnapIndexForPosition(coordinates) {\n\t\t\tvar axis;\n\t\t\tvar indexes = {x: 0, y: 0};\n\t\t\tfor (axis in _scrollableAxes) {\n\t\t\t\tif (_scrollableAxes.hasOwnProperty(axis) && _snapGridSize[axis]) {\n\t\t\t\t\tindexes[axis] = Math.round(coordinates[axis] / _snapGridSize[axis]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn indexes;\n\t\t};\n\n\t\t/**\n\t\t * Get an appropriate snap point for a supplied index.\n\t\t */\n\t\t_getSnapPositionForIndexes = function _getSnapPositionForIndexes(indexes, currentCoordinates) {\n\t\t\tvar axis;\n\t\t\tvar coordinatesToReturn = {\n\t\t\t\tx: currentCoordinates.x,\n\t\t\t\ty: currentCoordinates.y\n\t\t\t};\n\t\t\tfor (axis in _scrollableAxes) {\n\t\t\t\tif (_scrollableAxes.hasOwnProperty(axis)) {\n\t\t\t\t\tcoordinatesToReturn[axis] = indexes[axis] * _snapGridSize[axis];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn coordinatesToReturn;\n\t\t};\n\n\t\t/**\n\t\t * Update the scroll position while scrolling is active, checking the position\n\t\t * within bounds and rubberbanding/constraining as appropriate; also triggers a\n\t\t * scroll position render if a requestAnimationFrame loop isn't active\n\t\t */\n\t\t_constrainAndRenderTargetScrollPosition = function _constrainAndRenderTargetScrollPosition() {\n\t\t\tvar axis, upperBound, lowerBound;\n\n\t\t\t// Update axes target positions if beyond bounds\n\t\t\tfor (axis in _scrollableAxes) {\n\t\t\t\tif (_scrollableAxes.hasOwnProperty(axis)) {\n\n\t\t\t\t\t// Set bounds to the left and right of the container\n\t\t\t\t\tupperBound = 0;\n\t\t\t\t\tlowerBound = _metrics.scrollEnd[axis];\n\n\t\t\t\t\tif (_instanceOptions.singlePageScrolls && _instanceOptions.snapping) {\n\n\t\t\t\t\t\t// For a single-page-scroll, set the bounds to the left and right of the\n\t\t\t\t\t\t// current segment\n\t\t\t\t\t\tupperBound = Math.min(upperBound, -(_baseSegment[axis] - 1) * _snapGridSize[axis]);\n\t\t\t\t\t\tlowerBound = Math.max(lowerBound, -(_baseSegment[axis] + 1) * _snapGridSize[axis]);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (_targetScrollPosition[axis] > upperBound) {\n\t\t\t\t\t\t_targetScrollPosition[axis] = upperBound + _modifyDistanceBeyondBounds(_targetScrollPosition[axis] - upperBound, axis);\n\t\t\t\t\t} else if (_targetScrollPosition[axis] < lowerBound) {\n\t\t\t\t\t\t_targetScrollPosition[axis] = lowerBound + _modifyDistanceBeyondBounds(_targetScrollPosition[axis] - lowerBound, axis);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Trigger a scroll position update for platforms not using requestAnimationFrames\n\t\t\tif (!_reqAnimationFrame) {\n\t\t\t\t_scheduleRender();\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Limit coordinates within the bounds of the scrollable viewport.\n\t\t */\n\t\t_limitToBounds = function _limitToBounds(coordinates) {\n\t\t\tvar axis;\n\t\t\tvar coordinatesToReturn = { x: coordinates.x, y: coordinates.y };\n\n\t\t\tfor (axis in _scrollableAxes) {\n\t\t\t\tif (_scrollableAxes.hasOwnProperty(axis)) {\n\n\t\t\t\t\t// If the coordinate is beyond the edges of the scroller, use the closest edge\n\t\t\t\t\tif (coordinates[axis] > 0) {\n\t\t\t\t\t\tcoordinatesToReturn[axis] = 0;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (coordinates[axis] < _metrics.scrollEnd[axis]) {\n\t\t\t\t\t\tcoordinatesToReturn[axis] = _metrics.scrollEnd[axis];\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn coordinatesToReturn;\n\t\t};\n\n\n\t\t/**\n\t\t * Sets up the DOM around the node to be scrolled.\n\t\t */\n\t\t_initializeDOM = function _initializeDOM() {\n\t\t\tvar offscreenFragment, offscreenNode, scrollYParent;\n\n\t\t\t// Check whether the DOM is already present and valid - if so, no further action required.\n\t\t\tif (_existingDOMValid()) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Otherwise, the DOM needs to be created inside the originally supplied node.  The node\n\t\t\t// has a container inserted inside it - which acts as an anchor element with constraints -\n\t\t\t// and then the scrollable layers as appropriate.\n\n\t\t\t// Create a new document fragment to temporarily hold the scrollable content\n\t\t\toffscreenFragment = _scrollableMasterNode.ownerDocument.createDocumentFragment();\n\t\t\toffscreenNode = document.createElement('DIV');\n\t\t\toffscreenFragment.appendChild(offscreenNode);\n\n\t\t\t// Drop in the wrapping HTML\n\t\t\toffscreenNode.innerHTML = FTScroller.prototype.getPrependedHTML(!_instanceOptions.scrollingX, !_instanceOptions.scrollingY, _instanceOptions.hwAccelerationClass) + FTScroller.prototype.getAppendedHTML(!_instanceOptions.scrollingX, !_instanceOptions.scrollingY, _instanceOptions.hwAccelerationClass, _instanceOptions.scrollbars);\n\n\t\t\t// Update references as appropriate\n\t\t\t_containerNode = offscreenNode.firstElementChild;\n\t\t\tscrollYParent = _containerNode;\n\t\t\tif (_instanceOptions.scrollingX) {\n\t\t\t\t_scrollNodes.x = _containerNode.firstElementChild;\n\t\t\t\tscrollYParent = _scrollNodes.x;\n\t\t\t\tif (_instanceOptions.scrollbars) {\n\t\t\t\t\t_scrollbarNodes.x = _containerNode.getElementsByClassName('ftscroller_scrollbarx')[0];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (_instanceOptions.scrollingY) {\n\t\t\t\t_scrollNodes.y = scrollYParent.firstElementChild;\n\t\t\t\tif (_instanceOptions.scrollbars) {\n\t\t\t\t\t_scrollbarNodes.y = _containerNode.getElementsByClassName('ftscroller_scrollbary')[0];\n\t\t\t\t}\n\t\t\t\t_contentParentNode = _scrollNodes.y;\n\t\t\t} else {\n\t\t\t\t_contentParentNode = _scrollNodes.x;\n\t\t\t}\n\n\t\t\t// Take the contents of the scrollable element, and copy them into the new container\n\t\t\twhile (_scrollableMasterNode.firstChild) {\n\t\t\t\t_contentParentNode.appendChild(_scrollableMasterNode.firstChild);\n\t\t\t}\n\n\t\t\t// Move the wrapped elements back into the document\n\t\t\t_scrollableMasterNode.appendChild(_containerNode);\n\t\t};\n\n\t\t/**\n\t\t * Attempts to use any existing DOM scroller nodes if possible, returning true if so;\n\t\t * updates all internal element references.\n\t\t */\n\t\t_existingDOMValid = function _existingDOMValid() {\n\t\t\tvar scrollerContainer, layerX, layerY, yParent, scrollerX, scrollerY, candidates, i, l;\n\n\t\t\t// Check that there's an initial child node, and make sure it's the container class\n\t\t\tscrollerContainer = _scrollableMasterNode.firstElementChild;\n\t\t\tif (!scrollerContainer || scrollerContainer.className.indexOf('ftscroller_container') === -1) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If x-axis scrolling is enabled, find and verify the x scroller layer\n\t\t\tif (_instanceOptions.scrollingX) {\n\n\t\t\t\t// Find and verify the x scroller layer\n\t\t\t\tlayerX = scrollerContainer.firstElementChild;\n\t\t\t\tif (!layerX || layerX.className.indexOf('ftscroller_x') === -1) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tyParent = layerX;\n\n\t\t\t\t// Find and verify the x scrollbar if enabled\n\t\t\t\tif (_instanceOptions.scrollbars) {\n\t\t\t\t\tcandidates = scrollerContainer.getElementsByClassName('ftscroller_scrollbarx');\n\t\t\t\t\tif (candidates) {\n\t\t\t\t\t\tfor (i = 0, l = candidates.length; i < l; i = i + 1) {\n\t\t\t\t\t\t\tif (candidates[i].parentNode === scrollerContainer) {\n\t\t\t\t\t\t\t\tscrollerX = candidates[i];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!scrollerX) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tyParent = scrollerContainer;\n\t\t\t}\n\n\t\t\t// If y-axis scrolling is enabled, find and verify the y scroller layer\n\t\t\tif (_instanceOptions.scrollingY) {\n\n\t\t\t\t// Find and verify the x scroller layer\n\t\t\t\tlayerY = yParent.firstElementChild;\n\t\t\t\tif (!layerY || layerY.className.indexOf('ftscroller_y') === -1) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Find and verify the y scrollbar if enabled\n\t\t\t\tif (_instanceOptions.scrollbars) {\n\t\t\t\t\tcandidates = scrollerContainer.getElementsByClassName('ftscroller_scrollbary');\n\t\t\t\t\tif (candidates) {\n\t\t\t\t\t\tfor (i = 0, l = candidates.length; i < l; i = i + 1) {\n\t\t\t\t\t\t\tif (candidates[i].parentNode === scrollerContainer) {\n\t\t\t\t\t\t\t\tscrollerY = candidates[i];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!scrollerY) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Elements found and verified - update the references and return success\n\t\t\t_containerNode = scrollerContainer;\n\t\t\tif (layerX) {\n\t\t\t\t_scrollNodes.x = layerX;\n\t\t\t}\n\t\t\tif (layerY) {\n\t\t\t\t_scrollNodes.y = layerY;\n\t\t\t}\n\t\t\tif (scrollerX) {\n\t\t\t\t_scrollbarNodes.x = scrollerX;\n\t\t\t}\n\t\t\tif (scrollerY) {\n\t\t\t\t_scrollbarNodes.y = scrollerY;\n\t\t\t}\n\t\t\tif (_instanceOptions.scrollingY) {\n\t\t\t\t_contentParentNode = layerY;\n\t\t\t} else {\n\t\t\t\t_contentParentNode = layerX;\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\n\t\t_domChanged = function _domChanged(e) {\n\n\t\t\t// If the timer is active, clear it\n\t\t\tif (_domChangeDebouncer) {\n\t\t\t\twindow.clearTimeout(_domChangeDebouncer);\n\t\t\t}\n\n\t\t\t// React to resizes at once\n\t\t\tif (e && e.type === 'resize') {\n\t\t\t\t_updateDimensions();\n\n\t\t\t// For other changes, which may occur in groups, set up the DOM changed timer\n\t\t\t} else {\n\t\t\t\t_domChangeDebouncer = setTimeout(function () {\n\t\t\t\t\t_updateDimensions();\n\t\t\t\t}, 100);\n\t\t\t}\n\t\t};\n\n\t\t_updateDimensions = function _updateDimensions(ignoreSnapScroll) {\n\t\t\tvar axis;\n\n\t\t\t// Only update dimensions if the container node exists (DOM elements can go away if\n\t\t\t// the scroller instance is not destroyed correctly)\n\t\t\tif (!_containerNode || !_contentParentNode) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (_domChangeDebouncer) {\n\t\t\t\twindow.clearTimeout(_domChangeDebouncer);\n\t\t\t\t_domChangeDebouncer = false;\n\t\t\t}\n\t\t\tvar containerWidth, containerHeight, startAlignments;\n\n\t\t\t// Calculate the starting alignment for comparison later\n\t\t\tstartAlignments = { x: false, y: false };\n\t\t\tfor (axis in startAlignments) {\n\t\t\t\tif (startAlignments.hasOwnProperty(axis)) {\n\t\t\t\t\tif (_lastScrollPosition[axis] === 0) {\n\t\t\t\t\t\tstartAlignments[axis] = -1;\n\t\t\t\t\t} else if (_lastScrollPosition[axis] <= _metrics.scrollEnd[axis]) {\n\t\t\t\t\t\tstartAlignments[axis] = 1;\n\t\t\t\t\t} else if (_lastScrollPosition[axis] * 2 <= _metrics.scrollEnd[axis] + 5 && _lastScrollPosition[axis] * 2 >= _metrics.scrollEnd[axis] - 5) {\n\t\t\t\t\t\tstartAlignments[axis] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcontainerWidth = _containerNode.offsetWidth;\n\t\t\tcontainerHeight = _containerNode.offsetHeight;\n\n\t\t\t// Grab the dimensions\n\t\t\tvar rawScrollWidth = options.contentWidth || _contentParentNode.offsetWidth;\n\t\t\tvar rawScrollHeight = options.contentHeight || _contentParentNode.offsetHeight;\n\t\t\tvar scrollWidth = rawScrollWidth;\n\t\t\tvar scrollHeight = rawScrollHeight;\n\t\t\tvar targetPosition = { x: _lastScrollPosition.x, y: _lastScrollPosition.y };\n\n\t\t\t// Update snap grid\n\t\t\tif (!_snapGridSize.userX) {\n\t\t\t\t_snapGridSize.x = containerWidth;\n\t\t\t}\n\t\t\tif (!_snapGridSize.userY) {\n\t\t\t\t_snapGridSize.y = containerHeight;\n\t\t\t}\n\n\t\t\t// If there is a grid, conform to the grid\n\t\t\tif (_instanceOptions.snapping) {\n\t\t\t\tif (_snapGridSize.userX) {\n\t\t\t\t\tscrollWidth = Math.ceil(scrollWidth / _snapGridSize.userX) * _snapGridSize.userX;\n\t\t\t\t} else {\n\t\t\t\t\tscrollWidth = Math.ceil(scrollWidth / _snapGridSize.x) * _snapGridSize.x;\n\t\t\t\t}\n\t\t\t\tif (_snapGridSize.userY) {\n\t\t\t\t\tscrollHeight = Math.ceil(scrollHeight / _snapGridSize.userY) * _snapGridSize.userY;\n\t\t\t\t} else {\n\t\t\t\t\tscrollHeight = Math.ceil(scrollHeight / _snapGridSize.y) * _snapGridSize.y;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If no details have changed, return.\n\t\t\tif (_metrics.container.x === containerWidth && _metrics.container.y === containerHeight && _metrics.content.x === scrollWidth && _metrics.content.y === scrollHeight) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Update the sizes\n\t\t\t_metrics.container.x = containerWidth;\n\t\t\t_metrics.container.y = containerHeight;\n\t\t\t_metrics.content.x = scrollWidth;\n\t\t\t_metrics.content.rawX = rawScrollWidth;\n\t\t\t_metrics.content.y = scrollHeight;\n\t\t\t_metrics.content.rawY = rawScrollHeight;\n\t\t\t_metrics.scrollEnd.x = containerWidth - scrollWidth;\n\t\t\t_metrics.scrollEnd.y = containerHeight - scrollHeight;\n\n\t\t\t_updateScrollbarDimensions();\n\n\t\t\t// If scrolling is in progress, trigger a scroll update\n\t\t\tif (_isScrolling) {\n\t\t\t\t_lastScrollPosition.x--;\n\t\t\t\t_lastScrollPosition.y--;\n\t\t\t\t_constrainAndRenderTargetScrollPosition();\n\n\t\t\t// If scrolling *isn't* in progress, snap and realign.\n\t\t\t} else {\n\t\t\t\tif (!ignoreSnapScroll && _instanceOptions.snapping) {\n\n\t\t\t        // Ensure bounds are correct\n\t\t\t\t\t_updateSegments();\n\t\t\t\t\ttargetPosition = _getSnapPositionForIndexes(_snapIndex, _lastScrollPosition);\n\t\t\t\t}\n\n\t\t\t\t// Apply base alignment if appropriate\n\t\t\t\tfor (axis in targetPosition) {\n\t\t\t\t\tif (targetPosition.hasOwnProperty(axis)) {\n\n\t\t\t\t\t\t// If the container is smaller than the content, determine whether to apply the\n\t\t\t\t\t\t// alignment.  This occurs if a scroll has never taken place, or if the position\n\t\t\t\t\t\t// was previously at the correct \"end\" and can be maintained.\n\t\t\t\t\t\tif (_metrics.container[axis] < _metrics.content[axis]) {\n\t\t\t\t\t\t\tif (_hasBeenScrolled && _instanceOptions.baseAlignments[axis] !== startAlignments[axis]) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Apply the alignment\n\t\t\t\t\t\tif (_instanceOptions.baseAlignments[axis] === 1) {\n\t\t\t\t\t\t\ttargetPosition[axis] = _metrics.scrollEnd[axis];\n\t\t\t\t\t\t} else if (_instanceOptions.baseAlignments[axis] === 0) {\n\t\t\t\t\t\t\ttargetPosition[axis] = Math.floor(_metrics.scrollEnd[axis] / 2);\n\t\t\t\t\t\t} else if (_instanceOptions.baseAlignments[axis] === -1) {\n\t\t\t\t\t\t\ttargetPosition[axis] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Limit to bounds\n\t\t\t\ttargetPosition = _limitToBounds(targetPosition);\n\n\t\t\t\tif (_instanceOptions.scrollingX && targetPosition.x !== _lastScrollPosition.x) {\n\t\t\t\t\t_setAxisPosition('x', targetPosition.x, 0);\n\t\t\t\t\t_baseScrollPosition.x = targetPosition.x;\n\t\t\t\t}\n\t\t\t\tif (_instanceOptions.scrollingY && targetPosition.y !== _lastScrollPosition.y) {\n\t\t\t\t\t_setAxisPosition('y', targetPosition.y, 0);\n\t\t\t\t\t_baseScrollPosition.y = targetPosition.y;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t_updateScrollbarDimensions = function _updateScrollbarDimensions() {\n\n\t\t\t// Update scrollbar sizes\n\t\t\tif (_instanceOptions.scrollbars) {\n\t\t\t\tif (_instanceOptions.scrollingX) {\n\t\t\t\t\t_scrollbarNodes.x.style.width = Math.max(6, Math.round(_metrics.container.x * (_metrics.container.x / _metrics.content.x) - 4)) + 'px';\n\t\t\t\t}\n\t\t\t\tif (_instanceOptions.scrollingY) {\n\t\t\t\t\t_scrollbarNodes.y.style.height = Math.max(6, Math.round(_metrics.container.y * (_metrics.container.y / _metrics.content.y) - 4)) + 'px';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Update scroll caches\n\t\t\t_scrollableAxes = {};\n\t\t\tif (_instanceOptions.scrollingX && (_metrics.content.x > _metrics.container.x || _instanceOptions.alwaysScroll)) {\n\t\t\t\t_scrollableAxes.x = true;\n\t\t\t}\n\t\t\tif (_instanceOptions.scrollingY && (_metrics.content.y > _metrics.container.y || _instanceOptions.alwaysScroll)) {\n\t\t\t\t_scrollableAxes.y = true;\n\t\t\t}\n\t\t};\n\n\t\t_updateElementPosition = function _updateElementPosition() {\n\t\t\tvar axis, computedStyle, splitStyle;\n\n\t\t\t// Retrieve the current position of each active axis.\n\t\t\t// Custom parsing is used instead of native matrix support for speed and for\n\t\t\t// backwards compatibility.\n\t\t\tfor (axis in _scrollableAxes) {\n\t\t\t\tif (_scrollableAxes.hasOwnProperty(axis)) {\n\t\t\t\t\tcomputedStyle = window.getComputedStyle(_scrollNodes[axis], null)[_vendorTransformLookup];\n\t\t\t\t\tsplitStyle = computedStyle.split(', ');\n\n\t\t\t\t\t// For 2d-style transforms, pull out elements four or five\n\t\t\t\t\tif (splitStyle.length === 6) {\n\t\t\t\t\t\t_baseScrollPosition[axis] = parseInt(splitStyle[(axis === 'y') ? 5 : 4], 10);\n\n\t\t\t\t\t// For 3d-style transforms, pull out elements twelve or thirteen\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_baseScrollPosition[axis] = parseInt(splitStyle[(axis === 'y') ? 13 : 12], 10);\n\t\t\t\t\t}\n\t\t\t\t\t_lastScrollPosition[axis] = _baseScrollPosition[axis];\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t_updateSegments = function _updateSegments(scrollFinalised) {\n\t\t\tvar axis;\n\t\t\tvar newSegment = { x: 0, y: 0 };\n\n\t\t\t// If snapping is disabled, return without any further action required\n\t\t\tif (!_instanceOptions.snapping) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Calculate the new segments\n\t\t\tfor (axis in _scrollableAxes) {\n\t\t\t\tif (_scrollableAxes.hasOwnProperty(axis)) {\n\t\t\t\t\tnewSegment[axis] = Math.max(0, Math.min(Math.ceil(_metrics.content[axis] / _snapGridSize[axis]) - 1, Math.round(-_lastScrollPosition[axis] / _snapGridSize[axis])));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// In all cases update the active segment if appropriate\n\t\t\tif (newSegment.x !== _activeSegment.x || newSegment.y !== _activeSegment.y) {\n\t\t\t\t_activeSegment.x = newSegment.x;\n\t\t\t\t_activeSegment.y = newSegment.y;\n\t\t\t\t_fireEvent('segmentwillchange', { segmentX: newSegment.x, segmentY: newSegment.y });\n\t\t\t}\n\n\t\t\t// If the scroll has been finalised, also update the base segment\n\t\t\tif (scrollFinalised) {\n\t\t\t\tif (newSegment.x !== _baseSegment.x || newSegment.y !== _baseSegment.y) {\n\t\t\t\t\t_baseSegment.x = newSegment.x;\n\t\t\t\t\t_baseSegment.y = newSegment.y;\n\t\t\t\t\t_fireEvent('segmentdidchange', { segmentX: newSegment.x, segmentY: newSegment.y });\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t_setAxisPosition = function _setAxisPosition(axis, position, animationDuration, animationBezier, boundsCrossDelay) {\n\t\t\tvar transitionCSSString, newPositionAtExtremity = null;\n\n\t\t\t// Only update position if the axis node exists (DOM elements can go away if\n\t\t\t// the scroller instance is not destroyed correctly)\n\t\t\tif (!_scrollNodes[axis]) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Determine the transition property to apply to both the scroll element and the scrollbar\n\t\t\tif (animationDuration) {\n\t\t\t\tif (!animationBezier) {\n\t\t\t\t\tanimationBezier = _instanceOptions.flingBezier;\n\t\t\t\t}\n\n\t\t\t\ttransitionCSSString = _vendorCSSPrefix + 'transform ' + animationDuration + 'ms ' + animationBezier.toString();\n\t\t\t} else {\n\t\t\t\ttransitionCSSString = '';\n\t\t\t}\n\n\t\t\t// Apply the transition property to elements\n\t\t\t_scrollNodes[axis].style[_transitionProperty] = transitionCSSString;\n\t\t\tif (_instanceOptions.scrollbars) {\n\t\t\t\t_scrollbarNodes[axis].style[_transitionProperty] = transitionCSSString;\n\t\t\t}\n\n\t\t\t// Update the positions\n\t\t\t_scrollNodes[axis].style[_transformProperty] = _translateRulePrefix + _transformPrefixes[axis] + position + 'px' + _transformSuffixes[axis];\n\t\t\tif (_instanceOptions.scrollbars) {\n\t\t\t\t_scrollbarNodes[axis].style[_transformProperty] = _translateRulePrefix + _transformPrefixes[axis] + (-position * _metrics.container[axis] / _metrics.content[axis]) + 'px' + _transformSuffixes[axis];\n\t\t\t}\n\n\t\t\t// Determine whether the scroll is at an extremity.\n\t\t\tif (position >= 0) {\n\t\t\t\tnewPositionAtExtremity = 'start';\n\t\t\t} else if (position <= _metrics.scrollEnd[axis]) {\n\t\t\t\tnewPositionAtExtremity = 'end';\n\t\t\t}\n\n\t\t\t// If the extremity status has changed, fire an appropriate event\n\t\t\tif (newPositionAtExtremity !== _scrollAtExtremity[axis]) {\n\t\t\t\tif (newPositionAtExtremity !== null) {\n\t\t\t\t\tif (animationDuration) {\n\t\t\t\t\t\t_timeouts.push(setTimeout(function() {\n\t\t\t\t\t\t\t_fireEvent('reached' + newPositionAtExtremity, { axis: axis });\n\t\t\t\t\t\t}, boundsCrossDelay || animationDuration));\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_fireEvent('reached' + newPositionAtExtremity, { axis: axis });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_scrollAtExtremity[axis] = newPositionAtExtremity;\n\t\t\t}\n\n\t\t\t// Update the recorded position if there's no duration\n\t\t\tif (!animationDuration) {\n\t\t\t\t_lastScrollPosition[axis] = position;\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Retrieve the current position as an object with scrollLeft and scrollTop\n\t\t * properties.\n\t\t */\n\t\t_getPosition = function _getPosition() {\n\t\t\treturn {\n\t\t\t\tscrollLeft: -_lastScrollPosition.x,\n\t\t\t\tscrollTop: -_lastScrollPosition.y\n\t\t\t};\n\t\t};\n\n\t\t_scheduleAxisPosition = function _scheduleAxisPosition(axis, position, animationDuration, animationBezier, afterDelay) {\n\t\t\t_timeouts.push(setTimeout(function () {\n\t\t\t\t_setAxisPosition(axis, position, animationDuration, animationBezier);\n\t\t\t}, afterDelay));\n\t\t};\n\n\t\t_fireEvent = function _fireEvent(eventName, eventObject) {\n\t\t\tvar i, l;\n\t\t\teventObject.srcObject = _publicSelf;\n\n\t\t\t// Iterate through any listeners\n\t\t\tfor (i = 0, l = _eventListeners[eventName].length; i < l; i = i + 1) {\n\n\t\t\t\t// Execute each in a try/catch\n\t\t\t\ttry {\n\t\t\t\t\t_eventListeners[eventName][i](eventObject);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tif (window.console && window.console.error) {\n\t\t\t\t\t\tif (error.message) {\n\t\t\t\t\t\t\twindow.console.error(error.message + ' (' + error.sourceURL + ', line ' + error.line + ')');\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twindow.console.error('Error encountered executing FTScroller event listener callback for [' + eventName + ']. Add a \"debugger\" statement here to obtain a full backtrace.');\n\t\t\t\t\t\t\tif (window.console.dir) window.console.dir(error);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Update the scroll position so that the child element is in view.\n\t\t */\n\t\t_childFocused = function _childFocused(event) {\n\t\t\tvar offset, axis, visibleChildPortion;\n\t\t\tvar focusedNodeRect = _getBoundingRect(event.target);\n\t\t\tvar containerRect = _getBoundingRect(_containerNode);\n\t\t\tvar edgeMap = { x: 'left', y: 'top' };\n\t\t\tvar opEdgeMap = { x: 'right', y: 'bottom' };\n\t\t\tvar dimensionMap = { x: 'width', y: 'height' };\n\n\t\t\t// If an input is currently being tracked, ignore the focus event\n\t\t\tif (_inputIdentifier !== false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (axis in _scrollableAxes) {\n\t\t\t\tif (_scrollableAxes.hasOwnProperty(axis)) {\n\n\t\t\t\t\t// If the focussed node is entirely in view, there is no need to center it\n\t\t\t\t\tif (focusedNodeRect[edgeMap[axis]] >= containerRect[edgeMap[axis]] && focusedNodeRect[opEdgeMap[axis]] <= containerRect[opEdgeMap[axis]]) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If the focussed node is larger than the container...\n\t\t\t\t\tif (focusedNodeRect[dimensionMap[axis]] > containerRect[dimensionMap[axis]]) {\n\n\t\t\t\t\t\tvisibleChildPortion = focusedNodeRect[dimensionMap[axis]] - Math.max(0, containerRect[edgeMap[axis]] - focusedNodeRect[edgeMap[axis]]) - Math.max(0, focusedNodeRect[opEdgeMap[axis]] - containerRect[opEdgeMap[axis]]);\n\n\t\t\t\t\t\t// If more than half a container's portion of the focussed node is visible, there's no need to center it\n\t\t\t\t\t\tif (visibleChildPortion >= (containerRect[dimensionMap[axis]] / 2)) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Set the target offset to be in the middle of the container, or as close as bounds permit\n\t\t\t\t\toffset = -Math.round((focusedNodeRect[dimensionMap[axis]] / 2) - _lastScrollPosition[axis] + focusedNodeRect[edgeMap[axis]] - containerRect[edgeMap[axis]]  - (containerRect[dimensionMap[axis]] / 2));\n\t\t\t\t\toffset = Math.min(0, Math.max(_metrics.scrollEnd[axis], offset));\n\n\t\t\t\t\t// Perform the scroll\n\t\t\t\t\t_setAxisPosition(axis, offset, 0);\n\t\t\t\t\t_baseScrollPosition[axis] = offset;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconsole.log('firing scroll event from _childFocused');\n\t\t\t_fireEvent('scroll', _getPosition());\n\t\t};\n\n\t\t/**\n\t\t * Given a relative distance beyond the element bounds, returns a modified version to\n\t\t * simulate bouncy/springy edges.\n\t\t */\n\t\t_modifyDistanceBeyondBounds = function _modifyDistanceBeyondBounds(distance, axis) {\n\t\t\tif (!_instanceOptions.bouncing) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tvar e = Math.exp(distance / _metrics.container[axis]);\n\t\t\treturn Math.round(_metrics.container[axis] * 0.6 * (e - 1) / (e + 1));\n\t\t};\n\n\t\t/**\n\t\t * Given positions for each enabled axis, returns an object showing how far each axis is beyond\n\t\t * bounds. If within bounds, -1 is returned; if at the bounds, 0 is returned.\n\t\t */\n\t\t_distancesBeyondBounds = function _distancesBeyondBounds(positions) {\n\t\t\tvar axis, position;\n\t\t\tvar distances = {};\n\t\t\tfor (axis in positions) {\n\t\t\t\tif (positions.hasOwnProperty(axis)) {\n\t\t\t\t\tposition = positions[axis];\n\n\t\t\t\t\t// If the position is to the left/top, no further modification required\n\t\t\t\t\tif (position >= 0) {\n\t\t\t\t\t\tdistances[axis] = position;\n\n\t\t\t\t\t// If it's within the bounds, use -1\n\t\t\t\t\t} else if (position > _metrics.scrollEnd[axis]) {\n\t\t\t\t\t\tdistances[axis] = -1;\n\n\t\t\t\t\t// Otherwise, amend by the distance of the maximum edge\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdistances[axis] = _metrics.scrollEnd[axis] - position;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn distances;\n\t\t};\n\n\t\t/**\n\t\t * On platforms which support it, use RequestAnimationFrame to group\n\t\t * position updates for speed.  Starts the render process.\n\t\t */\n\t\t_startAnimation = function _startAnimation() {\n\t\t\tif (_reqAnimationFrame) {\n\t\t\t\t_cancelAnimation();\n\t\t\t\t_animationFrameRequest = _reqAnimationFrame(_scheduleRender);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * On platforms which support RequestAnimationFrame, provide the rendering loop.\n\t\t * Takes two arguments; the first is the render/position update function to\n\t\t * be called, and the second is a string controlling the render type to\n\t\t * allow previous changes to be cancelled - should be 'pan' or 'scroll'.\n\t\t */\n\t\t_scheduleRender = function _scheduleRender() {\n\t\t\tvar axis, positionUpdated;\n\n\t\t\t// If using requestAnimationFrame schedule the next update at once\n\t\t\tif (_reqAnimationFrame) {\n\t\t\t\t_animationFrameRequest = _reqAnimationFrame(_scheduleRender);\n\t\t\t}\n\n\t\t\t// Perform the draw.\n\t\t\tfor (axis in _scrollableAxes) {\n\t\t\t\tif (_scrollableAxes.hasOwnProperty(axis) && _targetScrollPosition[axis] !== _lastScrollPosition[axis]) {\n\t\t\t\t\t_setAxisPosition(axis, _targetScrollPosition[axis]);\n\t\t\t\t\tpositionUpdated = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If full, locked scrolling has enabled, fire any scroll and segment change events\n\t\t\tif (_isScrolling && positionUpdated) {\n\t\t\t\tconsole.log('firing scroll event from _scheduleRender');\n\t\t\t\t_fireEvent('scroll', _getPosition());\n\t\t\t\t_updateSegments(false);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Stops the animation process.\n\t\t */\n\t\t_cancelAnimation = function _cancelAnimation() {\n\t\t\tif (_animationFrameRequest === false || !_cancelAnimationFrame) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_cancelAnimationFrame(_animationFrameRequest);\n\t\t\t_animationFrameRequest = false;\n\t\t};\n\n\t\t/**\n\t\t * Remove then re-set event handlers\n\t\t */\n\t\t_resetEventHandlers = function() {\n\t\t\t_removeEventHandlers();\n\t\t\t_addEventHandlers();\n\t\t};\n\n\t\t/**\n\t\t * Register event handlers\n\t\t */\n\t\t_addEventHandlers = function _addEventHandlers() {\n\t\t\tvar MutationObserver;\n\n\t\t\t// Only remove the event if the node exists (DOM elements can go away)\n\t\t\tif (!_containerNode) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (_trackPointerEvents && !_instanceOptions.disabledInputMethods.pointer) {\n\t\t\t\tif (_pointerEventsPrefixed) {\n\t\t\t\t\t_containerNode.addEventListener('MSPointerDown', _onPointerDown);\n\t\t\t\t\t_containerNode.addEventListener('MSPointerMove', _onPointerMove);\n\t\t\t\t\t_containerNode.addEventListener('MSPointerUp', _onPointerUp);\n\t\t\t\t\t_containerNode.addEventListener('MSPointerCancel', _onPointerCancel);\n\t\t\t\t} else {\n\t\t\t\t\t_containerNode.addEventListener('pointerdown', _onPointerDown);\n\t\t\t\t\t_containerNode.addEventListener('pointermove', _onPointerMove);\n\t\t\t\t\t_containerNode.addEventListener('pointerup', _onPointerUp);\n\t\t\t\t\t_containerNode.addEventListener('pointercancel', _onPointerCancel);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (_trackTouchEvents && !_instanceOptions.disabledInputMethods.touch) {\n\t\t\t\t\t_containerNode.addEventListener('touchstart', _onTouchStart);\n\t\t\t\t\t_containerNode.addEventListener('touchmove', _onTouchMove);\n\t\t\t\t\t_containerNode.addEventListener('touchend', _onTouchEnd);\n\t\t\t\t\t_containerNode.addEventListener('touchcancel', _onTouchEnd);\n\t\t\t\t}\n\t\t\t\tif (!_instanceOptions.disabledInputMethods.mouse) {\n\t\t\t\t\t_containerNode.addEventListener('mousedown', _onMouseDown);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!_instanceOptions.disabledInputMethods.scroll) {\n\t\t\t\t_containerNode.addEventListener('DOMMouseScroll', _onMouseScroll);\n\t\t\t\t_containerNode.addEventListener('mousewheel', _onMouseScroll);\n\t\t\t}\n\n\t\t\t// If any of the input methods which would eventually trigger a click are\n\t\t\t// enabled, add a click event listener so that phantom clicks can be prevented\n\t\t\t// at the end of a scroll. Otherwise, don't add a listener and don't prevent\n\t\t\t// clicks.\n\t\t\tif (!_instanceOptions.disabledInputMethods.mouse || !_instanceOptions.disabledInputMethods.touch || !_instanceOptions.disabledInputMethods.pointer) {\n\n\t\t\t\t// Add a click listener.  On IE, add the listener to the document, to allow\n\t\t\t\t// clicks to be cancelled if a scroll ends outside the bounds of the container; on\n\t\t\t\t// other platforms, add to the container node.\n\t\t\t\tif (_trackPointerEvents) {\n\t\t\t\t\tdocument.addEventListener('click', _onClick, true);\n\t\t\t\t} else {\n\t\t\t\t\t_containerNode.addEventListener('click', _onClick, true);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Watch for changes inside the contained element to update bounds - de-bounced slightly.\n\t\t\tif (!_instanceOptions.disabledInputMethods.focus) {\n\t\t\t\t_contentParentNode.addEventListener('focus', _childFocused);\n\t\t\t}\n\t\t\tif (_instanceOptions.updateOnChanges) {\n\n\t\t\t\t// Try and reuse the old, disconnected observer instance if available\n\t\t\t\t// Otherwise, check for support before proceeding\n\t\t\t\tif (!_mutationObserver) {\n\t\t\t\t\tMutationObserver = window.MutationObserver || window.WebKitMutationObserver || window[_vendorStylePropertyPrefix + 'MutationObserver'];\n\t\t\t\t\tif (MutationObserver) {\n\t\t\t\t\t\t_mutationObserver = new MutationObserver(_domChanged);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (_mutationObserver) {\n\t\t\t\t\t_mutationObserver.observe(_contentParentNode, {\n\t\t\t\t\t\tchildList: true,\n\t\t\t\t\t\tcharacterData: true,\n\t\t\t\t\t\tsubtree: true\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\t_contentParentNode.addEventListener('DOMSubtreeModified', function (e) {\n\n\t\t\t\t\t\t// Ignore changes to nested FT Scrollers - even updating a transform style\n\t\t\t\t\t\t// can trigger a DOMSubtreeModified in IE, causing nested scrollers to always\n\t\t\t\t\t\t// favour the deepest scroller as parent scrollers 'resize'/end scrolling.\n\t\t\t\t\t\tif (e && (e.srcElement === _contentParentNode || e.srcElement.className.indexOf('ftscroller_') !== -1)) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_domChanged();\n\t\t\t\t\t}, true);\n\t\t\t\t}\n\t\t\t\t_contentParentNode.addEventListener('load', _domChanged);\n\t\t\t}\n\t\t\tif (_instanceOptions.updateOnWindowResize) {\n\t\t\t\twindow.addEventListener('resize', _domChanged);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Remove event handlers.\n\t\t *\n\t\t * The current flags may not match the state when the event handlers were set up,\n\t\t * so remove all event handlers unconditionally, just in case they're bound.\n\t\t */\n\t\t_removeEventHandlers = function _removeEventHandlers() {\n\n\t\t\tif (_containerNode) {\n\t\t\t\t_containerNode.removeEventListener('MSPointerDown', _onPointerDown);\n\t\t\t\t_containerNode.removeEventListener('MSPointerMove', _onPointerMove);\n\t\t\t\t_containerNode.removeEventListener('MSPointerUp', _onPointerUp);\n\t\t\t\t_containerNode.removeEventListener('MSPointerCancel', _onPointerCancel);\n\t\t\t\t_containerNode.removeEventListener('pointerdown', _onPointerDown);\n\t\t\t\t_containerNode.removeEventListener('pointermove', _onPointerMove);\n\t\t\t\t_containerNode.removeEventListener('pointerup', _onPointerUp);\n\t\t\t\t_containerNode.removeEventListener('pointercancel', _onPointerCancel);\n\t\t\t\t_containerNode.removeEventListener('touchstart', _onTouchStart);\n\t\t\t\t_containerNode.removeEventListener('touchmove', _onTouchMove);\n\t\t\t\t_containerNode.removeEventListener('touchend', _onTouchEnd);\n\t\t\t\t_containerNode.removeEventListener('touchcancel', _onTouchEnd);\n\t\t\t\t_containerNode.removeEventListener('mousedown', _onMouseDown);\n\t\t\t\t_containerNode.removeEventListener('DOMMouseScroll', _onMouseScroll);\n\t\t\t\t_containerNode.removeEventListener('mousewheel', _onMouseScroll);\n\t\t\t\t_containerNode.removeEventListener('click', _onClick, true);\n\t\t\t}\n\n\t\t\tif (_contentParentNode) {\n\t\t\t\t_contentParentNode.removeEventListener('focus', _childFocused);\n\t\t\t\t_contentParentNode.removeEventListener('DOMSubtreeModified', _domChanged);\n\t\t\t\t_contentParentNode.removeEventListener('load', _domChanged);\n\t\t\t}\n\n\t\t\tif (_mutationObserver) {\n\t\t\t\t_mutationObserver.disconnect();\n\t\t\t}\n\n\t\t\tdocument.removeEventListener('mousemove', _onMouseMove);\n\t\t\tdocument.removeEventListener('mouseup', _onMouseUp);\n\t\t\tdocument.removeEventListener('click', _onClick, true);\n\t\t\twindow.removeEventListener('resize', _domChanged);\n\t\t};\n\n\t\t/**\n\t\t * Touch event handlers\n\t\t */\n\t\t_onTouchStart = function _onTouchStart(startEvent) {\n\t\t\tvar i, l, touchEvent;\n\n\t\t\t// If a touch is already active, ensure that the index\n\t\t\t// is mapped to the correct finger, and return.\n\t\t\tif (_inputIdentifier) {\n\t\t\t\tfor (i = 0, l = startEvent.touches.length; i < l; i = i + 1) {\n\t\t\t\t\tif (startEvent.touches[i].identifier === _inputIdentifier) {\n\t\t\t\t\t\t_inputIndex = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Track the new touch's identifier, reset index, and pass\n\t\t\t// the coordinates to the scroll start function.\n\t\t\ttouchEvent = startEvent.touches[0];\n\t\t\t_inputIdentifier = touchEvent.identifier;\n\t\t\t_inputIndex = 0;\n\t\t\t_startScroll(touchEvent.clientX, touchEvent.clientY, startEvent.timeStamp, startEvent);\n\t\t};\n\t\t_onTouchMove = function _onTouchMove(moveEvent) {\n\t\t\tif (_inputIdentifier === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Get the coordinates from the appropriate touch event and\n\t\t\t// pass them on to the scroll handler\n\t\t\tvar touchEvent = moveEvent.touches[_inputIndex];\n\t\t\t_updateScroll(touchEvent.clientX, touchEvent.clientY, moveEvent.timeStamp, moveEvent);\n\t\t};\n\t\t_onTouchEnd = function _onTouchEnd(endEvent) {\n\t\t\tvar i, l;\n\n\t\t\t// Check whether the original touch event is still active,\n\t\t\t// if it is, update the index and return.\n\t\t\tif (endEvent.touches) {\n\t\t\t\tfor (i = 0, l = endEvent.touches.length; i < l; i = i + 1) {\n\t\t\t\t\tif (endEvent.touches[i].identifier === _inputIdentifier) {\n\t\t\t\t\t\t_inputIndex = i;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Complete the scroll.  Note that touch end events\n\t\t\t// don't capture coordinates.\n\t\t\t_endScroll(endEvent.timeStamp, endEvent);\n\t\t};\n\n\t\t/**\n\t\t * Mouse event handlers\n\t\t */\n\t\t_onMouseDown = function _onMouseDown(startEvent) {\n\n\t\t\t// Don't track the right mouse buttons, or a context menu\n\t\t\tif ((startEvent.button && startEvent.button === 2) || startEvent.ctrlKey) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Capture if possible\n\t\t\tif (_containerNode.setCapture) {\n\t\t\t\t_containerNode.setCapture();\n\t\t\t}\n\n\t\t\t// Add move & up handlers to the *document* to allow handling outside the element\n\t\t\tdocument.addEventListener('mousemove', _onMouseMove, true);\n\t\t\tdocument.addEventListener('mouseup', _onMouseUp, true);\n\n\t\t\t_inputIdentifier = startEvent.button || 1;\n\t\t\t_inputIndex = 0;\n\t\t\t_startScroll(startEvent.clientX, startEvent.clientY, startEvent.timeStamp, startEvent);\n\t\t};\n\t\t_onMouseMove = function _onMouseMove(moveEvent) {\n\t\t\tif (!_inputIdentifier) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_updateScroll(moveEvent.clientX, moveEvent.clientY, moveEvent.timeStamp, moveEvent);\n\t\t};\n\t\t_onMouseUp = function _onMouseUp(endEvent) {\n\t\t\tif (endEvent.button && endEvent.button !== _inputIdentifier) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tdocument.removeEventListener('mousemove', _onMouseMove, true);\n\t\t\tdocument.removeEventListener('mouseup', _onMouseUp, true);\n\n\t\t\t// Release capture if possible\n\t\t\tif (_containerNode.releaseCapture) {\n\t\t\t\t_containerNode.releaseCapture();\n\t\t\t}\n\n\t\t\t_endScroll(endEvent.timeStamp, endEvent);\n\t\t};\n\n\t\t/**\n\t\t * Pointer event handlers\n\t\t */\n\t\t_onPointerDown = function _onPointerDown(startEvent) {\n\n\t\t\t// If there is already a pointer event being tracked, ignore subsequent.\n\t\t\t// However, if this pointer is seen as the primary pointer, override that.\n\t\t\tif (_inputIdentifier && !startEvent.isPrimary) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Disable specific input types if specified in the config.  Separate\n\t\t\t// out touch and other events (eg treat both pen and mouse as \"mouse\")\n\t\t\tif (startEvent.pointerType === _pointerTypeTouch) {\n\t\t\t\tif (_instanceOptions.disabledInputMethods.touch) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else if (_instanceOptions.disabledInputMethods.mouse) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_inputIdentifier = startEvent.pointerId;\n\t\t\t_startScroll(startEvent.clientX, startEvent.clientY, startEvent.timeStamp, startEvent);\n\t\t};\n\t\t_onPointerMove = function _onPointerMove(moveEvent) {\n\t\t\tif (_inputIdentifier !== moveEvent.pointerId) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t_updateScroll(moveEvent.clientX, moveEvent.clientY, moveEvent.timeStamp, moveEvent);\n\t\t};\n\t\t_onPointerUp = function _onPointerUp(endEvent) {\n\t\t\tif (_inputIdentifier !== endEvent.pointerId) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_endScroll(endEvent.timeStamp, endEvent);\n\t\t};\n\t\t_onPointerCancel = function _onPointerCancel(endEvent) {\n\t\t\t_endScroll(endEvent.timeStamp, endEvent);\n\t\t};\n\t\t_onPointerCaptureEnd = function _onPointerCaptureEnd(event) {\n\n\t\t\t// On pointer capture end - which can happen because of another element\n\t\t\t// releasing pointer capture - don't end scrolling, but do track that\n\t\t\t// input capture has been lost.  This will result in pointers leaving\n\t\t\t// the window possibly being lost, but further interactions will fix\n\t\t\t// the tracking again.\n\t\t\t_inputCaptured = false;\n\t\t};\n\n\n\t\t/**\n\t\t * Prevents click actions if appropriate\n\t\t */\n\t\t_onClick = function _onClick(clickEvent) {\n\n\t\t\t// If a scroll action hasn't resulted in the next scroll being prevented, and a scroll\n\t\t\t// isn't currently in progress with a different identifier, allow the click\n\t\t\tif (!_preventClick) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// Prevent clicks using the preventDefault() and stopPropagation() handlers on the event;\n\t\t\t// this is safe even in IE10 as this is always a \"true\" event, never a window.event.\n\t\t\tclickEvent.preventDefault();\n\t\t\tclickEvent.stopPropagation();\n\t\t\tif (!_inputIdentifier) {\n\t\t\t\t_preventClick = false;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\n\t\t/**\n\t\t * Process scroll wheel/input actions as scroller scrolls\n\t\t */\n\t\t_onMouseScroll = function _onMouseScroll(event) {\n\t\t\tvar scrollDeltaX, scrollDeltaY;\n\t\t\tif (_inputIdentifier !== 'scrollwheel') {\n\t\t\t\tif (_inputIdentifier !== false) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t_inputIdentifier = 'scrollwheel';\n\t\t\t\t_cumulativeScroll.x = 0;\n\t\t\t\t_cumulativeScroll.y = 0;\n\n\t\t\t\t// Start a scroll event\n\t\t\t\tif (!_startScroll(event.clientX, event.clientY, Date.now(), event)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Convert the scrollwheel values to a scroll value\n\t\t\tif (event.wheelDelta) {\n\t\t\t\tif (event.wheelDeltaX) {\n\t\t\t\t\tscrollDeltaX = event.wheelDeltaX / 2;\n\t\t\t\t\tscrollDeltaY = event.wheelDeltaY / 2;\n\t\t\t\t} else {\n\t\t\t\t\tscrollDeltaX = 0;\n\t\t\t\t\tscrollDeltaY = event.wheelDelta / 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (event.axis && event.axis === event.HORIZONTAL_AXIS) {\n\t\t\t\t\tscrollDeltaX = event.detail * -10;\n\t\t\t\t\tscrollDeltaY = 0;\n\t\t\t\t} else {\n\t\t\t\t\tscrollDeltaX = 0;\n\t\t\t\t\tscrollDeltaY = event.detail * -10;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If the scroller is constrained to an x axis, convert y scroll to allow single-axis scroll\n\t\t\t// wheels to scroll constrained content.\n\t\t\tif (!_instanceOptions.scrollingY && !scrollDeltaX) {\n\t\t\t\tscrollDeltaX = scrollDeltaY;\n\t\t\t\tscrollDeltaY = 0;\n\t\t\t}\n\n\t\t\t_cumulativeScroll.x = Math.round(_cumulativeScroll.x + scrollDeltaX);\n\t\t\t_cumulativeScroll.y = Math.round(_cumulativeScroll.y + scrollDeltaY);\n\n\t\t\t_updateScroll(_gestureStart.x + _cumulativeScroll.x, _gestureStart.y + _cumulativeScroll.y, event.timeStamp, event);\n\n\t\t\t// End scrolling state\n\t\t\tif (_scrollWheelEndDebouncer) {\n\t\t\t\tclearTimeout(_scrollWheelEndDebouncer);\n\t\t\t}\n\t\t\t_scrollWheelEndDebouncer = setTimeout(function () {\n\t\t\t\t_releaseInputCapture();\n\t\t\t\t_inputIdentifier = false;\n\t\t\t\t_isScrolling = false;\n\t\t\t\t_preventClick = false;\n\t\t\t\t_isDisplayingScroll = false;\n\t\t\t\t_ftscrollerMoving = false;\n\t\t\t\tif (_instanceOptions.windowScrollingActiveFlag) {\n\t\t\t\t\twindow[_instanceOptions.windowScrollingActiveFlag] = false;\n\t\t\t\t}\n\t\t\t\t_cancelAnimation();\n\t\t\t\tif (!_snapScroll()) {\n\t\t\t\t\t_finalizeScroll();\n\t\t\t\t}\n\t\t\t}, 300);\n\t\t};\n\n\t\t/**\n\t\t * Capture and release input support, particularly allowing tracking\n\t\t * of Metro pointers outside the docked view.  Note that _releaseInputCapture\n\t\t * should be called before the input identifier is cleared.\n\t\t */\n\t\t_captureInput = function _captureInput() {\n\t\t\tif (_inputCaptured || _inputIdentifier === false || _inputIdentifier === 'scrollwheel') {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (_trackPointerEvents) {\n\t\t\t\t_containerNode[_setPointerCapture](_inputIdentifier);\n\t\t\t\t_containerNode.addEventListener(_lostPointerCapture, _onPointerCaptureEnd, false);\n\t\t\t}\n\t\t\t_inputCaptured = true;\n\t\t};\n\t\t_releaseInputCapture = function _releaseInputCapture() {\n\t\t\tif (!_inputCaptured) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (_trackPointerEvents) {\n\t\t\t\t_containerNode.removeEventListener(_lostPointerCapture, _onPointerCaptureEnd, false);\n\t\t\t\t_containerNode[_releasePointerCapture](_inputIdentifier);\n\t\t\t}\n\t\t\t_inputCaptured = false;\n\t\t};\n\n\t\t/**\n\t\t * Utility function acting as a getBoundingClientRect polyfill.\n\t\t */\n\t\t_getBoundingRect = function _getBoundingRect(anElement) {\n\t\t\tif (anElement.getBoundingClientRect) {\n\t\t\t\treturn anElement.getBoundingClientRect();\n\t\t\t}\n\n\t\t\tvar x = 0, y = 0, eachElement = anElement;\n\t\t\twhile (eachElement) {\n\t\t\t\tx = x + eachElement.offsetLeft - eachElement.scrollLeft;\n\t\t\t\ty = y + eachElement.offsetTop - eachElement.scrollTop;\n\t\t\t\teachElement = eachElement.offsetParent;\n\t\t\t}\n\t\t\treturn { left: x, top: y, width: anElement.offsetWidth, height: anElement.offsetHeight };\n\t\t};\n\n\n\t\t/*                     Instantiation                     */\n\n\t\t// Set up the DOM node if appropriate\n\t\t_initializeDOM();\n\n\t\t// Update sizes\n\t\t_updateDimensions();\n\n\t\t// Set up the event handlers\n\t\t_addEventHandlers();\n\n\t\t// Define a public API to be returned at the bottom - this is the public-facing interface.\n\t\t_publicSelf = {\n\t\t\tdestroy: destroy,\n\t\t\tsetSnapSize: setSnapSize,\n\t\t\tscrollTo: scrollTo,\n\t\t\tscrollBy: scrollBy,\n\t\t\tupdateDimensions: updateDimensions,\n\t\t\taddEventListener: addEventListener,\n\t\t\tremoveEventListener: removeEventListener,\n\t\t\tsetDisabledInputMethods: setDisabledInputMethods\n\t\t};\n\n\t\tif (Object.defineProperties) {\n\t\t\tObject.defineProperties(_publicSelf, {\n\t\t\t\t'scrollHeight': {\n\t\t\t\t\tget: function() { return _metrics.content.y; },\n\t\t\t\t\tset: function(value) { throw new SyntaxError('scrollHeight is currently read-only - ignoring ' + value); }\n\t\t\t\t},\n\t\t\t\t'scrollLeft': {\n\t\t\t\t\tget: function() { return -_lastScrollPosition.x; },\n\t\t\t\t\tset: function(value) { scrollTo(value, false, false); return -_lastScrollPosition.x; }\n\t\t\t\t},\n\t\t\t\t'scrollTop': {\n\t\t\t\t\tget: function() { return -_lastScrollPosition.y; },\n\t\t\t\t\tset: function(value) { scrollTo(false, value, false); return -_lastScrollPosition.y; }\n\t\t\t\t},\n\t\t\t\t'scrollWidth': {\n\t\t\t\t\tget: function() { return _metrics.content.x; },\n\t\t\t\t\tset: function(value) { throw new SyntaxError('scrollWidth is currently read-only - ignoring ' + value); }\n\t\t\t\t},\n\t\t\t\t'segmentCount': {\n\t\t\t\t\tget: function() {\n\t\t\t\t\t\tif (!_instanceOptions.snapping) {\n\t\t\t\t\t\t\treturn { x: NaN, y: NaN };\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tx: Math.ceil(_metrics.content.x / _snapGridSize.x),\n\t\t\t\t\t\t\ty: Math.ceil(_metrics.content.y / _snapGridSize.y)\n\t\t\t\t\t\t};\n\t\t\t\t\t},\n\t\t\t\t\tset: function(value) { throw new SyntaxError('segmentCount is currently read-only - ignoring ' + value); }\n\t\t\t\t},\n\t\t\t\t'currentSegment': {\n\t\t\t\t\tget: function() { return { x: _activeSegment.x, y: _activeSegment.y }; },\n\t\t\t\t\tset: function(value) { throw new SyntaxError('currentSegment is currently read-only - ignoring ' + value); }\n\t\t\t\t},\n\t\t\t\t'contentContainerNode': {\n\t\t\t\t\tget: function() { return _contentParentNode; },\n\t\t\t\t\tset: function(value) { throw new SyntaxError('contentContainerNode is currently read-only - ignoring ' + value); }\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// Return the public interface.\n\t\treturn _publicSelf;\n\t};\n\n\n\t/*          Prototype Functions and Properties           */\n\n\t/**\n\t * The HTML to prepend to the scrollable content to wrap it. Used internally,\n\t * and may be used to pre-wrap scrollable content.  Axes can optionally\n\t * be excluded for speed improvements.\n\t */\n\tFTScroller.prototype.getPrependedHTML = function (excludeXAxis, excludeYAxis, hwAccelerationClass) {\n\t\tif (!hwAccelerationClass) {\n\t\t\tif (typeof FTScrollerOptions === 'object' && FTScrollerOptions.hwAccelerationClass) {\n\t\t\t\thwAccelerationClass = FTScrollerOptions.hwAccelerationClass;\n\t\t\t} else {\n\t\t\t\thwAccelerationClass = 'ftscroller_hwaccelerated';\n\t\t\t}\n\t\t}\n\n\t\tvar output = '<div class=\"ftscroller_container\">';\n\t\tif (!excludeXAxis) {\n\t\t\toutput += '<div class=\"ftscroller_x ' + hwAccelerationClass + '\">';\n\t\t}\n\t\tif (!excludeYAxis) {\n\t\t\toutput += '<div class=\"ftscroller_y ' + hwAccelerationClass + '\">';\n\t\t}\n\n\t\treturn output;\n\t};\n\n\t/**\n\t * The HTML to append to the scrollable content to wrap it; again, used internally,\n\t * and may be used to pre-wrap scrollable content.\n\t */\n\tFTScroller.prototype.getAppendedHTML = function (excludeXAxis, excludeYAxis, hwAccelerationClass, scrollbars) {\n\t\tif (!hwAccelerationClass) {\n\t\t\tif (typeof FTScrollerOptions === 'object' && FTScrollerOptions.hwAccelerationClass) {\n\t\t\t\thwAccelerationClass = FTScrollerOptions.hwAccelerationClass;\n\t\t\t} else {\n\t\t\t\thwAccelerationClass = 'ftscroller_hwaccelerated';\n\t\t\t}\n\t\t}\n\n\t\tvar output = '';\n\t\tif (!excludeXAxis) {\n\t\t\toutput += '</div>';\n\t\t}\n\t\tif (!excludeYAxis) {\n\t\t\toutput += '</div>';\n\t\t}\n\t\tif (scrollbars) {\n\t\t\tif (!excludeXAxis) {\n\t\t\t\toutput += '<div class=\"ftscroller_scrollbar ftscroller_scrollbarx ' + hwAccelerationClass + '\"><div class=\"ftscroller_scrollbarinner\"></div></div>';\n\t\t\t}\n\t\t\tif (!excludeYAxis) {\n\t\t\t\toutput += '<div class=\"ftscroller_scrollbar ftscroller_scrollbary ' + hwAccelerationClass + '\"><div class=\"ftscroller_scrollbarinner\"></div></div>';\n\t\t\t}\n\t\t}\n\t\toutput += '</div>';\n\n\t\treturn output;\n\t};\n}());\n\n\n(function () {\n\t'use strict';\n\n\tfunction clamp(value) {\n\t\tif (value > 1.0) return 1.0;\n\t\tif (value < 0.0) return 0.0;\n\t\treturn value;\n\t}\n\n\t/**\n\t * Represents a two-dimensional cubic bezier curve with the starting\n\t * point (0, 0) and the end point (1, 1). The two control points p1 and p2\n\t * have x and y coordinates between 0 and 1.\n\t *\n\t * This type of bezier curves can be used as CSS transform timing functions.\n\t */\n\tCubicBezier = function (p1x, p1y, p2x, p2y) {\n\t\t// Control points\n\t\tthis._p1 = { x: clamp(p1x), y: clamp(p1y) };\n\t\tthis._p2 = { x: clamp(p2x), y: clamp(p2y) };\n\t};\n\n\tCubicBezier.prototype._getCoordinateForT = function (t, p1, p2) {\n\t\tvar c = 3 * p1,\n\t\t\tb = 3 * (p2 - p1) - c,\n\t\t\ta = 1 - c - b;\n\n\t\treturn ((a * t + b) * t + c) * t;\n\t};\n\n\tCubicBezier.prototype._getCoordinateDerivateForT = function (t, p1, p2) {\n\t\tvar c = 3 * p1,\n\t\t\tb = 3 * (p2 - p1) - c,\n\t\t\ta = 1 - c - b;\n\n\t\treturn (3 * a * t + 2 * b) * t + c;\n\t};\n\n\tCubicBezier.prototype._getTForCoordinate = function (c, p1, p2, epsilon) {\n\t\tif (!isFinite(epsilon) || epsilon <= 0) {\n\t\t\tthrow new RangeError('\"epsilon\" must be a number greater than 0.');\n\t\t}\n\t\tvar t2, i, c2, d2;\n\n\t\t// First try a few iterations of Newton's method -- normally very fast.\n\t\tfor (t2 = c, i = 0; i < 8; i = i + 1) {\n\t\t\tc2 = this._getCoordinateForT(t2, p1, p2) - c;\n\t\t\tif (Math.abs(c2) < epsilon) {\n\t\t\t\treturn t2;\n\t\t\t}\n\t\t\td2 = this._getCoordinateDerivateForT(t2, p1, p2);\n\t\t\tif (Math.abs(d2) < 1e-6) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tt2 = t2 - c2 / d2;\n\t\t}\n\n\t\t// Fall back to the bisection method for reliability.\n\t\tt2 = c;\n\t\tvar t0 = 0,\n\t\t\tt1 = 1;\n\n\t\tif (t2 < t0) {\n\t\t\treturn t0;\n\t\t}\n\t\tif (t2 > t1) {\n\t\t\treturn t1;\n\t\t}\n\n\t\twhile (t0 < t1) {\n\t\t\tc2 = this._getCoordinateForT(t2, p1, p2);\n\t\t\tif (Math.abs(c2 - c) < epsilon) {\n\t\t\t\treturn t2;\n\t\t\t}\n\t\t\tif (c > c2) {\n\t\t\t\tt0 = t2;\n\t\t\t} else {\n\t\t\t\tt1 = t2;\n\t\t\t}\n\t\t\tt2 = (t1 - t0) * 0.5 + t0;\n\t\t}\n\n\t\t// Failure.\n\t\treturn t2;\n\t};\n\n\t/**\n\t * Computes the point for a given t value.\n\t *\n\t * @param {number} t\n\t * @returns {Object} Returns an object with x and y properties\n\t */\n\tCubicBezier.prototype.getPointForT = function (t) {\n\n\t\t// Special cases: starting and ending points\n\t\tif (t === 0 || t === 1) {\n\t\t\treturn { x: t, y: t };\n\t\t}\n\n\t\t// Check for correct t value (must be between 0 and 1)\n\t\tif (t < 0 || t > 1) {\n\t\t\t_throwRangeError('t', t);\n\t\t}\n\n\t\treturn {\n\t\t\tx: this._getCoordinateForT(t, this._p1.x, this._p2.x),\n\t\t\ty: this._getCoordinateForT(t, this._p1.y, this._p2.y)\n\t\t};\n\t};\n\n\tCubicBezier.prototype.getTForX = function (x, epsilon) {\n\t\treturn this._getTForCoordinate(x, this._p1.x, this._p2.x, epsilon);\n\t};\n\n\tCubicBezier.prototype.getTForY = function (y, epsilon) {\n\t\treturn this._getTForCoordinate(y, this._p1.y, this._p2.y, epsilon);\n\t};\n\n\t/**\n\t * Computes auxiliary points using De Casteljau's algorithm.\n\t *\n\t * @param {number} t must be greater than 0 and lower than 1.\n\t * @returns {Object} with members i0, i1, i2 (first iteration),\n\t *    j1, j2 (second iteration) and k (the exact point for t)\n\t */\n\tCubicBezier.prototype._getAuxPoints = function (t) {\n\t\tif (t <= 0 || t >= 1) {\n\t\t\t_throwRangeError('t', t);\n\t\t}\n\n\n\t\t/* First series of auxiliary points */\n\n\t\t// First control point of the left curve\n\t\tvar i0 = {\n\t\t\t\tx: t * this._p1.x,\n\t\t\t\ty: t * this._p1.y\n\t\t\t},\n\t\t\ti1 = {\n\t\t\t\tx: this._p1.x + t * (this._p2.x - this._p1.x),\n\t\t\t\ty: this._p1.y + t * (this._p2.y - this._p1.y)\n\t\t\t},\n\n\t\t\t// Second control point of the right curve\n\t\t\ti2  = {\n\t\t\t\tx: this._p2.x + t * (1 - this._p2.x),\n\t\t\t\ty: this._p2.y + t * (1 - this._p2.y)\n\t\t\t};\n\n\n\t\t/* Second series of auxiliary points */\n\n\t\t// Second control point of the left curve\n\t\tvar j0 = {\n\t\t\t\tx: i0.x + t * (i1.x - i0.x),\n\t\t\t\ty: i0.y + t * (i1.y - i0.y)\n\t\t\t},\n\n\t\t\t// First control point of the right curve\n\t\t\tj1 = {\n\t\t\t\tx: i1.x + t * (i2.x - i1.x),\n\t\t\t\ty: i1.y + t * (i2.y - i1.y)\n\t\t\t};\n\n\t\t// The division point (ending point of left curve, starting point of right curve)\n\t\tvar k = {\n\t\t\t\tx: j0.x + t * (j1.x - j0.x),\n\t\t\t\ty: j0.y + t * (j1.y - j0.y)\n\t\t\t};\n\n\t\treturn {\n\t\t\ti0: i0,\n\t\t\ti1: i1,\n\t\t\ti2: i2,\n\t\t\tj0: j0,\n\t\t\tj1: j1,\n\t\t\tk: k\n\t\t};\n\t};\n\n\t/**\n\t * Divides the bezier curve into two bezier functions.\n\t *\n\t * De Casteljau's algorithm is used to compute the new starting, ending, and\n\t * control points.\n\t *\n\t * @param {number} t must be greater than 0 and lower than 1.\n\t *     t === 1 or t === 0 are the starting/ending points of the curve, so no\n\t *     division is needed.\n\t *\n\t * @returns {CubicBezier[]} Returns an array containing two bezier curves\n\t *     to the left and the right of t.\n\t */\n\tCubicBezier.prototype.divideAtT = function (t) {\n\t\tif (t < 0 || t > 1) {\n\t\t\t_throwRangeError('t', t);\n\t\t}\n\n\t\t// Special cases t = 0, t = 1: Curve can be cloned for one side, the other\n\t\t// side is a linear curve (with duration 0)\n\t\tif (t === 0 || t === 1) {\n\t\t\tvar curves = [];\n\t\t\tcurves[t] = CubicBezier.linear();\n\t\t\tcurves[1 - t] = this.clone();\n\t\t\treturn curves;\n\t\t}\n\n\t\tvar left = {},\n\t\t\tright = {},\n\t\t\tpoints = this._getAuxPoints(t);\n\n\t\tvar i0 = points.i0,\n\t\t\ti2 = points.i2,\n\t\t\tj0 = points.j0,\n\t\t\tj1 = points.j1,\n\t\t\tk = points.k;\n\n\t\t// Normalize derived points, so that the new curves starting/ending point\n\t\t// coordinates are (0, 0) respectively (1, 1)\n\t\tvar factorX = k.x,\n\t\t\tfactorY = k.y;\n\n\t\tleft.p1 = {\n\t\t\tx: i0.x / factorX,\n\t\t\ty: i0.y / factorY\n\t\t};\n\t\tleft.p2 = {\n\t\t\tx: j0.x / factorX,\n\t\t\ty: j0.y / factorY\n\t\t};\n\n\t\tright.p1 = {\n\t\t\tx: (j1.x - factorX) / (1 - factorX),\n\t\t\ty: (j1.y - factorY) / (1 - factorY)\n\t\t};\n\n\t\tright.p2 = {\n\t\t\tx: (i2.x - factorX) / (1 - factorX),\n\t\t\ty: (i2.y - factorY) / (1 - factorY)\n\t\t};\n\n\t\treturn [\n\t\t\tnew CubicBezier(left.p1.x, left.p1.y, left.p2.x, left.p2.y),\n\t\t\tnew CubicBezier(right.p1.x, right.p1.y, right.p2.x, right.p2.y)\n\t\t];\n\t};\n\n\tCubicBezier.prototype.divideAtX = function (x, epsilon) {\n\t\tif (x < 0 || x > 1) {\n\t\t\t_throwRangeError('x', x);\n\t\t}\n\n\t\tvar t = this.getTForX(x, epsilon);\n\t\treturn this.divideAtT(t);\n\t};\n\n\tCubicBezier.prototype.divideAtY = function (y, epsilon) {\n\t\tif (y < 0 || y > 1) {\n\t\t\t_throwRangeError('y', y);\n\t\t}\n\n\t\tvar t = this.getTForY(y, epsilon);\n\t\treturn this.divideAtT(t);\n\t};\n\n\tCubicBezier.prototype.clone = function () {\n\t\treturn new CubicBezier(this._p1.x, this._p1.y, this._p2.x, this._p2.y);\n\t};\n\n\tCubicBezier.prototype.toString = function () {\n\t\treturn \"cubic-bezier(\" + [\n\t\t\tthis._p1.x,\n\t\t\tthis._p1.y,\n\t\t\tthis._p2.x,\n\t\t\tthis._p2.y\n\t\t].join(\", \") + \")\";\n\t};\n\n\tCubicBezier.linear = function () {\n\t\treturn new CubicBezier();\n\t};\n\n\tCubicBezier.ease = function () {\n\t\treturn new CubicBezier(0.25, 0.1, 0.25, 1.0);\n\t};\n\tCubicBezier.linear = function () {\n\t\treturn new CubicBezier(0.0, 0.0, 1.0, 1.0);\n\t};\n\tCubicBezier.easeIn = function () {\n\t\treturn new CubicBezier(0.42, 0, 1.0, 1.0);\n\t};\n\tCubicBezier.easeOut = function () {\n\t\treturn new CubicBezier(0, 0, 0.58, 1.0);\n\t};\n\tCubicBezier.easeInOut = function () {\n\t\treturn new CubicBezier(0.42, 0, 0.58, 1.0);\n\t};\n}());\n\nif (typeof define !== 'undefined' && define.amd) {\n\t// AMD. Register as an anonymous module.\n\tdefine(function() {\n\t\t'use strict';\n\t\treturn {\n\t\t\tFTScroller: FTScroller,\n\t\t\tCubicBezier: CubicBezier\n\t\t};\n\t});\n} else if (typeof module !== 'undefined' && module.exports) {\n\tmodule.exports = function(domNode, options) {\n\t\t'use strict';\n\t\treturn new FTScroller(domNode, options);\n\t};\n\n\tmodule.exports.FTScroller = FTScroller;\n\tmodule.exports.CubicBezier = CubicBezier;\n}\n","active":false,"path":"/Users/matthew.brennan/Documents/ft-app/node_modules/ftscroller/lib/ftscroller.js","scroll":1792.0975505553974,"cursor":{"row":1853,"column":18}}]