{
  "name": "observe-js",
  "version": "0.0.0",
  "description": "ObserveJS =============",
  "main": "src/observe.js",
  "directories": {
    "example": "examples",
    "test": "tests"
  },
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/Polymer/ObserveJS.git"
  },
  "author": "",
  "license": "BSD",
  "readmeFilename": "README.md",
  "gitHead": "123e411687c6199c240b709d582b0e939cb14080",
  "devDependencies": {
    "chai": "*",
    "mocha": "*",
    "grunt": "*",
    "grunt-karma": "*",
    "karma": "~0.12.0",
    "karma-mocha": "*",
    "karma-firefox-launcher": "*",
    "karma-ie-launcher": "*",
    "karma-safari-launcher": "*",
    "karma-script-launcher": "*",
    "karma-crbot-reporter": "*"
  },
  "contributors": [
    {
      "name": "Google Inc.",
      "email": "*@google.com"
    }
  ],
  "readme": "[![Build status](http://www.polymer-project.org/build/observe-js/status.png \"Build status\")](http://build.chromium.org/p/client.polymer/waterfall) [![Analytics](https://ga-beacon.appspot.com/UA-39334307-2/Polymer/observe-js/README)](https://github.com/igrigorik/ga-beacon)\n\n## Learn the tech\n\n### Why observe-js?\n\nobserve-js is a library for observing changes in JavaScript data. It exposes a high-level API and uses Object.observe if available, and otherwise performs dirty-checking. observe-js requires ECMAScript 5.\n\n### Observable\n\nobserve-js implements a set of observers (PathObserver, ArrayObserver, ObjectObserver, CompoundObserver, ObserverTransform) which all implement the Observable interface:\n\n```JavaScript\n{\n  // Begins observation. Value changes will be reported by invoking |changeFn| with |opt_receiver| as\n  // the target, if provided. Returns the initial value of the observation.\n  open: function(changeFn, opt_receiver) {},\n\n  // Report any changes now (does nothing if there are no changes to report).\n  deliver: function() {},\n\n  // If there are changes to report, ignore them. Returns the current value of the observation.\n  discardChanges: function() {},\n\n  // Ends observation. Frees resources and drops references to observed objects.\n  close: function() {}\n}\n```\n\n### PathObserver\n\nPathObserver observes a \"value-at-a-path\" from a given object:\n\n```JavaScript\nvar obj = { foo: { bar: 'baz' } };\nvar observer = new PathObserver(obj, 'foo.bar');\nobserver.open(function(newValue, oldValue) {\n  // respond to obj.foo.bar having changed value.\n});\n```\n\nPathObserver will report a change whenever the value obtained by the corresponding path expression (e.g. `obj.foo.bar`) would return a different value.\n\nPathObserver also exposes a `setValue` method which attempts to update the underlying value. Setting the value does not affect notification state (in other words, a caller sets the value but does not `discardChanges`, the `changeFn` will be notified of the change).\n\n```JavaScript\nobserver.setValue('boo');\nassert(obj.foo.bar == 'boo');\n```\n\nNotes:\n * If the path is ever unreachable, the value is considered to be `undefined`.\n * If the path is empty (e.g. `''`), it is said to be the empty path and its value is its root object.\n * PathObservation respects values on the prototype chain\n\n### ArrayObserver\n\nArrayObserver observes the index-positions of an Array and reports changes as the minimal set of \"splices\" which would have had the same effect.\n\n```JavaScript\nvar arr = [0, 1, 2, 4];\nvar observer = new ArrayObserver(arr);\nobserver.open(function(splices) {\n  // respond to changes to the elements of arr.\n  splices.forEach(function(splice) {\n    splice.index; // index position that the change occurred.\n    splice.removed; // an array of values representing the sequence of elements which were removed\n    splice.addedCount; // the number of elements which were inserted.\n  });\n});\n```\n\nArrayObserver also exposes a utility function: `applySplices`. The purpose of `applySplices` is to transform a copy of an old state of an array into a copy of its current state, given the current state and the splices reported from the ArrayObserver.\n\n```JavaScript\nAraryObserver.applySplices = function(previous, current, splices) { }\n```\n\n### ObjectObserver\n\nObjectObserver observes the set of own-properties of an object and their values.\n\n```JavaScript\nvar myObj = { id: 1, foo: 'bar' };\nvar observer = new ObjectObserver(myObj);\nobserver.open(function(added, removed, changed, getOldValueFn) {\n  // respond to changes to the obj.\n  Object.keys(added).forEach(function(property) {\n    property; // a property which has been been added to obj\n    added[property]; // its value\n  });\n  Object.keys(removed).forEach(function(property) {\n    property; // a property which has been been removed from obj\n    getOldValueFn(property); // its old value\n  });\n  Object.keys(changed).forEach(function(property) {\n    property; // a property on obj which has changed value.\n    changed[property]; // its value\n    getOldValueFn(property); // its old value\n  });\n});\n```\n\n### CompoundObserver\n\nCompoundObserver allows simultaneous observation of multiple paths and/or Observables. It reports any and all changes in to the provided `changeFn` callback.\n\n```JavaScript\nvar obj = {\n  a: 1,\n  b: 2,\n};\n\nvar otherObj = { c: 3 };\n\nvar observer = new CompoundObserver();\nobserver.addPath(obj, 'a');\nobserver.addObserver(new PathObserver(obj, 'b'));\nobserver.addPath(otherObj, 'c');\nobserver.open(function(newValues, oldValues) {\n  // Use for-in to iterte which values have changed.\n  for (var i in oldValues) {\n    console.log('The ' + i + 'th value changed from: ' + newValues[i] + ' to: ' + oldValues[i]);\n  }\n});\n```\n\n\n### ObserverTransform\n\nObserverTransform is used to dynamically transform observed value(s).\n\n```JavaScript\nvar obj = { value: 10 };\nvar observer = new PathObserver(obj, 'value');\nfunction getValue(value) { return value * 2 };\nfunction setValue(value) { return value / 2 };\n\nvar transform = new ObserverTransform(observer, getValue, setValue);\n\n// returns 20.\ntransform.open(function(newValue, oldValue) {\n  console.log('new: ' + newValue + ', old: ' + oldValue);\n});\n\nobj.value = 20;\ntransform.deliver(); // 'new: 40, old: 20'\ntransform.setValue(4); // obj.value === 2;\n```\n\nObserverTransform can also be used to reduce a set of observed values to a single value:\n\n```JavaScript\nvar obj = { a: 1, b: 2, c: 3 };\nvar observer = new CompoundObserver();\nobserver.addPath(obj, 'a');\nobserver.addPath(obj, 'b');\nobserver.addPath(obj, 'c');\nvar transform = new ObserverTransform(observer, fuction(values) {\n  var value = 0;\n  for (var i = 0; i < values.length; i++)\n    value += values[i]\n  return value;\n});\n\n// returns 6.\ntransform.open(function(newValue, oldValue) {\n  console.log('new: ' + newValue + ', old: ' + oldValue);\n});\n\nobj.a = 2;\nobj.c = 10;\ntransform.deliver(); // 'new: 14, old: 6'\n```\n\n### Path objects\n\nA path is an ECMAScript expression consisting only of identifiers (`myVal`), member accesses (`foo.bar`) and key lookup with literal values (`arr[0]` `obj['str-value'].bar.baz`).\n\n`Path.get('foo.bar.baz')` returns a Path object which represents the path. Path objects have the following API:\n\n```JavaScript\n{\n  // Returns the current of the path from the provided object. If eval() is available, a compiled getter will be\n  // used for better performance.\n  getValueFrom: function(obj) { }\n\n\n  // Attempts to set the value of the path from the provided object. Returns true IFF the path was reachable and\n  // set.\n  setValueFrom: function(obj, newValue) { }\n}\n```\n\nPath objects are interned (e.g. `assert(Path.get('foo.bar.baz') === Path.get('foo.bar.baz'));`) and are used internally to avoid excessive parsing of path strings. Observers which take path strings as arguments will also accept Path objects.\n\n## About delivery of changes\n\nobserve-js is intended for use in environments which implement Object.observe, but it supports use in environments which do not.\n\nIf `Object.observe` is present, and observers have changes to report, their callbacks will be invoked at the end of the current turn (microtask). In a browser environment, this is generally at the end of an event.\n\nIf `Object.observe` is absent, `Platform.performMicrotaskCheckpoint()` must be called to trigger delivery of changes. If `Object.observe` is implemented, `Platform.performMicrotaskCheckpoint()` has no effect.\n",
  "bugs": {
    "url": "https://github.com/Polymer/ObserveJS/issues"
  },
  "homepage": "https://github.com/Polymer/ObserveJS",
  "_id": "observe-js@0.0.0",
  "_shasum": "ea5a347727c480c2211d2890f126d8285e2dd862",
  "_from": "../../../../../../../var/folders/nb/yrkkk0cx6jd1xw820d76p97wngv2__/T/npm-77779-aed24730/git-cache-5e3d91269537/fa70c37099026225876f7c7a26bdee7c48129f1c",
  "_resolved": "git://github.com/Polymer/observe-js.git#fa70c37099026225876f7c7a26bdee7c48129f1c"
}
